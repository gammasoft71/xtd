<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::text::basic_string_builder&lt; char_t, traits_t, allocator_t &gt; Class Template Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="namespacextd_1_1text.html">text</a></li><li class="navelem"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classxtd_1_1text_1_1basic__string__builder-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::text::basic_string_builder&lt; char_t, traits_t, allocator_t &gt; Class Template Reference<span class="mlabels"><span class="mlabel">final</span></span><div class="ingroups"><a class="el" href="group__libraries.html">ï¹¡ libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a> &#124; <a class="el" href="group__system.html">system</a> &raquo; <a class="el" href="group__text.html">text</a> &#124; <a class="el" href="group__system.html">system</a> &raquo; <a class="el" href="group__strings.html">strings</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::text::basic_string_builder&lt; char_t, traits_t, allocator_t &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1text_1_1basic__string__builder.png" usemap="#xtd::text::basic_5Fstring_5Fbuilder_3C_20char_5Ft_2C_20traits_5Ft_2C_20allocator_5Ft_20_3E_map" alt=""/>
  <map id="xtd::text::basic_5Fstring_5Fbuilder_3C_20char_5Ft_2C_20traits_5Ft_2C_20allocator_5Ft_20_3E_map" name="xtd::text::basic_5Fstring_5Fbuilder_3C_20char_5Ft_2C_20traits_5Ft_2C_20allocator_5Ft_20_3E_map">
<area href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes...." alt="xtd::object" shape="rect" coords="0,56,743,80"/>
<area href="classxtd_1_1iequatable.html" title="Defines a generalized method that a value type or class implements to create a type-specific method f..." alt="xtd::iequatable&lt; type_t &gt;" shape="rect" coords="753,56,1496,80"/>
<area href="classxtd_1_1interface.html" title="Represent an interface class." alt="xtd::interface" shape="rect" coords="376,0,1119,24"/>
<area href="classxtd_1_1extensions_1_1equality__operators.html" alt="xtd::extensions::equality_operators&lt; type_t, iequatable&lt; type_t &gt; &gt;" shape="rect" coords="1129,0,1872,24"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt;<br />
class xtd::text::basic_string_builder&lt; char_t, traits_t, allocator_t &gt;</div><p>Represents a mutable string of characters. This class cannot be inherited. </p>
<dl class="section user"><dt>Namespace</dt><dd><a class="el" href="namespacextd_1_1text.html" title="Contains classes that represent ASCII and Unicode character encodings; abstract base classes for conv...">xtd::text</a> </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> class represents a string-like object whose value is a mutable sequence of characters. </dd>
<dd>
<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> implements <a href="https://en.cppreference.com/w/cpp/basic_string_builder/basic_string_builder">std::basic_string&lt;char&gt;</a> and therefore offers the full API of std::basic_string. </dd>
<dd>
Several aliases for common character types are provided: </dd>
<dd>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Definition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__strings.html#ga01dd8c7bcd2cfe43dec73df5b56f9d57" title="Represents text as a sequence of UTF-8 code units.">xtd::text::string_builder</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> &lt;char&gt;    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__strings.html#gae904e0b84e59ec1fb1f7b36c5d297170" title="Represents text as a sequence of UTF-16 code units.">xtd::text::u16string_builder</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> &lt;<a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570" title="Represents a 16-bit unicode character.">xtd::char16</a>&gt;    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__strings.html#gaf400587a5eb8700190f8519397e6a119" title="Represents text as a sequence of UTF-32 code units.">xtd::text::u32string_builder</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> &lt;<a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92" title="Represents a 32-bit unicode character.">xtd::char32</a>&gt;    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__strings.html#ga42708caf1efb39fc106bcbe5194b84bb" title="Represents text as a sequence of UTF-8 code units.">xtd::text::u8string_builder</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> &lt;<a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a" title="Represents a 8-bit unicode character.">xtd::char8</a>&gt;    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__strings.html#ga516498bf5a31bcaeee8b68db8b27166d" title="Represents text as a sequence of UTF-16 code unit on Windows or UTF-32 code unit on non-Windows syste...">xtd::text::wstring_builder</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> &lt;<a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518" title="Represents a wide character.">xtd::wchar</a>&gt;   </td></tr>
</table>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ip_address_8cpp-example.html#_a1">ip_address.cpp</a>, <a class="el" href="ostream_unit_test_8cpp-example.html#_a3">ostream_unit_test.cpp</a>, and <a class="el" href="string_builder_append_8cpp-example.html#_a1">string_builder_append.cpp</a>.</dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Aliases</h2></td></tr>
<tr class="memitem:ac9f39b0cc8b359570352fb6c86f17424"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ac9f39b0cc8b359570352fb6c86f17424">base_type</a> = std::basic_string&lt; char_t, traits_t, allocator_t &gt;</td></tr>
<tr class="memdesc:ac9f39b0cc8b359570352fb6c86f17424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the basic string base type.  <br /></td></tr>
<tr class="separator:ac9f39b0cc8b359570352fb6c86f17424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f317b652276573d985e1cca5d94d4e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a24f317b652276573d985e1cca5d94d4e">traits_type</a> = typename base_type::traits_type</td></tr>
<tr class="memdesc:a24f317b652276573d985e1cca5d94d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the basic string traits type.  <br /></td></tr>
<tr class="separator:a24f317b652276573d985e1cca5d94d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4750931de93fb98ca4024209bd18cc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> = typename base_type::value_type</td></tr>
<tr class="memdesc:afc4750931de93fb98ca4024209bd18cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the basic string value type.  <br /></td></tr>
<tr class="separator:afc4750931de93fb98ca4024209bd18cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb22ca3eb2fea9a222bddac1b5282675"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aeb22ca3eb2fea9a222bddac1b5282675">allocator_type</a> = typename base_type::allocator_type</td></tr>
<tr class="memdesc:aeb22ca3eb2fea9a222bddac1b5282675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the basic string allocator type.  <br /></td></tr>
<tr class="separator:aeb22ca3eb2fea9a222bddac1b5282675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d3525c87b582cd9dbf27852cf1199f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> = typename base_type::size_type</td></tr>
<tr class="memdesc:a00d3525c87b582cd9dbf27852cf1199f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the basic string size type.  <br /></td></tr>
<tr class="separator:a00d3525c87b582cd9dbf27852cf1199f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09714b6f7df9b2a5b5372affd6a4265d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a09714b6f7df9b2a5b5372affd6a4265d">difference_type</a> = typename base_type::difference_type</td></tr>
<tr class="memdesc:a09714b6f7df9b2a5b5372affd6a4265d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the basic string difference type.  <br /></td></tr>
<tr class="separator:a09714b6f7df9b2a5b5372affd6a4265d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9b46ae1d66c7d5c9ac716899c0be58"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a9b9b46ae1d66c7d5c9ac716899c0be58">reference</a> = typename base_type::reference</td></tr>
<tr class="memdesc:a9b9b46ae1d66c7d5c9ac716899c0be58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the basic string referecne type.  <br /></td></tr>
<tr class="separator:a9b9b46ae1d66c7d5c9ac716899c0be58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9fff0c8a14fc2115fe86547402e0b4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a7a9fff0c8a14fc2115fe86547402e0b4">const_reference</a> = typename base_type::const_reference</td></tr>
<tr class="memdesc:a7a9fff0c8a14fc2115fe86547402e0b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the basic string const referecne type.  <br /></td></tr>
<tr class="separator:a7a9fff0c8a14fc2115fe86547402e0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62aee9e769ee262f5deae94ff8ea03d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aa62aee9e769ee262f5deae94ff8ea03d">pointer</a> = typename base_type::pointer</td></tr>
<tr class="memdesc:aa62aee9e769ee262f5deae94ff8ea03d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the basic string pointer type.  <br /></td></tr>
<tr class="separator:aa62aee9e769ee262f5deae94ff8ea03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c11cf7a49f5f7c9bea14c37f003fafa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> = typename base_type::const_pointer</td></tr>
<tr class="memdesc:a5c11cf7a49f5f7c9bea14c37f003fafa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the basic string const pointer type.  <br /></td></tr>
<tr class="separator:a5c11cf7a49f5f7c9bea14c37f003fafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7df40d1cb269bbcdd170dde0f5dc20"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aae7df40d1cb269bbcdd170dde0f5dc20">iterator</a> = typename base_type::iterator</td></tr>
<tr class="memdesc:aae7df40d1cb269bbcdd170dde0f5dc20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the basic string iterator type.  <br /></td></tr>
<tr class="separator:aae7df40d1cb269bbcdd170dde0f5dc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5600ab3681a2caadbce6938ea712fa1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a> = typename base_type::const_iterator</td></tr>
<tr class="memdesc:ae5600ab3681a2caadbce6938ea712fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the basic string const iterator type.  <br /></td></tr>
<tr class="separator:ae5600ab3681a2caadbce6938ea712fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede664826bfa8b77004d2d6820265a2b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aede664826bfa8b77004d2d6820265a2b">reverse_iterator</a> = typename base_type::reverse_iterator</td></tr>
<tr class="memdesc:aede664826bfa8b77004d2d6820265a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the basic string reverse iterator type.  <br /></td></tr>
<tr class="separator:aede664826bfa8b77004d2d6820265a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa1a4e25bf1791171d367f204d8908d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#adfa1a4e25bf1791171d367f204d8908d">const_reverse_iterator</a> = typename base_type::const_reverse_iterator</td></tr>
<tr class="memdesc:adfa1a4e25bf1791171d367f204d8908d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the basic string const reverse iterator type.  <br /></td></tr>
<tr class="separator:adfa1a4e25bf1791171d367f204d8908d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Fields</h2></td></tr>
<tr class="memitem:a08bf02d73655eeb3dbc8eac397b81123"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123">npos</a></td></tr>
<tr class="memdesc:a08bf02d73655eeb3dbc8eac397b81123"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a special value equal to the maximum value representable by the type <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">xtd::size</a>.  <br /></td></tr>
<tr class="separator:a08bf02d73655eeb3dbc8eac397b81123"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Constructors</h2></td></tr>
<tr class="memitem:a6bbc2dc030748cdd71c255645df68db7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a6bbc2dc030748cdd71c255645df68db7">basic_string_builder</a> ()=default</td></tr>
<tr class="memdesc:a6bbc2dc030748cdd71c255645df68db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>.  <br /></td></tr>
<tr class="separator:a6bbc2dc030748cdd71c255645df68db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34138ab1b00c5623fd78d2e3a3737764"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a34138ab1b00c5623fd78d2e3a3737764">basic_string_builder</a> (<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a1fc6dca79d34264f29e710ffe3ce6e89">capacity</a>)</td></tr>
<tr class="memdesc:a34138ab1b00c5623fd78d2e3a3737764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> class using the specified capacity.  <br /></td></tr>
<tr class="separator:a34138ab1b00c5623fd78d2e3a3737764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8c9b34721a5dce3830f0e76d94d517"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3c8c9b34721a5dce3830f0e76d94d517">basic_string_builder</a> (<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a1fc6dca79d34264f29e710ffe3ce6e89">capacity</a>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e">max_capacity</a>)</td></tr>
<tr class="memdesc:a3c8c9b34721a5dce3830f0e76d94d517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> class that starts with a specified capacity and can grow to a specified maximum.  <br /></td></tr>
<tr class="separator:a3c8c9b34721a5dce3830f0e76d94d517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a982761414718b3de9e273d2ffa0bb9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a4a982761414718b3de9e273d2ffa0bb9">basic_string_builder</a> (const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> &gt; &amp;value)</td></tr>
<tr class="memdesc:a4a982761414718b3de9e273d2ffa0bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> class using the specified string.  <br /></td></tr>
<tr class="separator:a4a982761414718b3de9e273d2ffa0bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf3305b60b88f2f2da9a27d89bec228"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a9cf3305b60b88f2f2da9a27d89bec228">basic_string_builder</a> (const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> &gt; &amp;value, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a1fc6dca79d34264f29e710ffe3ce6e89">capacity</a>)</td></tr>
<tr class="memdesc:a9cf3305b60b88f2f2da9a27d89bec228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> class using the specified string and capacity.  <br /></td></tr>
<tr class="separator:a9cf3305b60b88f2f2da9a27d89bec228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092c81a4ac625c0e2a7302e229d70afe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a092c81a4ac625c0e2a7302e229d70afe">basic_string_builder</a> (const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> &gt; &amp;value, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> start_index, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a69a83b009389b1b5706ce202a2989afd">length</a>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a1fc6dca79d34264f29e710ffe3ce6e89">capacity</a>)</td></tr>
<tr class="memdesc:a092c81a4ac625c0e2a7302e229d70afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> class from the specified substring and capacity.  <br /></td></tr>
<tr class="separator:a092c81a4ac625c0e2a7302e229d70afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95cd1bd91463f31ace42004beafe7dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ab95cd1bd91463f31ace42004beafe7dd">basic_string_builder</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aeb22ca3eb2fea9a222bddac1b5282675">allocator_type</a> &amp;allocator) noexcept</td></tr>
<tr class="memdesc:ab95cd1bd91463f31ace42004beafe7dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified allocator.  <br /></td></tr>
<tr class="separator:ab95cd1bd91463f31ace42004beafe7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f315a639b6c053a7a6c7fa64f0d7d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ab4f315a639b6c053a7a6c7fa64f0d7d8">basic_string_builder</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str) noexcept</td></tr>
<tr class="memdesc:ab4f315a639b6c053a7a6c7fa64f0d7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:ab4f315a639b6c053a7a6c7fa64f0d7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20ff6e0d2e0c4f2249b011b9dc57c15"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#af20ff6e0d2e0c4f2249b011b9dc57c15">basic_string_builder</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str, const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aeb22ca3eb2fea9a222bddac1b5282675">allocator_type</a> &amp;allocator) noexcept</td></tr>
<tr class="memdesc:af20ff6e0d2e0c4f2249b011b9dc57c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified string to copy and allocator.  <br /></td></tr>
<tr class="separator:af20ff6e0d2e0c4f2249b011b9dc57c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2eaaca7b4913f37dedbb0193b1fb1f3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ac2eaaca7b4913f37dedbb0193b1fb1f3">basic_string_builder</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index)</td></tr>
<tr class="memdesc:ac2eaaca7b4913f37dedbb0193b1fb1f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified substring at index.  <br /></td></tr>
<tr class="separator:ac2eaaca7b4913f37dedbb0193b1fb1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e01bf4600fcf39d0fd6f655a5e7d48"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74e01bf4600fcf39d0fd6f655a5e7d48">basic_string_builder</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index, const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aeb22ca3eb2fea9a222bddac1b5282675">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a74e01bf4600fcf39d0fd6f655a5e7d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified substring at index and allocator.  <br /></td></tr>
<tr class="separator:a74e01bf4600fcf39d0fd6f655a5e7d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b1349c7b1ec9e5e4a951d63e6efdf3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ab3b1349c7b1ec9e5e4a951d63e6efdf3">basic_string_builder</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> count)</td></tr>
<tr class="memdesc:ab3b1349c7b1ec9e5e4a951d63e6efdf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified substring at index and count characters.  <br /></td></tr>
<tr class="separator:ab3b1349c7b1ec9e5e4a951d63e6efdf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc92a0f7ba80c74866fb05686f38458"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a4bc92a0f7ba80c74866fb05686f38458">basic_string_builder</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> count, const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aeb22ca3eb2fea9a222bddac1b5282675">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a4bc92a0f7ba80c74866fb05686f38458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified substring at index, count characters and allocator.  <br /></td></tr>
<tr class="separator:a4bc92a0f7ba80c74866fb05686f38458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41137d5915ae8dee52557e6b0804e81"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aa41137d5915ae8dee52557e6b0804e81">basic_string_builder</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&amp;str) noexcept</td></tr>
<tr class="memdesc:aa41137d5915ae8dee52557e6b0804e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified string to move.  <br /></td></tr>
<tr class="separator:aa41137d5915ae8dee52557e6b0804e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616f2a3c09f7ba771fece8d01e27caf0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a616f2a3c09f7ba771fece8d01e27caf0">basic_string_builder</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&amp;str, const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aeb22ca3eb2fea9a222bddac1b5282675">allocator_type</a> &amp;allocator) noexcept</td></tr>
<tr class="memdesc:a616f2a3c09f7ba771fece8d01e27caf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified string to move and allocator.  <br /></td></tr>
<tr class="separator:a616f2a3c09f7ba771fece8d01e27caf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5dcb91cdaddda62137663dcbaad59e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aa5dcb91cdaddda62137663dcbaad59e4">basic_string_builder</a> (<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> count, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> character)</td></tr>
<tr class="separator:aa5dcb91cdaddda62137663dcbaad59e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabace22c8a1a6c4cd4bb18d983e7d48"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afabace22c8a1a6c4cd4bb18d983e7d48">basic_string_builder</a> (<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> count, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> character, const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aeb22ca3eb2fea9a222bddac1b5282675">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:afabace22c8a1a6c4cd4bb18d983e7d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified count copies of character and specified allocator.  <br /></td></tr>
<tr class="separator:afabace22c8a1a6c4cd4bb18d983e7d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c12587ba88777f36f0294887119931"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#af7c12587ba88777f36f0294887119931">basic_string_builder</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> character, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> count)</td></tr>
<tr class="memdesc:af7c12587ba88777f36f0294887119931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified count copies of character.  <br /></td></tr>
<tr class="separator:af7c12587ba88777f36f0294887119931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1fe22bb536b67af64a42aeba74c9b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5d1fe22bb536b67af64a42aeba74c9b3">basic_string_builder</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> character, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> count, const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aeb22ca3eb2fea9a222bddac1b5282675">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a5d1fe22bb536b67af64a42aeba74c9b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified count copies of character and specified allocator.  <br /></td></tr>
<tr class="separator:a5d1fe22bb536b67af64a42aeba74c9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab918a3b6ff903ef3e016ef52d2e45860"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ab918a3b6ff903ef3e016ef52d2e45860">basic_string_builder</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> str)</td></tr>
<tr class="memdesc:ab918a3b6ff903ef3e016ef52d2e45860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:ab918a3b6ff903ef3e016ef52d2e45860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefaf1bb131ee0f2c41f827936e8b34c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aefaf1bb131ee0f2c41f827936e8b34c7">basic_string_builder</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> str, const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aeb22ca3eb2fea9a222bddac1b5282675">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:aefaf1bb131ee0f2c41f827936e8b34c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified string to copy, and allocator.  <br /></td></tr>
<tr class="separator:aefaf1bb131ee0f2c41f827936e8b34c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f09400b466cc35471381198fb4bdbe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ab3f09400b466cc35471381198fb4bdbe">basic_string_builder</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> count)</td></tr>
<tr class="memdesc:ab3f09400b466cc35471381198fb4bdbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified substring and count characters.  <br /></td></tr>
<tr class="separator:ab3f09400b466cc35471381198fb4bdbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ae8d1b9af820c62e746a683c966ccb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a61ae8d1b9af820c62e746a683c966ccb">basic_string_builder</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> count, const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aeb22ca3eb2fea9a222bddac1b5282675">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a61ae8d1b9af820c62e746a683c966ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified substring, count characters and allocator.  <br /></td></tr>
<tr class="separator:a61ae8d1b9af820c62e746a683c966ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b43fccbf6aebef6e176b699a44c63e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a56b43fccbf6aebef6e176b699a44c63e">basic_string_builder</a> (const std::basic_string&lt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:a56b43fccbf6aebef6e176b699a44c63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:a56b43fccbf6aebef6e176b699a44c63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e09d04571bf80582564efa57e5de001"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3e09d04571bf80582564efa57e5de001">basic_string_builder</a> (const std::basic_string&lt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> &gt; &amp;str, const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aeb22ca3eb2fea9a222bddac1b5282675">allocator_type</a> &amp;allocator) noexcept</td></tr>
<tr class="memdesc:a3e09d04571bf80582564efa57e5de001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified string to copy and allocator.  <br /></td></tr>
<tr class="separator:a3e09d04571bf80582564efa57e5de001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124dac9dfd4970e6409eb140fb4d21c3"><td class="memTemplParams" colspan="2">template&lt;class input_iterator_t &gt; </td></tr>
<tr class="memitem:a124dac9dfd4970e6409eb140fb4d21c3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a124dac9dfd4970e6409eb140fb4d21c3">basic_string_builder</a> (input_iterator_t first, input_iterator_t last)</td></tr>
<tr class="memdesc:a124dac9dfd4970e6409eb140fb4d21c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified first and last iterators of substring.  <br /></td></tr>
<tr class="separator:a124dac9dfd4970e6409eb140fb4d21c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca9835968f490d8e16087d3a3374768"><td class="memTemplParams" colspan="2">template&lt;class input_iterator_t &gt; </td></tr>
<tr class="memitem:abca9835968f490d8e16087d3a3374768"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#abca9835968f490d8e16087d3a3374768">basic_string_builder</a> (input_iterator_t first, input_iterator_t last, const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aeb22ca3eb2fea9a222bddac1b5282675">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:abca9835968f490d8e16087d3a3374768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified first and last iterators of substring and allocator.  <br /></td></tr>
<tr class="separator:abca9835968f490d8e16087d3a3374768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe22469b9a3a43e3c96898f3f6fbbf65"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#abe22469b9a3a43e3c96898f3f6fbbf65">basic_string_builder</a> (std::initializer_list&lt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> &gt; il)</td></tr>
<tr class="memdesc:abe22469b9a3a43e3c96898f3f6fbbf65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified initializer list.  <br /></td></tr>
<tr class="separator:abe22469b9a3a43e3c96898f3f6fbbf65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7cf422a1119c0190cab3c9de2b7363"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ada7cf422a1119c0190cab3c9de2b7363">basic_string_builder</a> (std::initializer_list&lt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> &gt; il, const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aeb22ca3eb2fea9a222bddac1b5282675">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:ada7cf422a1119c0190cab3c9de2b7363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified initializer list and allocator.  <br /></td></tr>
<tr class="separator:ada7cf422a1119c0190cab3c9de2b7363"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Properties</h2></td></tr>
<tr class="memitem:a8ceb59751b0c5fcc1ea228015d4d2b5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a7a9fff0c8a14fc2115fe86547402e0b4">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a8ceb59751b0c5fcc1ea228015d4d2b5b">back</a> () const</td></tr>
<tr class="memdesc:a8ceb59751b0c5fcc1ea228015d4d2b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to the last character in the string.  <br /></td></tr>
<tr class="separator:a8ceb59751b0c5fcc1ea228015d4d2b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8d874509ba8435d025a1a3c2c1cb56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a9b9b46ae1d66c7d5c9ac716899c0be58">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aea8d874509ba8435d025a1a3c2c1cb56">back</a> ()</td></tr>
<tr class="memdesc:aea8d874509ba8435d025a1a3c2c1cb56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to the last character in the string.  <br /></td></tr>
<tr class="separator:aea8d874509ba8435d025a1a3c2c1cb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20a8cc18d7386e351fd5e3850efa269"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ab20a8cc18d7386e351fd5e3850efa269">begin</a> () const</td></tr>
<tr class="memdesc:ab20a8cc18d7386e351fd5e3850efa269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first character of the string.  <br /></td></tr>
<tr class="separator:ab20a8cc18d7386e351fd5e3850efa269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd10efd565a623e44c46e4b8ffb76bfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aae7df40d1cb269bbcdd170dde0f5dc20">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd">begin</a> ()</td></tr>
<tr class="memdesc:acd10efd565a623e44c46e4b8ffb76bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first character of the string.  <br /></td></tr>
<tr class="separator:acd10efd565a623e44c46e4b8ffb76bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb10a6f59a4c7ba5d4b65ccca8f6695"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a8cb10a6f59a4c7ba5d4b65ccca8f6695">c_str</a> () const noexcept</td></tr>
<tr class="memdesc:a8cb10a6f59a4c7ba5d4b65ccca8f6695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to a null-terminated character array with data equivalent to those stored in the string.  <br /></td></tr>
<tr class="separator:a8cb10a6f59a4c7ba5d4b65ccca8f6695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc6dca79d34264f29e710ffe3ce6e89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a1fc6dca79d34264f29e710ffe3ce6e89">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:a1fc6dca79d34264f29e710ffe3ce6e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of characters that the string has currently allocated space for.  <br /></td></tr>
<tr class="separator:a1fc6dca79d34264f29e710ffe3ce6e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abc22d3c5615941bc4d8030dedbff77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a1abc22d3c5615941bc4d8030dedbff77">capacity</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> value)</td></tr>
<tr class="memdesc:a1abc22d3c5615941bc4d8030dedbff77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of characters that the string has currently allocated space for.  <br /></td></tr>
<tr class="separator:a1abc22d3c5615941bc4d8030dedbff77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa588349c0f4a4068b662b5b0d168bda6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aa588349c0f4a4068b662b5b0d168bda6">cbegin</a> () const</td></tr>
<tr class="memdesc:aa588349c0f4a4068b662b5b0d168bda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first character of the string.  <br /></td></tr>
<tr class="separator:aa588349c0f4a4068b662b5b0d168bda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5944beeb6ea364aeef256dc0089c7c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ac9f39b0cc8b359570352fb6c86f17424">base_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#abe5944beeb6ea364aeef256dc0089c7c">chars</a> () const noexcept</td></tr>
<tr class="memdesc:abe5944beeb6ea364aeef256dc0089c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the underlying base type.  <br /></td></tr>
<tr class="separator:abe5944beeb6ea364aeef256dc0089c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05538f86dee6b57b195ac7dc6030fc50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ac9f39b0cc8b359570352fb6c86f17424">base_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a05538f86dee6b57b195ac7dc6030fc50">chars</a> () noexcept</td></tr>
<tr class="memdesc:a05538f86dee6b57b195ac7dc6030fc50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the underlying base type.  <br /></td></tr>
<tr class="separator:a05538f86dee6b57b195ac7dc6030fc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf812628211c7c6282f30ba9e9ce642"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aebf812628211c7c6282f30ba9e9ce642">cend</a> () const</td></tr>
<tr class="memdesc:aebf812628211c7c6282f30ba9e9ce642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the character following the last character of the string. This character acts as a placeholder, attempting to access it results in undefined behavior.  <br /></td></tr>
<tr class="separator:aebf812628211c7c6282f30ba9e9ce642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f01d6712b1503a85e4afb98b217f5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad1f01d6712b1503a85e4afb98b217f5f">data</a> () const noexcept</td></tr>
<tr class="memdesc:ad1f01d6712b1503a85e4afb98b217f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the underlying array serving as character storage. The pointer is such that the range [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad361d27ed3369d1359dc34e135dede8a" title="Returns a pointer to the underlying array serving as character storage. The pointer is such that the ...">data()</a></code>, <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad361d27ed3369d1359dc34e135dede8a" title="Returns a pointer to the underlying array serving as character storage. The pointer is such that the ...">data()</a> + <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a></code>] is valid and the values in it correspond to the values stored in the string.  <br /></td></tr>
<tr class="separator:ad1f01d6712b1503a85e4afb98b217f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad361d27ed3369d1359dc34e135dede8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aa62aee9e769ee262f5deae94ff8ea03d">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad361d27ed3369d1359dc34e135dede8a">data</a> () noexcept</td></tr>
<tr class="memdesc:ad361d27ed3369d1359dc34e135dede8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the underlying array serving as character storage. The pointer is such that the range [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad361d27ed3369d1359dc34e135dede8a" title="Returns a pointer to the underlying array serving as character storage. The pointer is such that the ...">data()</a></code>, <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad361d27ed3369d1359dc34e135dede8a" title="Returns a pointer to the underlying array serving as character storage. The pointer is such that the ...">data()</a> + <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a></code>] is valid and the values in it correspond to the values stored in the string.  <br /></td></tr>
<tr class="separator:ad361d27ed3369d1359dc34e135dede8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79077a3108f556f2ce8e4231c607fde"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ac79077a3108f556f2ce8e4231c607fde">empty</a> () const noexcept</td></tr>
<tr class="memdesc:ac79077a3108f556f2ce8e4231c607fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the string has no characters, i.e. whether <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> == <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a32e986bfe09f3fef3a459b2a7a7b866b" title="Returns an iterator to the character following the last character of the string. This character acts ...">end()</a></code>.  <br /></td></tr>
<tr class="separator:ac79077a3108f556f2ce8e4231c607fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef3ac5569a780cc93f3abb76f74fef2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aeef3ac5569a780cc93f3abb76f74fef2">end</a> () const</td></tr>
<tr class="memdesc:aeef3ac5569a780cc93f3abb76f74fef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the character following the last character of the string. This character acts as a placeholder, attempting to access it results in undefined behavior.  <br /></td></tr>
<tr class="separator:aeef3ac5569a780cc93f3abb76f74fef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e986bfe09f3fef3a459b2a7a7b866b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aae7df40d1cb269bbcdd170dde0f5dc20">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a32e986bfe09f3fef3a459b2a7a7b866b">end</a> ()</td></tr>
<tr class="memdesc:a32e986bfe09f3fef3a459b2a7a7b866b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the character following the last character of the string. This character acts as a placeholder, attempting to access it results in undefined behavior.  <br /></td></tr>
<tr class="separator:a32e986bfe09f3fef3a459b2a7a7b866b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33db704e732528f8711c29847c1a36e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a7a9fff0c8a14fc2115fe86547402e0b4">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ac33db704e732528f8711c29847c1a36e">front</a> () const</td></tr>
<tr class="memdesc:ac33db704e732528f8711c29847c1a36e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to the first character in the string. The behavior is undefined if <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ac79077a3108f556f2ce8e4231c607fde" title="Checks if the string has no characters, i.e. whether begin() == end().">empty()</a> is <code>true</code>.  <br /></td></tr>
<tr class="separator:ac33db704e732528f8711c29847c1a36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b43937b0cd6ab3199960fd2bb86d56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a9b9b46ae1d66c7d5c9ac716899c0be58">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a69b43937b0cd6ab3199960fd2bb86d56">front</a> ()</td></tr>
<tr class="memdesc:a69b43937b0cd6ab3199960fd2bb86d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to the first character in the string. The behavior is undefined if <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ac79077a3108f556f2ce8e4231c607fde" title="Checks if the string has no characters, i.e. whether begin() == end().">empty()</a> is <code>true</code>.  <br /></td></tr>
<tr class="separator:a69b43937b0cd6ab3199960fd2bb86d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a83b009389b1b5706ce202a2989afd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a69a83b009389b1b5706ce202a2989afd">length</a> () const noexcept</td></tr>
<tr class="memdesc:a69a83b009389b1b5706ce202a2989afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or sets the length of the current <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object.  <br /></td></tr>
<tr class="separator:a69a83b009389b1b5706ce202a2989afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259a72058d7f426ff10ba30079c26ead"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a259a72058d7f426ff10ba30079c26ead">length</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> value) noexcept</td></tr>
<tr class="memdesc:a259a72058d7f426ff10ba30079c26ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets or sets the length of the current <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object.  <br /></td></tr>
<tr class="separator:a259a72058d7f426ff10ba30079c26ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a9b0e909ef5975e6ac07821b8b100e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e">max_capacity</a> () const noexcept</td></tr>
<tr class="memdesc:a82a9b0e909ef5975e6ac07821b8b100e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of characters that the string has currently allocated space for.  <br /></td></tr>
<tr class="separator:a82a9b0e909ef5975e6ac07821b8b100e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36eabe6c7e3276bcd466f1fbb78e623"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aa36eabe6c7e3276bcd466f1fbb78e623">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:aa36eabe6c7e3276bcd466f1fbb78e623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements the string is able to hold due to system or library implementation limitations, i.e. <code>std::distance(<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a32e986bfe09f3fef3a459b2a7a7b866b" title="Returns an iterator to the character following the last character of the string. This character acts ...">end()</a>)</code> for the largest string.  <br /></td></tr>
<tr class="separator:aa36eabe6c7e3276bcd466f1fbb78e623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0bcb20cc5e977d053c10714929242c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad0bcb20cc5e977d053c10714929242c6">size</a> () const noexcept</td></tr>
<tr class="memdesc:ad0bcb20cc5e977d053c10714929242c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of <code>char_t</code> elements in the string, i.e. <code>std::distance(<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a32e986bfe09f3fef3a459b2a7a7b866b" title="Returns an iterator to the character following the last character of the string. This character acts ...">end()</a>)</code>.  <br /></td></tr>
<tr class="separator:ad0bcb20cc5e977d053c10714929242c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Methods</h2></td></tr>
<tr class="memitem:a74b530fbbad4b6b67da525a5b401219d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a> (const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t &gt; &amp;value)</td></tr>
<tr class="memdesc:a74b530fbbad4b6b67da525a5b401219d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a copy of the specified string to this instance.  <br /></td></tr>
<tr class="separator:a74b530fbbad4b6b67da525a5b401219d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da9e6a8896481aabbb6dce74a762416"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a4da9e6a8896481aabbb6dce74a762416">append</a> (const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t &gt; &amp;value, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> start_index, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count)</td></tr>
<tr class="memdesc:a4da9e6a8896481aabbb6dce74a762416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a copy of a specified substring to this instance.  <br /></td></tr>
<tr class="separator:a4da9e6a8896481aabbb6dce74a762416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcca2132d878dd94d8994e7ef8fad237"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afcca2132d878dd94d8994e7ef8fad237">append</a> (<a class="el" href="group__types.html#gab7230dbe491f8bcef5e5f8bdaba5e27f">xtd::boolean</a> value)</td></tr>
<tr class="memdesc:afcca2132d878dd94d8994e7ef8fad237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the string representation of a specified boolean value to this instance.  <br /></td></tr>
<tr class="separator:afcca2132d878dd94d8994e7ef8fad237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2eccf50e17279bf21511fd60903ab2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a7f2eccf50e17279bf21511fd60903ab2">append</a> (<a class="el" href="group__types.html#gabb9d3031d62e3725b4265c7e5d2a98e1">xtd::byte</a> value)</td></tr>
<tr class="memdesc:a7f2eccf50e17279bf21511fd60903ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the string representation of a specified 8-bit unsigned value to this instance.  <br /></td></tr>
<tr class="separator:a7f2eccf50e17279bf21511fd60903ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665936538d24374216c72ac789df1a94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a665936538d24374216c72ac789df1a94">append</a> (<a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a">xtd::decimal</a> value)</td></tr>
<tr class="memdesc:a665936538d24374216c72ac789df1a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the string representation of a specified decimal value to this instance.  <br /></td></tr>
<tr class="separator:a665936538d24374216c72ac789df1a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31334474f22063e04a4113319f8b33b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a31334474f22063e04a4113319f8b33b6">append</a> (double value)</td></tr>
<tr class="memdesc:a31334474f22063e04a4113319f8b33b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the string representation of a specified double value to this instance.  <br /></td></tr>
<tr class="separator:a31334474f22063e04a4113319f8b33b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63a690e346ea38d7215307e9583d98e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae63a690e346ea38d7215307e9583d98e">append</a> (<a class="el" href="group__types.html#ga4c9f72f7ab9ea9919c93a1a2b245ab71">xtd::single</a> value)</td></tr>
<tr class="memdesc:ae63a690e346ea38d7215307e9583d98e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the string representation of a specified single value to this instance.  <br /></td></tr>
<tr class="separator:ae63a690e346ea38d7215307e9583d98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2432a93c66bd22b0e7e92318109d0821"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a2432a93c66bd22b0e7e92318109d0821">append</a> (<a class="el" href="group__types.html#ga09d26135a9af4f7a5f4cae382627d6d1">xtd::int16</a> value)</td></tr>
<tr class="memdesc:a2432a93c66bd22b0e7e92318109d0821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the string representation of a specified 16-bit signed integer value to this instance.  <br /></td></tr>
<tr class="separator:a2432a93c66bd22b0e7e92318109d0821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391439e1450dd6677d8eb32a6c2b67d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a391439e1450dd6677d8eb32a6c2b67d7">append</a> (<a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a> value)</td></tr>
<tr class="memdesc:a391439e1450dd6677d8eb32a6c2b67d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the string representation of a specified 32-bit signed integer value to this instance.  <br /></td></tr>
<tr class="separator:a391439e1450dd6677d8eb32a6c2b67d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c74d861600b24e5c2356537b5a50473"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a8c74d861600b24e5c2356537b5a50473">append</a> (<a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4">xtd::int64</a> value)</td></tr>
<tr class="memdesc:a8c74d861600b24e5c2356537b5a50473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the string representation of a specified 64-bit signed integer value to this instance.  <br /></td></tr>
<tr class="separator:a8c74d861600b24e5c2356537b5a50473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc9f3ddffa40df1d58f755211c6b1ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3dc9f3ddffa40df1d58f755211c6b1ac">append</a> (<a class="el" href="group__types.html#ga37e983ceedf5a7f73bc4568eaeae0aa2">xtd::sbyte</a> value)</td></tr>
<tr class="memdesc:a3dc9f3ddffa40df1d58f755211c6b1ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the string representation of a specified 8-bit signed integer value to this instance.  <br /></td></tr>
<tr class="separator:a3dc9f3ddffa40df1d58f755211c6b1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86f131b2cd185c31f509e37d2a91e18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae86f131b2cd185c31f509e37d2a91e18">append</a> (<a class="el" href="group__types.html#gad8523b51611f0fac793f78f16b155b21">xtd::uint16</a> value)</td></tr>
<tr class="memdesc:ae86f131b2cd185c31f509e37d2a91e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the string representation of a specified 16-bit unsigned integer value to this instance.  <br /></td></tr>
<tr class="separator:ae86f131b2cd185c31f509e37d2a91e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d074c80b3939ba408e9fb552181eec6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a6d074c80b3939ba408e9fb552181eec6">append</a> (<a class="el" href="group__types.html#ga41c5d8b5d999ac5a2ff06fe57f38d5f5">xtd::uint32</a> value)</td></tr>
<tr class="memdesc:a6d074c80b3939ba408e9fb552181eec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the string representation of a specified 32-bit unsigned integer value to this instance.  <br /></td></tr>
<tr class="separator:a6d074c80b3939ba408e9fb552181eec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b234771b2201b8fbfb1644f7aa531b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a6b234771b2201b8fbfb1644f7aa531b7">append</a> (<a class="el" href="group__types.html#gab5833228ed21371660af349c9b1fe797">xtd::uint64</a> value)</td></tr>
<tr class="memdesc:a6b234771b2201b8fbfb1644f7aa531b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the string representation of a specified 64-bit unsigned integer value to this instance.  <br /></td></tr>
<tr class="separator:a6b234771b2201b8fbfb1644f7aa531b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54cc64a71cbc139d592a9c0fdf6b05e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a54cc64a71cbc139d592a9c0fdf6b05e3">append</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> value)</td></tr>
<tr class="memdesc:a54cc64a71cbc139d592a9c0fdf6b05e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the string representation of a specified <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc" title="Represents the basic string value type.">xtd::text::basic_string_builder::value_type</a> value to this instance.  <br /></td></tr>
<tr class="separator:a54cc64a71cbc139d592a9c0fdf6b05e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a45a2aeb5cc6bf291cda4785c37bc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a50a45a2aeb5cc6bf291cda4785c37bc4">append</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> value, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> repeat_count)</td></tr>
<tr class="memdesc:a50a45a2aeb5cc6bf291cda4785c37bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a specified number of copies of the string representation of a Unicode character to this instance.  <br /></td></tr>
<tr class="separator:a50a45a2aeb5cc6bf291cda4785c37bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a81c0e4a6288fe54b854c98ad485b8"><td class="memTemplParams" colspan="2">template&lt;class object_t &gt; </td></tr>
<tr class="memitem:a01a81c0e4a6288fe54b854c98ad485b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a01a81c0e4a6288fe54b854c98ad485b8">append</a> (object_t value)</td></tr>
<tr class="memdesc:a01a81c0e4a6288fe54b854c98ad485b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the string representation of a specified object to this instance.  <br /></td></tr>
<tr class="separator:a01a81c0e4a6288fe54b854c98ad485b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff714472cf75a0223adea8f73bc48573"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aff714472cf75a0223adea8f73bc48573">append</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> ch)</td></tr>
<tr class="memdesc:aff714472cf75a0223adea8f73bc48573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:aff714472cf75a0223adea8f73bc48573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a597a810e2423dbc847e86d163394e386"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a597a810e2423dbc847e86d163394e386">append</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str)</td></tr>
<tr class="memdesc:a597a810e2423dbc847e86d163394e386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a597a810e2423dbc847e86d163394e386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126d93539fcf8d3d17c9f883d960828a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a126d93539fcf8d3d17c9f883d960828a">append</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos)</td></tr>
<tr class="memdesc:a126d93539fcf8d3d17c9f883d960828a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a126d93539fcf8d3d17c9f883d960828a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2279334b8f5bce4bc235485e683adf7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a2279334b8f5bce4bc235485e683adf7f">append</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count)</td></tr>
<tr class="memdesc:a2279334b8f5bce4bc235485e683adf7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a2279334b8f5bce4bc235485e683adf7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1faae533546f74f439cc3c6fd6eb6747"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a1faae533546f74f439cc3c6fd6eb6747">append</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count)</td></tr>
<tr class="memdesc:a1faae533546f74f439cc3c6fd6eb6747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a1faae533546f74f439cc3c6fd6eb6747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb64cb2156c53cafb1a1f44176a6c54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a7eb64cb2156c53cafb1a1f44176a6c54">append</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>)</td></tr>
<tr class="memdesc:a7eb64cb2156c53cafb1a1f44176a6c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a7eb64cb2156c53cafb1a1f44176a6c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6198aa2543faceea31519407dc22dd72"><td class="memTemplParams" colspan="2">template&lt;class input_iterator_t &gt; </td></tr>
<tr class="memitem:a6198aa2543faceea31519407dc22dd72"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a6198aa2543faceea31519407dc22dd72">append</a> (input_iterator_t first, input_iterator_t last)</td></tr>
<tr class="memdesc:a6198aa2543faceea31519407dc22dd72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a6198aa2543faceea31519407dc22dd72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6267fe16a67d3534248d92508d1f9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a7d6267fe16a67d3534248d92508d1f9a">append</a> (std::initializer_list&lt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> &gt; ilist)</td></tr>
<tr class="memdesc:a7d6267fe16a67d3534248d92508d1f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a7d6267fe16a67d3534248d92508d1f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdea991b3a89ae01e8c998481fa987d3"><td class="memTemplParams" colspan="2">template&lt;class ... args_t&gt; </td></tr>
<tr class="memitem:afdea991b3a89ae01e8c998481fa987d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afdea991b3a89ae01e8c998481fa987d3">append_format</a> (const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t &gt; &amp;<a class="el" href="group__format__parse.html#ga73705cb16c7db5a2b7567456ff4e7e14">format</a>, args_t &amp;&amp;... args)</td></tr>
<tr class="memdesc:afdea991b3a89ae01e8c998481fa987d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance. Each format item is replaced by the string representation of a corresponding argument in a parameters.  <br /></td></tr>
<tr class="separator:afdea991b3a89ae01e8c998481fa987d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb8078255c5b4308703ec56e604b447"><td class="memTemplParams" colspan="2">template&lt;class collection_t &gt; </td></tr>
<tr class="memitem:aacb8078255c5b4308703ec56e604b447"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aacb8078255c5b4308703ec56e604b447">append_join</a> (const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t &gt; &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2aa0f0bc95016c862498bbad29d1f4d9d4">separator</a>, const collection_t &amp;values)</td></tr>
<tr class="memdesc:aacb8078255c5b4308703ec56e604b447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates and appends the members of a collection, using the specified separator between each member.  <br /></td></tr>
<tr class="separator:aacb8078255c5b4308703ec56e604b447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3028a3e141c23684354b44777e3ff8"><td class="memTemplParams" colspan="2">template&lt;class collection_t &gt; </td></tr>
<tr class="memitem:a7f3028a3e141c23684354b44777e3ff8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a7f3028a3e141c23684354b44777e3ff8">append_join</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2aa0f0bc95016c862498bbad29d1f4d9d4">separator</a>, const collection_t &amp;values)</td></tr>
<tr class="memdesc:a7f3028a3e141c23684354b44777e3ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates and appends the members of a collection, using the specified xtd::basic_string_builder::value_type separator between each member.  <br /></td></tr>
<tr class="separator:a7f3028a3e141c23684354b44777e3ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad848c2e409fe2fcaaa4f1066c3faa655"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad848c2e409fe2fcaaa4f1066c3faa655">append_line</a> ()</td></tr>
<tr class="memdesc:ad848c2e409fe2fcaaa4f1066c3faa655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the default line terminator to the end of the current <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object.  <br /></td></tr>
<tr class="separator:ad848c2e409fe2fcaaa4f1066c3faa655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34fedf9b31b7064396a6e1b8162cd6b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a34fedf9b31b7064396a6e1b8162cd6b9">append_line</a> (const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t &gt; &amp;value)</td></tr>
<tr class="memdesc:a34fedf9b31b7064396a6e1b8162cd6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a copy of the specified string followed by the default line terminator to the end of the current <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object.  <br /></td></tr>
<tr class="separator:a34fedf9b31b7064396a6e1b8162cd6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4874895a2538a2e3e197128c6d3ec0b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a7a9fff0c8a14fc2115fe86547402e0b4">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a4874895a2538a2e3e197128c6d3ec0b1">at</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos) const</td></tr>
<tr class="memdesc:a4874895a2538a2e3e197128c6d3ec0b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the character at specified location <code>pos</code>.  <br /></td></tr>
<tr class="separator:a4874895a2538a2e3e197128c6d3ec0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b9ffd98bb38650acf1485acce992bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a9b9b46ae1d66c7d5c9ac716899c0be58">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a70b9ffd98bb38650acf1485acce992bc">at</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos)</td></tr>
<tr class="memdesc:a70b9ffd98bb38650acf1485acce992bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the character at specified location <code>pos</code>.  <br /></td></tr>
<tr class="separator:a70b9ffd98bb38650acf1485acce992bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889d0621a11daabdcfd36f0b15f5a8ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a889d0621a11daabdcfd36f0b15f5a8ad">clear</a> ()</td></tr>
<tr class="memdesc:a889d0621a11daabdcfd36f0b15f5a8ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all characters from the current <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance.  <br /></td></tr>
<tr class="separator:a889d0621a11daabdcfd36f0b15f5a8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb3c07e3514242c5441eac7bead3d70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#adcb3c07e3514242c5441eac7bead3d70">compare</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str) const</td></tr>
<tr class="memdesc:adcb3c07e3514242c5441eac7bead3d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two character sequences.  <br /></td></tr>
<tr class="separator:adcb3c07e3514242c5441eac7bead3d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac602163d39c8c3cdb6b409f1fde49c7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ac602163d39c8c3cdb6b409f1fde49c7f">compare</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos1, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count1, const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str) const</td></tr>
<tr class="memdesc:ac602163d39c8c3cdb6b409f1fde49c7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two character sequences.  <br /></td></tr>
<tr class="separator:ac602163d39c8c3cdb6b409f1fde49c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935248e98bf33fdfcc1fae68d198a2f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a935248e98bf33fdfcc1fae68d198a2f1">compare</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos1, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count1, const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos2) const</td></tr>
<tr class="memdesc:a935248e98bf33fdfcc1fae68d198a2f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two character sequences.  <br /></td></tr>
<tr class="separator:a935248e98bf33fdfcc1fae68d198a2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb00b052cf70d3ee4df156ed4707e841"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afb00b052cf70d3ee4df156ed4707e841">compare</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos1, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count1, const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos2, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count2) const</td></tr>
<tr class="memdesc:afb00b052cf70d3ee4df156ed4707e841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two character sequences.  <br /></td></tr>
<tr class="separator:afb00b052cf70d3ee4df156ed4707e841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4e44756cc5852ef2a75ed7e4763f9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a1a4e44756cc5852ef2a75ed7e4763f9c">compare</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:a1a4e44756cc5852ef2a75ed7e4763f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two character sequences.  <br /></td></tr>
<tr class="separator:a1a4e44756cc5852ef2a75ed7e4763f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e43fb14da06fe4c8abdfb096538347c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a7e43fb14da06fe4c8abdfb096538347c">compare</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos1, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count1, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:a7e43fb14da06fe4c8abdfb096538347c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two character sequences.  <br /></td></tr>
<tr class="separator:a7e43fb14da06fe4c8abdfb096538347c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32da0105edfb4de7d7a4e03702bdd01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aa32da0105edfb4de7d7a4e03702bdd01">compare</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos1, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count1, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count2) const</td></tr>
<tr class="memdesc:aa32da0105edfb4de7d7a4e03702bdd01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two character sequences.  <br /></td></tr>
<tr class="separator:aa32da0105edfb4de7d7a4e03702bdd01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0daf0e5823acccf7dc869e1e542d7e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae0daf0e5823acccf7dc869e1e542d7e4">copy</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aa62aee9e769ee262f5deae94ff8ea03d">pointer</a> dest, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count) const</td></tr>
<tr class="memdesc:ae0daf0e5823acccf7dc869e1e542d7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a substring [<code>pos</code>, <code>pos + count</code>) to character string pointed to by <code>dest</code>. If the requested substring lasts past the end of the string, or if <code>count == npos</code>, the copied substring is [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>).  <br /></td></tr>
<tr class="separator:ae0daf0e5823acccf7dc869e1e542d7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68eec80ec1a4223dc129301eb889e6a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a68eec80ec1a4223dc129301eb889e6a4">copy</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aa62aee9e769ee262f5deae94ff8ea03d">pointer</a> dest, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos) const</td></tr>
<tr class="memdesc:a68eec80ec1a4223dc129301eb889e6a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a substring [<code>pos</code>, <code>pos + count</code>) to character string pointed to by <code>dest</code>. If the requested substring lasts past the end of the string, or if <code>count == npos</code>, the copied substring is [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>).  <br /></td></tr>
<tr class="separator:a68eec80ec1a4223dc129301eb889e6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab371da2a717b123bae6b1d802ef8493c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ab371da2a717b123bae6b1d802ef8493c">copy_to</a> (<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> source_index, <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> &gt; &amp;destination, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> destination_index, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> destination_count) const</td></tr>
<tr class="memdesc:ab371da2a717b123bae6b1d802ef8493c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the characters from a specified segment of this instance to a specified segment of a destination <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc" title="Represents the basic string value type.">xtd::text::basic_string_builder::value_type</a> array.  <br /></td></tr>
<tr class="separator:ab371da2a717b123bae6b1d802ef8493c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96c2ac833670b1180ac068212ad9f4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#af96c2ac833670b1180ac068212ad9f4f">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;obj) const noexcept override</td></tr>
<tr class="memdesc:af96c2ac833670b1180ac068212ad9f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this instance and a specified object, which must also be a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, have the same value.  <br /></td></tr>
<tr class="separator:af96c2ac833670b1180ac068212ad9f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d34f9d4cd8a741fe9db2eee6c5aefd5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a0d34f9d4cd8a741fe9db2eee6c5aefd5">equals</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;value) const noexcept override</td></tr>
<tr class="memdesc:a0d34f9d4cd8a741fe9db2eee6c5aefd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this instance and another specified <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object have the same value.  <br /></td></tr>
<tr class="separator:a0d34f9d4cd8a741fe9db2eee6c5aefd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbeb4cc1cfd200606618eb6739608942"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#abbeb4cc1cfd200606618eb6739608942">ensure_capacity</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a1fc6dca79d34264f29e710ffe3ce6e89">capacity</a>)</td></tr>
<tr class="memdesc:abbeb4cc1cfd200606618eb6739608942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the capacity of this instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is at least the specified value.  <br /></td></tr>
<tr class="separator:abbeb4cc1cfd200606618eb6739608942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5c9fcc11b456758adcff89a37db3d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5b5c9fcc11b456758adcff89a37db3d6">erase</a> ()</td></tr>
<tr class="memdesc:a5b5c9fcc11b456758adcff89a37db3d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes specified characters from the string.  <br /></td></tr>
<tr class="separator:a5b5c9fcc11b456758adcff89a37db3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98036eb33b9f5efccea8f3ab0c4260d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aa98036eb33b9f5efccea8f3ab0c4260d">erase</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> index)</td></tr>
<tr class="memdesc:aa98036eb33b9f5efccea8f3ab0c4260d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes specified characters from the string.  <br /></td></tr>
<tr class="separator:aa98036eb33b9f5efccea8f3ab0c4260d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba63b5048abc857d0ef9fec7202868e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aba63b5048abc857d0ef9fec7202868e2">erase</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> index, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count)</td></tr>
<tr class="memdesc:aba63b5048abc857d0ef9fec7202868e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes specified characters from the string.  <br /></td></tr>
<tr class="separator:aba63b5048abc857d0ef9fec7202868e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4a2cd3ac7315702ee353559ca0a826"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aae7df40d1cb269bbcdd170dde0f5dc20">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a0b4a2cd3ac7315702ee353559ca0a826">erase</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a> position)</td></tr>
<tr class="memdesc:a0b4a2cd3ac7315702ee353559ca0a826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes specified characters from the string.  <br /></td></tr>
<tr class="separator:a0b4a2cd3ac7315702ee353559ca0a826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43cc268cc3bbc170e27fb9890960ecfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aae7df40d1cb269bbcdd170dde0f5dc20">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a43cc268cc3bbc170e27fb9890960ecfd">erase</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a> first, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a> last)</td></tr>
<tr class="memdesc:a43cc268cc3bbc170e27fb9890960ecfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes specified characters from the string.  <br /></td></tr>
<tr class="separator:a43cc268cc3bbc170e27fb9890960ecfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd010f465e21bfe02a37a72327fcb8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#addd010f465e21bfe02a37a72327fcb8b">find</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str) const</td></tr>
<tr class="memdesc:addd010f465e21bfe02a37a72327fcb8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>.  <br /></td></tr>
<tr class="separator:addd010f465e21bfe02a37a72327fcb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4056d79afbf4cd7427b088ff37fd73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aca4056d79afbf4cd7427b088ff37fd73">find</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos) const</td></tr>
<tr class="memdesc:aca4056d79afbf4cd7427b088ff37fd73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>.  <br /></td></tr>
<tr class="separator:aca4056d79afbf4cd7427b088ff37fd73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871f4dcc9e986d3391773e94001d4424"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a871f4dcc9e986d3391773e94001d4424">find</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count) const</td></tr>
<tr class="memdesc:a871f4dcc9e986d3391773e94001d4424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>.  <br /></td></tr>
<tr class="separator:a871f4dcc9e986d3391773e94001d4424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa516a25b121ca140f4e32b25686ee448"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aa516a25b121ca140f4e32b25686ee448">find</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:aa516a25b121ca140f4e32b25686ee448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>.  <br /></td></tr>
<tr class="separator:aa516a25b121ca140f4e32b25686ee448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a375a366e73b0bb4a472a54e55b7820b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a375a366e73b0bb4a472a54e55b7820b5">find</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos) const</td></tr>
<tr class="memdesc:a375a366e73b0bb4a472a54e55b7820b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>.  <br /></td></tr>
<tr class="separator:a375a366e73b0bb4a472a54e55b7820b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dde10776af5e4236d17f723f5e16272"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a1dde10776af5e4236d17f723f5e16272">find</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> ch) const</td></tr>
<tr class="memdesc:a1dde10776af5e4236d17f723f5e16272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>.  <br /></td></tr>
<tr class="separator:a1dde10776af5e4236d17f723f5e16272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb87f140c3fb2c99c9213e41bdf6c7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acdb87f140c3fb2c99c9213e41bdf6c7a">find</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> ch, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos) const</td></tr>
<tr class="memdesc:acdb87f140c3fb2c99c9213e41bdf6c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>.  <br /></td></tr>
<tr class="separator:acdb87f140c3fb2c99c9213e41bdf6c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1193f4f61458f636924c8c12e37c389e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a1193f4f61458f636924c8c12e37c389e">find_first_of</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str) const</td></tr>
<tr class="memdesc:a1193f4f61458f636924c8c12e37c389e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a1193f4f61458f636924c8c12e37c389e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01193dda07e43b164b2162867e8af66e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a01193dda07e43b164b2162867e8af66e">find_first_of</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos) const</td></tr>
<tr class="memdesc:a01193dda07e43b164b2162867e8af66e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a01193dda07e43b164b2162867e8af66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4930ea45a844d0194dc6becc05f910"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5f4930ea45a844d0194dc6becc05f910">find_first_of</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count) const</td></tr>
<tr class="memdesc:a5f4930ea45a844d0194dc6becc05f910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a5f4930ea45a844d0194dc6becc05f910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6486e9aa4f41fd50996a84103e643f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a0f6486e9aa4f41fd50996a84103e643f">find_first_of</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:a0f6486e9aa4f41fd50996a84103e643f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a0f6486e9aa4f41fd50996a84103e643f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5822b12952b2e94f633ed23864a033b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5822b12952b2e94f633ed23864a033b1">find_first_of</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos) const</td></tr>
<tr class="memdesc:a5822b12952b2e94f633ed23864a033b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a5822b12952b2e94f633ed23864a033b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173cc774d0d51ce3b178e057384bd785"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a173cc774d0d51ce3b178e057384bd785">find_first_of</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> ch) const</td></tr>
<tr class="memdesc:a173cc774d0d51ce3b178e057384bd785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a173cc774d0d51ce3b178e057384bd785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021c75422a879b861ed2e6d70a87056d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a021c75422a879b861ed2e6d70a87056d">find_first_of</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> ch, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos) const</td></tr>
<tr class="memdesc:a021c75422a879b861ed2e6d70a87056d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a021c75422a879b861ed2e6d70a87056d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782483099e1899cde8dcdd99d33874a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a782483099e1899cde8dcdd99d33874a8">find_first_not_of</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str) const</td></tr>
<tr class="memdesc:a782483099e1899cde8dcdd99d33874a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a782483099e1899cde8dcdd99d33874a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ea74d485358c59e05a8a4c166b9d57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a64ea74d485358c59e05a8a4c166b9d57">find_first_not_of</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos) const</td></tr>
<tr class="memdesc:a64ea74d485358c59e05a8a4c166b9d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a64ea74d485358c59e05a8a4c166b9d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3c984bc0ecb97d0b7b043aef7e342c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd3c984bc0ecb97d0b7b043aef7e342c">find_first_not_of</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count) const</td></tr>
<tr class="memdesc:acd3c984bc0ecb97d0b7b043aef7e342c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:acd3c984bc0ecb97d0b7b043aef7e342c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59823a9dd0e8f7198911cb405d1fd5d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a59823a9dd0e8f7198911cb405d1fd5d9">find_first_not_of</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:a59823a9dd0e8f7198911cb405d1fd5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a59823a9dd0e8f7198911cb405d1fd5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b3ddb2b4b520bbb17977b9aa40abdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a59b3ddb2b4b520bbb17977b9aa40abdd">find_first_not_of</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos) const</td></tr>
<tr class="memdesc:a59b3ddb2b4b520bbb17977b9aa40abdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a59b3ddb2b4b520bbb17977b9aa40abdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341d07800aea00111e68dc05f9e53b25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a341d07800aea00111e68dc05f9e53b25">find_first_not_of</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> ch) const</td></tr>
<tr class="memdesc:a341d07800aea00111e68dc05f9e53b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a341d07800aea00111e68dc05f9e53b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253195d4dd86e68c524904601b299455"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a253195d4dd86e68c524904601b299455">find_first_not_of</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> ch, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos) const</td></tr>
<tr class="memdesc:a253195d4dd86e68c524904601b299455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a253195d4dd86e68c524904601b299455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14020567dcd6804b6cdcb44195921e08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a14020567dcd6804b6cdcb44195921e08">find_last_of</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str) const</td></tr>
<tr class="memdesc:a14020567dcd6804b6cdcb44195921e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a14020567dcd6804b6cdcb44195921e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695e88d8d0a58a53f73959164c6d6880"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a695e88d8d0a58a53f73959164c6d6880">find_last_of</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos) const</td></tr>
<tr class="memdesc:a695e88d8d0a58a53f73959164c6d6880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a695e88d8d0a58a53f73959164c6d6880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c85187149a417bd2f31d6a22acf2ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#af4c85187149a417bd2f31d6a22acf2ce">find_last_of</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count) const</td></tr>
<tr class="memdesc:af4c85187149a417bd2f31d6a22acf2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:af4c85187149a417bd2f31d6a22acf2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448a629104e7ce594fd1a23aa00c6626"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a448a629104e7ce594fd1a23aa00c6626">find_last_of</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:a448a629104e7ce594fd1a23aa00c6626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a448a629104e7ce594fd1a23aa00c6626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f81f8edf0cf5a8ca3e544026074ef68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5f81f8edf0cf5a8ca3e544026074ef68">find_last_of</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos) const</td></tr>
<tr class="memdesc:a5f81f8edf0cf5a8ca3e544026074ef68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a5f81f8edf0cf5a8ca3e544026074ef68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b96875455b6f3b0f2d1142ffbbacd25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3b96875455b6f3b0f2d1142ffbbacd25">find_last_of</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> ch) const</td></tr>
<tr class="memdesc:a3b96875455b6f3b0f2d1142ffbbacd25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a3b96875455b6f3b0f2d1142ffbbacd25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81c01bf59e08e245516c40ebc2ee842"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#af81c01bf59e08e245516c40ebc2ee842">find_last_of</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> ch, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos) const</td></tr>
<tr class="memdesc:af81c01bf59e08e245516c40ebc2ee842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:af81c01bf59e08e245516c40ebc2ee842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b045db53e2ee1951e28b54df69a1cc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5b045db53e2ee1951e28b54df69a1cc9">find_last_not_of</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str) const</td></tr>
<tr class="memdesc:a5b045db53e2ee1951e28b54df69a1cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a5b045db53e2ee1951e28b54df69a1cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dbef564df0bc8b53eb5af4c5d4d743f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a7dbef564df0bc8b53eb5af4c5d4d743f">find_last_not_of</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos) const</td></tr>
<tr class="memdesc:a7dbef564df0bc8b53eb5af4c5d4d743f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a7dbef564df0bc8b53eb5af4c5d4d743f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce1bca49f91f2cbaf6cd55afb394a07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#adce1bca49f91f2cbaf6cd55afb394a07">find_last_not_of</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count) const</td></tr>
<tr class="memdesc:adce1bca49f91f2cbaf6cd55afb394a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:adce1bca49f91f2cbaf6cd55afb394a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b25d4d6d8b1112152fed3d5a8675fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a36b25d4d6d8b1112152fed3d5a8675fb">find_last_not_of</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:a36b25d4d6d8b1112152fed3d5a8675fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a36b25d4d6d8b1112152fed3d5a8675fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ada4c383c61f1705fed87a7a517f56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aa3ada4c383c61f1705fed87a7a517f56">find_last_not_of</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos) const</td></tr>
<tr class="memdesc:aa3ada4c383c61f1705fed87a7a517f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:aa3ada4c383c61f1705fed87a7a517f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09746cee91ee1b9de5560cc055a0ba67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a09746cee91ee1b9de5560cc055a0ba67">find_last_not_of</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> ch) const</td></tr>
<tr class="memdesc:a09746cee91ee1b9de5560cc055a0ba67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a09746cee91ee1b9de5560cc055a0ba67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf963ad4b8dbdb486ce6d9861323568"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a4cf963ad4b8dbdb486ce6d9861323568">find_last_not_of</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> ch, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos) const</td></tr>
<tr class="memdesc:a4cf963ad4b8dbdb486ce6d9861323568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a4cf963ad4b8dbdb486ce6d9861323568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74555342c1e71644a8c85221c22a253"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aeb22ca3eb2fea9a222bddac1b5282675">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ab74555342c1e71644a8c85221c22a253">get_allocator</a> () const</td></tr>
<tr class="memdesc:ab74555342c1e71644a8c85221c22a253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the string.  <br /></td></tr>
<tr class="separator:ab74555342c1e71644a8c85221c22a253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255284f6f267ad0dec0b3ce000012406"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ac9f39b0cc8b359570352fb6c86f17424">base_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a255284f6f267ad0dec0b3ce000012406">get_base_type</a> () const noexcept</td></tr>
<tr class="memdesc:a255284f6f267ad0dec0b3ce000012406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying base type.  <br /></td></tr>
<tr class="separator:a255284f6f267ad0dec0b3ce000012406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62861111a3dbc4a98fad55c9d550f1c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a62861111a3dbc4a98fad55c9d550f1c0">get_hash_code</a> () const noexcept override</td></tr>
<tr class="memdesc:a62861111a3dbc4a98fad55c9d550f1c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the hash code for this <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>.  <br /></td></tr>
<tr class="separator:a62861111a3dbc4a98fad55c9d550f1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6adb1caf7d21ef5cf838abf7d1fe3a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad6adb1caf7d21ef5cf838abf7d1fe3a1">insert</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> index, const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t &gt; &amp;value)</td></tr>
<tr class="memdesc:ad6adb1caf7d21ef5cf838abf7d1fe3a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a string into this instance at the specified character position.  <br /></td></tr>
<tr class="separator:ad6adb1caf7d21ef5cf838abf7d1fe3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98ed3d1bcec424cc1ced4248256f1dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ac98ed3d1bcec424cc1ced4248256f1dc">insert</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> index, const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t &gt; &amp;value, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count)</td></tr>
<tr class="memdesc:ac98ed3d1bcec424cc1ced4248256f1dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts one or more copies of a specified string into this instance at the specified character position.  <br /></td></tr>
<tr class="separator:ac98ed3d1bcec424cc1ced4248256f1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71672fd9dc758a885e3ceffc79aa610e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a71672fd9dc758a885e3ceffc79aa610e">insert</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> index, <a class="el" href="group__types.html#gab7230dbe491f8bcef5e5f8bdaba5e27f">xtd::boolean</a> value)</td></tr>
<tr class="memdesc:a71672fd9dc758a885e3ceffc79aa610e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the string representation of a boolean value into this instance at the specified character position.  <br /></td></tr>
<tr class="separator:a71672fd9dc758a885e3ceffc79aa610e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81221aa31d3902af34338c7d5703087"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ab81221aa31d3902af34338c7d5703087">insert</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> index, <a class="el" href="group__types.html#gabb9d3031d62e3725b4265c7e5d2a98e1">xtd::byte</a> value)</td></tr>
<tr class="memdesc:ab81221aa31d3902af34338c7d5703087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the string representation of a specified 8-bit unsigned integer into this instance at the specified character position.  <br /></td></tr>
<tr class="separator:ab81221aa31d3902af34338c7d5703087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b977f8e3d9556c431a732382a12077f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3b977f8e3d9556c431a732382a12077f">insert</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> index, <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a">xtd::decimal</a> value)</td></tr>
<tr class="memdesc:a3b977f8e3d9556c431a732382a12077f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the string representation of a specified 8decimal into this instance at the specified character position.  <br /></td></tr>
<tr class="separator:a3b977f8e3d9556c431a732382a12077f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1998f21c817095eae59166547f564e6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a1998f21c817095eae59166547f564e6a">insert</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> index, double value)</td></tr>
<tr class="memdesc:a1998f21c817095eae59166547f564e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the string representation of a specified double into this instance at the specified character position.  <br /></td></tr>
<tr class="separator:a1998f21c817095eae59166547f564e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a136db945714bedcd09586014bc0a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#af4a136db945714bedcd09586014bc0a3">insert</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> index, <a class="el" href="group__types.html#ga4c9f72f7ab9ea9919c93a1a2b245ab71">xtd::single</a> value)</td></tr>
<tr class="memdesc:af4a136db945714bedcd09586014bc0a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the string representation of a specified single into this instance at the specified character position.  <br /></td></tr>
<tr class="separator:af4a136db945714bedcd09586014bc0a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebade1d7099ea019449faa5959c7c66e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aebade1d7099ea019449faa5959c7c66e">insert</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> index, <a class="el" href="group__types.html#ga09d26135a9af4f7a5f4cae382627d6d1">xtd::int16</a> value)</td></tr>
<tr class="memdesc:aebade1d7099ea019449faa5959c7c66e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the string representation of a specified 16-bit signed integer into this instance at the specified character position.  <br /></td></tr>
<tr class="separator:aebade1d7099ea019449faa5959c7c66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3ab96abfdc0853a7239ace614ee4bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a8e3ab96abfdc0853a7239ace614ee4bc">insert</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> index, <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a> value)</td></tr>
<tr class="memdesc:a8e3ab96abfdc0853a7239ace614ee4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the string representation of a specified 32-bit signed integer into this instance at the specified character position.  <br /></td></tr>
<tr class="separator:a8e3ab96abfdc0853a7239ace614ee4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae935ba62175a9d015ff0cdb3bdde036f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae935ba62175a9d015ff0cdb3bdde036f">insert</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> index, <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4">xtd::int64</a> value)</td></tr>
<tr class="memdesc:ae935ba62175a9d015ff0cdb3bdde036f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the string representation of a specified 64-bit signed integer into this instance at the specified character position.  <br /></td></tr>
<tr class="separator:ae935ba62175a9d015ff0cdb3bdde036f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe16b4a827b8c7451b6adeeb12c98822"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#abe16b4a827b8c7451b6adeeb12c98822">insert</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> index, <a class="el" href="group__types.html#ga37e983ceedf5a7f73bc4568eaeae0aa2">xtd::sbyte</a> value)</td></tr>
<tr class="memdesc:abe16b4a827b8c7451b6adeeb12c98822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the string representation of a specified 8-bit signed integer into this instance at the specified character position.  <br /></td></tr>
<tr class="separator:abe16b4a827b8c7451b6adeeb12c98822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12493726c9d996c346d2015c8879b667"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a12493726c9d996c346d2015c8879b667">insert</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> index, <a class="el" href="group__types.html#gad8523b51611f0fac793f78f16b155b21">xtd::uint16</a> value)</td></tr>
<tr class="memdesc:a12493726c9d996c346d2015c8879b667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the string representation of a specified 16-bit unsigned integer into this instance at the specified character position.  <br /></td></tr>
<tr class="separator:a12493726c9d996c346d2015c8879b667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ea5dab524bc80c779ae9f8e7e0418f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae6ea5dab524bc80c779ae9f8e7e0418f">insert</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> index, <a class="el" href="group__types.html#ga41c5d8b5d999ac5a2ff06fe57f38d5f5">xtd::uint32</a> value)</td></tr>
<tr class="memdesc:ae6ea5dab524bc80c779ae9f8e7e0418f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the string representation of a specified 32-bit unsigned integer into this instance at the specified character position.  <br /></td></tr>
<tr class="separator:ae6ea5dab524bc80c779ae9f8e7e0418f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8182b9785bb3bcdb7b85bb816c1feacf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a8182b9785bb3bcdb7b85bb816c1feacf">insert</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> index, <a class="el" href="group__types.html#gab5833228ed21371660af349c9b1fe797">xtd::uint64</a> value)</td></tr>
<tr class="memdesc:a8182b9785bb3bcdb7b85bb816c1feacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the string representation of a specified 64-bit unsigned integer into this instance at the specified character position.  <br /></td></tr>
<tr class="separator:a8182b9785bb3bcdb7b85bb816c1feacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af88ec0b5a9a9507d434f01c88081ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a7af88ec0b5a9a9507d434f01c88081ca">insert</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> index, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> value)</td></tr>
<tr class="memdesc:a7af88ec0b5a9a9507d434f01c88081ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the string representation of a specified Unicode character into this instance at the specified character position.  <br /></td></tr>
<tr class="separator:a7af88ec0b5a9a9507d434f01c88081ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a543f5eb24f0ce4efb0241346a6077b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a4a543f5eb24f0ce4efb0241346a6077b">insert</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> index, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> value, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> repeat_count)</td></tr>
<tr class="memdesc:a4a543f5eb24f0ce4efb0241346a6077b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a specified number of copies of the string representation of a Unicode character to this instance at the specified character position.  <br /></td></tr>
<tr class="separator:a4a543f5eb24f0ce4efb0241346a6077b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e26ca656cb16b1a051d29bbc6c0b8cd"><td class="memTemplParams" colspan="2">template&lt;class object_t &gt; </td></tr>
<tr class="memitem:a8e26ca656cb16b1a051d29bbc6c0b8cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a8e26ca656cb16b1a051d29bbc6c0b8cd">insert</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> index, object_t value)</td></tr>
<tr class="memdesc:a8e26ca656cb16b1a051d29bbc6c0b8cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the string representation of a specified object into this instance at the specified character position.  <br /></td></tr>
<tr class="separator:a8e26ca656cb16b1a051d29bbc6c0b8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d09df18594f89f4ffc30414acdd611a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a4d09df18594f89f4ffc30414acdd611a">insert</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> index, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> ch)</td></tr>
<tr class="memdesc:a4d09df18594f89f4ffc30414acdd611a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts characters into the string.  <br /></td></tr>
<tr class="separator:a4d09df18594f89f4ffc30414acdd611a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2402d5c4a4e5387741556e7fda742be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae2402d5c4a4e5387741556e7fda742be">insert</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> index, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>)</td></tr>
<tr class="memdesc:ae2402d5c4a4e5387741556e7fda742be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts characters into the string.  <br /></td></tr>
<tr class="separator:ae2402d5c4a4e5387741556e7fda742be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d53654f3dcd914ea3082bdf4118558f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a0d53654f3dcd914ea3082bdf4118558f">insert</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> index, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count)</td></tr>
<tr class="memdesc:a0d53654f3dcd914ea3082bdf4118558f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts characters into the string.  <br /></td></tr>
<tr class="separator:a0d53654f3dcd914ea3082bdf4118558f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b040b19ef40b307d698b783dea5e915"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a1b040b19ef40b307d698b783dea5e915">insert</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> index, const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str)</td></tr>
<tr class="memdesc:a1b040b19ef40b307d698b783dea5e915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts characters into the string.  <br /></td></tr>
<tr class="separator:a1b040b19ef40b307d698b783dea5e915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b0e31251aca8ac7d1c995a4d310acf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a67b0e31251aca8ac7d1c995a4d310acf">insert</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> index, const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> s_index, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count)</td></tr>
<tr class="memdesc:a67b0e31251aca8ac7d1c995a4d310acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts characters into the string.  <br /></td></tr>
<tr class="separator:a67b0e31251aca8ac7d1c995a4d310acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36684de7f76f8c67b3f9061825817be4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a36684de7f76f8c67b3f9061825817be4">insert</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> index, const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> s_index)</td></tr>
<tr class="memdesc:a36684de7f76f8c67b3f9061825817be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts characters into the string.  <br /></td></tr>
<tr class="separator:a36684de7f76f8c67b3f9061825817be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe673712687e609844a2cc13af4d225"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aae7df40d1cb269bbcdd170dde0f5dc20">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aafe673712687e609844a2cc13af4d225">insert</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a> pos, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> ch)</td></tr>
<tr class="memdesc:aafe673712687e609844a2cc13af4d225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts characters into the string.  <br /></td></tr>
<tr class="separator:aafe673712687e609844a2cc13af4d225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75785f232f852c4f1fefc2af75473480"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aae7df40d1cb269bbcdd170dde0f5dc20">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a75785f232f852c4f1fefc2af75473480">insert</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a> pos, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> ch)</td></tr>
<tr class="memdesc:a75785f232f852c4f1fefc2af75473480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts characters into the string.  <br /></td></tr>
<tr class="separator:a75785f232f852c4f1fefc2af75473480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4c4a8641108b8ffea1f2fef33e3af0"><td class="memTemplParams" colspan="2">template&lt;class input_iterator_t &gt; </td></tr>
<tr class="memitem:a7c4c4a8641108b8ffea1f2fef33e3af0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aae7df40d1cb269bbcdd170dde0f5dc20">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a7c4c4a8641108b8ffea1f2fef33e3af0">insert</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a> pos, input_iterator_t first, input_iterator_t last)</td></tr>
<tr class="memdesc:a7c4c4a8641108b8ffea1f2fef33e3af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts characters into the string.  <br /></td></tr>
<tr class="separator:a7c4c4a8641108b8ffea1f2fef33e3af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589e207eda41349a89b4bc5f73f38359"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aae7df40d1cb269bbcdd170dde0f5dc20">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a589e207eda41349a89b4bc5f73f38359">insert</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a> pos, std::initializer_list&lt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> &gt; ilist)</td></tr>
<tr class="memdesc:a589e207eda41349a89b4bc5f73f38359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts characters into the string.  <br /></td></tr>
<tr class="separator:a589e207eda41349a89b4bc5f73f38359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab655758dbc96bb5b3b2fc9316b43af44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ab655758dbc96bb5b3b2fc9316b43af44">pop_back</a> ()</td></tr>
<tr class="memdesc:ab655758dbc96bb5b3b2fc9316b43af44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last character from the string.  <br /></td></tr>
<tr class="separator:ab655758dbc96bb5b3b2fc9316b43af44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d7995728250775b7047fff4d2bfb3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a06d7995728250775b7047fff4d2bfb3d">push_back</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> ch)</td></tr>
<tr class="memdesc:a06d7995728250775b7047fff4d2bfb3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given character ch to the end of the string.  <br /></td></tr>
<tr class="separator:a06d7995728250775b7047fff4d2bfb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2fa6b7bb8ecb46f5e7d391c4f101d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aad2fa6b7bb8ecb46f5e7d391c4f101d0">remove</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> start_index, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a69a83b009389b1b5706ce202a2989afd">length</a>)</td></tr>
<tr class="memdesc:aad2fa6b7bb8ecb46f5e7d391c4f101d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified range of characters from this instance.  <br /></td></tr>
<tr class="separator:aad2fa6b7bb8ecb46f5e7d391c4f101d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230379fc4c043d52efe193008e83467d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a230379fc4c043d52efe193008e83467d">replace</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> old_char, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> new_char) noexcept</td></tr>
<tr class="memdesc:a230379fc4c043d52efe193008e83467d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all occurrences of a specified character in this instance with another specified character.  <br /></td></tr>
<tr class="separator:a230379fc4c043d52efe193008e83467d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681fbefc0f94da898a3b0a9001cc9a2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a681fbefc0f94da898a3b0a9001cc9a2d">replace</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> old_char, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> new_char, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> start_index, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count)</td></tr>
<tr class="memdesc:a681fbefc0f94da898a3b0a9001cc9a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces, within a substring of this instance, all occurrences of a specified character with another specified character.  <br /></td></tr>
<tr class="separator:a681fbefc0f94da898a3b0a9001cc9a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cea578a9167bdb678a53d3caee7ae7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a88cea578a9167bdb678a53d3caee7ae7">replace</a> (const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t &gt; &amp;old_value, const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t &gt; &amp;new_value) noexcept</td></tr>
<tr class="memdesc:a88cea578a9167bdb678a53d3caee7ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all occurrences of a specified string in this instance with another specified string.  <br /></td></tr>
<tr class="separator:a88cea578a9167bdb678a53d3caee7ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a81ae8fccafc2206050c3ca0c46122"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad3a81ae8fccafc2206050c3ca0c46122">replace</a> (const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t &gt; &amp;old_value, const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t &gt; &amp;new_value, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> start_index, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count)</td></tr>
<tr class="memdesc:ad3a81ae8fccafc2206050c3ca0c46122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces, within a substring of this instance, all occurrences of a specified string with another specified string.  <br /></td></tr>
<tr class="separator:ad3a81ae8fccafc2206050c3ca0c46122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b199ea7cfb5a58d7404585abc06e4af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a2b199ea7cfb5a58d7404585abc06e4af">replace</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count, const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str)</td></tr>
<tr class="memdesc:a2b199ea7cfb5a58d7404585abc06e4af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the characters in the range [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + pos</code>, <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters.  <br /></td></tr>
<tr class="separator:a2b199ea7cfb5a58d7404585abc06e4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5d1e871c0993f1d447d2ee567e523d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a7b5d1e871c0993f1d447d2ee567e523d">replace</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a> first, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a> last, const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str)</td></tr>
<tr class="memdesc:a7b5d1e871c0993f1d447d2ee567e523d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the characters in the range [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + pos</code>, <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters.  <br /></td></tr>
<tr class="separator:a7b5d1e871c0993f1d447d2ee567e523d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f15b2e74550cadf3a03adb10bbbbced"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a0f15b2e74550cadf3a03adb10bbbbced">replace</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count, const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos2)</td></tr>
<tr class="memdesc:a0f15b2e74550cadf3a03adb10bbbbced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the characters in the range [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + pos</code>, <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters.  <br /></td></tr>
<tr class="separator:a0f15b2e74550cadf3a03adb10bbbbced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3759d0dbdb288f6d9516aefe8878b525"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3759d0dbdb288f6d9516aefe8878b525">replace</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count, const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos2, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count2)</td></tr>
<tr class="memdesc:a3759d0dbdb288f6d9516aefe8878b525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the characters in the range [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + pos</code>, <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters.  <br /></td></tr>
<tr class="separator:a3759d0dbdb288f6d9516aefe8878b525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee9f691c22dcd1658803d4496117255"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a1ee9f691c22dcd1658803d4496117255">replace</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> cstr, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count2)</td></tr>
<tr class="memdesc:a1ee9f691c22dcd1658803d4496117255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the characters in the range [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + pos</code>, <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters.  <br /></td></tr>
<tr class="separator:a1ee9f691c22dcd1658803d4496117255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa91c883f69a8b3f7810c07ac8421f98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aaa91c883f69a8b3f7810c07ac8421f98">replace</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a> first, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a> last, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> cstr, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count2)</td></tr>
<tr class="memdesc:aaa91c883f69a8b3f7810c07ac8421f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the characters in the range [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + pos</code>, <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters.  <br /></td></tr>
<tr class="separator:aaa91c883f69a8b3f7810c07ac8421f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb13f23d390a47081a00e137355a6aff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#abb13f23d390a47081a00e137355a6aff">replace</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> cstr)</td></tr>
<tr class="memdesc:abb13f23d390a47081a00e137355a6aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the characters in the range [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + pos</code>, <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters.  <br /></td></tr>
<tr class="separator:abb13f23d390a47081a00e137355a6aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c7af9db7caa09b5f865b9d20e95c7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a34c7af9db7caa09b5f865b9d20e95c7c">replace</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a> first, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a> last, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> cstr)</td></tr>
<tr class="memdesc:a34c7af9db7caa09b5f865b9d20e95c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the characters in the range [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + pos</code>, <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters.  <br /></td></tr>
<tr class="separator:a34c7af9db7caa09b5f865b9d20e95c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e630d3858ea0aad67093fb1f51a3977"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a9e630d3858ea0aad67093fb1f51a3977">replace</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count2, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> ch)</td></tr>
<tr class="memdesc:a9e630d3858ea0aad67093fb1f51a3977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the characters in the range [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + pos</code>, <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters.  <br /></td></tr>
<tr class="separator:a9e630d3858ea0aad67093fb1f51a3977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7fb6a59a499e18aca19812d4b209e74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae7fb6a59a499e18aca19812d4b209e74">replace</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a> first, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a> last, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count2, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> ch)</td></tr>
<tr class="memdesc:ae7fb6a59a499e18aca19812d4b209e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the characters in the range [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + pos</code>, <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters.  <br /></td></tr>
<tr class="separator:ae7fb6a59a499e18aca19812d4b209e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111f0dbc2b4811ecdd92f884e9cbc578"><td class="memTemplParams" colspan="2">template&lt;class input_iterator_t &gt; </td></tr>
<tr class="memitem:a111f0dbc2b4811ecdd92f884e9cbc578"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a111f0dbc2b4811ecdd92f884e9cbc578">replace</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a> first, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a> last, input_iterator_t first2, input_iterator_t last2)</td></tr>
<tr class="memdesc:a111f0dbc2b4811ecdd92f884e9cbc578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the characters in the range [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + pos</code>, <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters.  <br /></td></tr>
<tr class="separator:a111f0dbc2b4811ecdd92f884e9cbc578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8cb03254df88645e72e8bdcde862dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a8a8cb03254df88645e72e8bdcde862dd">replace</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a> first, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a> last, std::initializer_list&lt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> &gt; ilist)</td></tr>
<tr class="memdesc:a8a8cb03254df88645e72e8bdcde862dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the characters in the range [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + pos</code>, <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters.  <br /></td></tr>
<tr class="separator:a8a8cb03254df88645e72e8bdcde862dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb5c5a986bb7a0ca537de53f074be54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aafb5c5a986bb7a0ca537de53f074be54">reserve</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> new_cap)</td></tr>
<tr class="memdesc:aafb5c5a986bb7a0ca537de53f074be54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Informs a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object of a planned change in size, so that it can manage the storage allocation appropriately.  <br /></td></tr>
<tr class="separator:aafb5c5a986bb7a0ca537de53f074be54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d03294134f9f849d74e8d303d261ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a14d03294134f9f849d74e8d303d261ac">resize</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count)</td></tr>
<tr class="memdesc:a14d03294134f9f849d74e8d303d261ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the string to contain count characters.  <br /></td></tr>
<tr class="separator:a14d03294134f9f849d74e8d303d261ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab478619bd3d3a456619a9b9b1d9ef3a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ab478619bd3d3a456619a9b9b1d9ef3a7">resize</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> ch)</td></tr>
<tr class="memdesc:ab478619bd3d3a456619a9b9b1d9ef3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the string to contain count characters.  <br /></td></tr>
<tr class="separator:ab478619bd3d3a456619a9b9b1d9ef3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2785748c9a606a2c0c724086b3b7a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afd2785748c9a606a2c0c724086b3b7a3">rfind</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str) const</td></tr>
<tr class="memdesc:afd2785748c9a606a2c0c724086b3b7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last substring that is equal to the given character sequence. The search begins at <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a><code>and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a>). If <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> or any value not smaller than <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad0bcb20cc5e977d053c10714929242c6" title="Returns the number of char_t elements in the string, i.e. std::distance(begin(), end()).">xtd::text::basic_string_builder::size()</a> - 1 is passed as <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a>, the whole string will be searched. @return Position of the first character of the found substring or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such substring is found. @remarks Finds the first substring equal to</code>str`.  <br /></td></tr>
<tr class="separator:afd2785748c9a606a2c0c724086b3b7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50146eee209c5eeef9ea1a6eaebb2459"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a50146eee209c5eeef9ea1a6eaebb2459">rfind</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos) const</td></tr>
<tr class="memdesc:a50146eee209c5eeef9ea1a6eaebb2459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> or any value not smaller than <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad0bcb20cc5e977d053c10714929242c6" title="Returns the number of char_t elements in the string, i.e. std::distance(begin(), end()).">xtd::text::basic_string_builder::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched.  <br /></td></tr>
<tr class="separator:a50146eee209c5eeef9ea1a6eaebb2459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0aad3615278f80f49b1a999a6317f13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aa0aad3615278f80f49b1a999a6317f13">rfind</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count) const</td></tr>
<tr class="memdesc:aa0aad3615278f80f49b1a999a6317f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> or any value not smaller than <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad0bcb20cc5e977d053c10714929242c6" title="Returns the number of char_t elements in the string, i.e. std::distance(begin(), end()).">xtd::text::basic_string_builder::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched.  <br /></td></tr>
<tr class="separator:aa0aad3615278f80f49b1a999a6317f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00668ba07c172dcadfb3ce3d1371f3cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00668ba07c172dcadfb3ce3d1371f3cd">rfind</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:a00668ba07c172dcadfb3ce3d1371f3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last substring that is equal to the given character sequence. The search begins at <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a><code>and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a>). If <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> or any value not smaller than <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad0bcb20cc5e977d053c10714929242c6" title="Returns the number of char_t elements in the string, i.e. std::distance(begin(), end()).">xtd::text::basic_string_builder::size()</a> - 1 is passed as <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a>, the whole string will be searched. @param s The pointer to a character string to search for. @return Position of the first character of the found substring or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such substring is found. @remarks Finds the first substring equal to the character string pointed to by</code>s<code>. The length of the string is determined by the first null character using</code>traits_t::length(s)<code>. @remarks If [</code>s<code>,</code>s + traits_t::length(s)`) is not a valid range, the behavior is undefined.  <br /></td></tr>
<tr class="separator:a00668ba07c172dcadfb3ce3d1371f3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab026da2f2056155bb144787f950ca3e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ab026da2f2056155bb144787f950ca3e7">rfind</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos) const</td></tr>
<tr class="memdesc:ab026da2f2056155bb144787f950ca3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> or any value not smaller than <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad0bcb20cc5e977d053c10714929242c6" title="Returns the number of char_t elements in the string, i.e. std::distance(begin(), end()).">xtd::text::basic_string_builder::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched.  <br /></td></tr>
<tr class="separator:ab026da2f2056155bb144787f950ca3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee1570674497bc4871d7ad3b9b17ed7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a2ee1570674497bc4871d7ad3b9b17ed7">rfind</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> ch) const</td></tr>
<tr class="memdesc:a2ee1570674497bc4871d7ad3b9b17ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last substring that is equal to the given character sequence. The search begins at <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a><code>and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a>). If <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> or any value not smaller than <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad0bcb20cc5e977d053c10714929242c6" title="Returns the number of char_t elements in the string, i.e. std::distance(begin(), end()).">xtd::text::basic_string_builder::size()</a> - 1 is passed as <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a>, the whole string will be searched. @param ch The character to search for. @return Position of the first character of the found substring or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such substring is found. @remarks Finds the first character</code>ch` (treated as a single-character substring by the formal rules below).  <br /></td></tr>
<tr class="separator:a2ee1570674497bc4871d7ad3b9b17ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd5950f09061481c41efd222922d8ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#adcd5950f09061481c41efd222922d8ce">rfind</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> ch, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos) const</td></tr>
<tr class="memdesc:adcd5950f09061481c41efd222922d8ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> or any value not smaller than <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad0bcb20cc5e977d053c10714929242c6" title="Returns the number of char_t elements in the string, i.e. std::distance(begin(), end()).">xtd::text::basic_string_builder::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched.  <br /></td></tr>
<tr class="separator:adcd5950f09061481c41efd222922d8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa3478a9e5c14cf145652dae38ef19f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3fa3478a9e5c14cf145652dae38ef19f">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:a3fa3478a9e5c14cf145652dae38ef19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the removal of unused capacity.  <br /></td></tr>
<tr class="separator:a3fa3478a9e5c14cf145652dae38ef19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168d97f3252db3d6706fa324190fbcd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a168d97f3252db3d6706fa324190fbcd8">substr</a> () const</td></tr>
<tr class="memdesc:a168d97f3252db3d6706fa324190fbcd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a substring [<code>pos</code>, <code>pos + count</code>). If the requested substring extends past the end of the string, i.e. the <code>count</code> is greater than <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a> - pos (e.g. if <code>count</code> == <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a>), the returned substring is [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>).  <br /></td></tr>
<tr class="separator:a168d97f3252db3d6706fa324190fbcd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b6033babf65f6afa93c1fa114fae88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aa6b6033babf65f6afa93c1fa114fae88">substr</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos) const</td></tr>
<tr class="memdesc:aa6b6033babf65f6afa93c1fa114fae88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a substring [<code>pos</code>, <code>pos + count</code>). If the requested substring extends past the end of the string, i.e. the <code>count</code> is greater than <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a> - pos (e.g. if <code>count</code> == <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a>), the returned substring is [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>).  <br /></td></tr>
<tr class="separator:aa6b6033babf65f6afa93c1fa114fae88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40cd57b1e78f411c904144725389941a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a40cd57b1e78f411c904144725389941a">substr</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> pos, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> count) const</td></tr>
<tr class="memdesc:a40cd57b1e78f411c904144725389941a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a substring [<code>pos</code>, <code>pos + count</code>). If the requested substring extends past the end of the string, i.e. the <code>count</code> is greater than <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a> - pos (e.g. if <code>count</code> == <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a>), the returned substring is [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>).  <br /></td></tr>
<tr class="separator:a40cd57b1e78f411c904144725389941a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4adcc8a4f6c42434091cc96fcc49061"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aa4adcc8a4f6c42434091cc96fcc49061">swap</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept</td></tr>
<tr class="memdesc:aa4adcc8a4f6c42434091cc96fcc49061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of the string with those of other. All iterators and references may be invalidated.  <br /></td></tr>
<tr class="separator:aa4adcc8a4f6c42434091cc96fcc49061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877feeab7ac0df07e40be12990dec52d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a877feeab7ac0df07e40be12990dec52d">to_string</a> () const noexcept override</td></tr>
<tr class="memdesc:a877feeab7ac0df07e40be12990dec52d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the value of this instance to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> &lt;char&gt;.  <br /></td></tr>
<tr class="separator:a877feeab7ac0df07e40be12990dec52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Operators</h2></td></tr>
<tr class="memitem:a3d162b34eefce8985ad367f3ca78e4dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a7a9fff0c8a14fc2115fe86547402e0b4">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3d162b34eefce8985ad367f3ca78e4dc">operator[]</a> (<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index) const</td></tr>
<tr class="memdesc:a3d162b34eefce8985ad367f3ca78e4dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the character at specified location index.  <br /></td></tr>
<tr class="separator:a3d162b34eefce8985ad367f3ca78e4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99facb90b642227990bd5b1f94bb1750"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a9b9b46ae1d66c7d5c9ac716899c0be58">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a99facb90b642227990bd5b1f94bb1750">operator[]</a> (<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index)</td></tr>
<tr class="memdesc:a99facb90b642227990bd5b1f94bb1750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the character at specified location index.  <br /></td></tr>
<tr class="separator:a99facb90b642227990bd5b1f94bb1750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f8e06524f9fa65f9c7017a9d9e4619"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ab1f8e06524f9fa65f9c7017a9d9e4619">operator const base_type &amp;</a> () const noexcept</td></tr>
<tr class="memdesc:ab1f8e06524f9fa65f9c7017a9d9e4619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the underlying base type.  <br /></td></tr>
<tr class="separator:ab1f8e06524f9fa65f9c7017a9d9e4619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f826690bfb0d112064bfdd5cb0e0f88"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a6f826690bfb0d112064bfdd5cb0e0f88">operator base_type &amp;</a> () noexcept</td></tr>
<tr class="memdesc:a6f826690bfb0d112064bfdd5cb0e0f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the underlying base type.  <br /></td></tr>
<tr class="separator:a6f826690bfb0d112064bfdd5cb0e0f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ecaa8470016180805e8aae60741be04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a1ecaa8470016180805e8aae60741be04">operator=</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str) noexcept</td></tr>
<tr class="memdesc:a1ecaa8470016180805e8aae60741be04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of str.  <br /></td></tr>
<tr class="separator:a1ecaa8470016180805e8aae60741be04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea8f1950013cfa7b62845ed804eadf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afea8f1950013cfa7b62845ed804eadf2">operator=</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&amp;str) noexcept</td></tr>
<tr class="memdesc:afea8f1950013cfa7b62845ed804eadf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in <code>str</code> is moved from <code>str</code> into this string). <code>str</code> is in a valid but unspecified state afterwards.  <br /></td></tr>
<tr class="separator:afea8f1950013cfa7b62845ed804eadf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb76aa90b3febf78d306d5eae58c0aaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aeb76aa90b3febf78d306d5eae58c0aaa">operator=</a> (const std::basic_string&lt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:aeb76aa90b3febf78d306d5eae58c0aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:aeb76aa90b3febf78d306d5eae58c0aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cba958ff90c1eae4110b211598479ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a8cba958ff90c1eae4110b211598479ed">operator=</a> (std::basic_string&lt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> &gt; &amp;&amp;str) noexcept</td></tr>
<tr class="memdesc:a8cba958ff90c1eae4110b211598479ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:a8cba958ff90c1eae4110b211598479ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361314e49ff5adb0ece44b9ebeaa068d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a361314e49ff5adb0ece44b9ebeaa068d">operator=</a> (const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:a361314e49ff5adb0ece44b9ebeaa068d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:a361314e49ff5adb0ece44b9ebeaa068d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7b1d4ebec4fcf9da9d90ea3c3219cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a7c7b1d4ebec4fcf9da9d90ea3c3219cb">operator=</a> (<a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> &gt; &amp;&amp;str) noexcept</td></tr>
<tr class="memdesc:a7c7b1d4ebec4fcf9da9d90ea3c3219cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:a7c7b1d4ebec4fcf9da9d90ea3c3219cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9440ad97280090e604efa6d926641189"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a9440ad97280090e604efa6d926641189">operator=</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> str)</td></tr>
<tr class="memdesc:a9440ad97280090e604efa6d926641189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:a9440ad97280090e604efa6d926641189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8965763778b83efc5a9f7557806f2a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad8965763778b83efc5a9f7557806f2a1">operator=</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> character)</td></tr>
<tr class="memdesc:ad8965763778b83efc5a9f7557806f2a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with the specified character.  <br /></td></tr>
<tr class="separator:ad8965763778b83efc5a9f7557806f2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628c15f570caf7d2efa10554d1fde169"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a628c15f570caf7d2efa10554d1fde169">operator=</a> (const std::initializer_list&lt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> &gt; &amp;il)</td></tr>
<tr class="memdesc:a628c15f570caf7d2efa10554d1fde169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of the specified initializer list.  <br /></td></tr>
<tr class="separator:a628c15f570caf7d2efa10554d1fde169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091ac07faa8b98417e11d70f4272d1c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a091ac07faa8b98417e11d70f4272d1c1">operator+=</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str)</td></tr>
<tr class="memdesc:a091ac07faa8b98417e11d70f4272d1c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a091ac07faa8b98417e11d70f4272d1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b9d25941d4757dc74bb5b1a956d79f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#af2b9d25941d4757dc74bb5b1a956d79f">operator+=</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&amp;str)</td></tr>
<tr class="memdesc:af2b9d25941d4757dc74bb5b1a956d79f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:af2b9d25941d4757dc74bb5b1a956d79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446536be6df64bb7da260de2891a3993"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a446536be6df64bb7da260de2891a3993">operator+=</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> str)</td></tr>
<tr class="memdesc:a446536be6df64bb7da260de2891a3993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a446536be6df64bb7da260de2891a3993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad64103e7fd14893e78d8ccd8e71bb82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aad64103e7fd14893e78d8ccd8e71bb82">operator+=</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> ch)</td></tr>
<tr class="memdesc:aad64103e7fd14893e78d8ccd8e71bb82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:aad64103e7fd14893e78d8ccd8e71bb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1object.html">xtd::object</a></td></tr>
<tr class="memitem:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ad2cab851376bb6ca085b567bf5da0f5f">object</a> ()=default</td></tr>
<tr class="memdesc:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of the ultimate base class object.  <br /></td></tr>
<tr class="separator:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1type__object.html">type_object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a322144840e8ad539c039538997b0fe40">get_type</a> () const noexcept</td></tr>
<tr class="memdesc:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the current instance.  <br /></td></tr>
<tr class="separator:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9700deaba669584080178e391d97c4 inherit pub_methods_classxtd_1_1object"><td class="memTemplParams" colspan="2">template&lt;class object_t &gt; </td></tr>
<tr class="memitem:abb9700deaba669584080178e391d97c4 inherit pub_methods_classxtd_1_1object"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga4ac188feb2d52b21e188417441519bb2">xtd::uptr</a>&lt; object_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#abb9700deaba669584080178e391d97c4">memberwise_clone</a> () const</td></tr>
<tr class="memdesc:abb9700deaba669584080178e391d97c4 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shallow copy of the current object.  <br /></td></tr>
<tr class="separator:abb9700deaba669584080178e391d97c4 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1iequatable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1iequatable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1iequatable.html">xtd::iequatable&lt; type_t &gt;</a></td></tr>
<tr class="memitem:a1f8bbde943d2e5ecf565734c60e23903 inherit pub_methods_classxtd_1_1iequatable"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1iequatable.html#a1f8bbde943d2e5ecf565734c60e23903">equals</a> (const type_t &amp;) const noexcept=0</td></tr>
<tr class="memdesc:a1f8bbde943d2e5ecf565734c60e23903 inherit pub_methods_classxtd_1_1iequatable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the current object is equal to another object of the same type.  <br /></td></tr>
<tr class="separator:a1f8bbde943d2e5ecf565734c60e23903 inherit pub_methods_classxtd_1_1iequatable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classxtd_1_1object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classxtd_1_1object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classxtd_1_1object.html">xtd::object</a></td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6 inherit pub_static_methods_classxtd_1_1object"><td class="memTemplParams" colspan="2">template&lt;class object_a_t , class object_b_t &gt; </td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6 inherit pub_static_methods_classxtd_1_1object"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a7fa6fd860800fb1dd1caac338e2355e6">equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a7fa6fd860800fb1dd1caac338e2355e6 inherit pub_static_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are considered equal.  <br /></td></tr>
<tr class="separator:a7fa6fd860800fb1dd1caac338e2355e6 inherit pub_static_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5 inherit pub_static_methods_classxtd_1_1object"><td class="memTemplParams" colspan="2">template&lt;class object_a_t , class object_b_t &gt; </td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5 inherit pub_static_methods_classxtd_1_1object"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a772d50f4da23b418b7e3a523f52564b5">reference_equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a772d50f4da23b418b7e3a523f52564b5 inherit pub_static_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are the same instance.  <br /></td></tr>
<tr class="separator:a772d50f4da23b418b7e3a523f52564b5 inherit pub_static_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac9f39b0cc8b359570352fb6c86f17424" name="ac9f39b0cc8b359570352fb6c86f17424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f39b0cc8b359570352fb6c86f17424">&#9670;&#160;</a></span>base_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::base_type =  std::basic_string&lt;char_t, traits_t, allocator_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the basic string base type. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Is equal to <code>std::basic_string&lt;char_t, traits_t, allocator_t&gt;</code>.` </dd></dl>

</div>
</div>
<a id="a24f317b652276573d985e1cca5d94d4e" name="a24f317b652276573d985e1cca5d94d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f317b652276573d985e1cca5d94d4e">&#9670;&#160;</a></span>traits_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::traits_type =  typename base_type::traits_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the basic string traits type. </p>

</div>
</div>
<a id="afc4750931de93fb98ca4024209bd18cc" name="afc4750931de93fb98ca4024209bd18cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc4750931de93fb98ca4024209bd18cc">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::value_type =  typename base_type::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the basic string value type. </p>

</div>
</div>
<a id="aeb22ca3eb2fea9a222bddac1b5282675" name="aeb22ca3eb2fea9a222bddac1b5282675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb22ca3eb2fea9a222bddac1b5282675">&#9670;&#160;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::allocator_type =  typename base_type::allocator_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the basic string allocator type. </p>

</div>
</div>
<a id="a00d3525c87b582cd9dbf27852cf1199f" name="a00d3525c87b582cd9dbf27852cf1199f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d3525c87b582cd9dbf27852cf1199f">&#9670;&#160;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::size_type =  typename base_type::size_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the basic string size type. </p>

</div>
</div>
<a id="a09714b6f7df9b2a5b5372affd6a4265d" name="a09714b6f7df9b2a5b5372affd6a4265d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09714b6f7df9b2a5b5372affd6a4265d">&#9670;&#160;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::difference_type =  typename base_type::difference_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the basic string difference type. </p>

</div>
</div>
<a id="a9b9b46ae1d66c7d5c9ac716899c0be58" name="a9b9b46ae1d66c7d5c9ac716899c0be58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9b46ae1d66c7d5c9ac716899c0be58">&#9670;&#160;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::reference =  typename base_type::reference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the basic string referecne type. </p>

</div>
</div>
<a id="a7a9fff0c8a14fc2115fe86547402e0b4" name="a7a9fff0c8a14fc2115fe86547402e0b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a9fff0c8a14fc2115fe86547402e0b4">&#9670;&#160;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::const_reference =  typename base_type::const_reference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the basic string const referecne type. </p>

</div>
</div>
<a id="aa62aee9e769ee262f5deae94ff8ea03d" name="aa62aee9e769ee262f5deae94ff8ea03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa62aee9e769ee262f5deae94ff8ea03d">&#9670;&#160;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::pointer =  typename base_type::pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the basic string pointer type. </p>

</div>
</div>
<a id="a5c11cf7a49f5f7c9bea14c37f003fafa" name="a5c11cf7a49f5f7c9bea14c37f003fafa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c11cf7a49f5f7c9bea14c37f003fafa">&#9670;&#160;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::const_pointer =  typename base_type::const_pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the basic string const pointer type. </p>

</div>
</div>
<a id="aae7df40d1cb269bbcdd170dde0f5dc20" name="aae7df40d1cb269bbcdd170dde0f5dc20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7df40d1cb269bbcdd170dde0f5dc20">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::iterator =  typename base_type::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the basic string iterator type. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000036">Todo:</a></b></dt><dd>replace xtd::ienumerable::iterator </dd></dl>

</div>
</div>
<a id="ae5600ab3681a2caadbce6938ea712fa1" name="ae5600ab3681a2caadbce6938ea712fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5600ab3681a2caadbce6938ea712fa1">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::const_iterator =  typename base_type::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the basic string const iterator type. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000037">Todo:</a></b></dt><dd>replace xtd::ienumerable::const_iterator </dd></dl>

</div>
</div>
<a id="aede664826bfa8b77004d2d6820265a2b" name="aede664826bfa8b77004d2d6820265a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede664826bfa8b77004d2d6820265a2b">&#9670;&#160;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::reverse_iterator =  typename base_type::reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the basic string reverse iterator type. </p>

</div>
</div>
<a id="adfa1a4e25bf1791171d367f204d8908d" name="adfa1a4e25bf1791171d367f204d8908d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa1a4e25bf1791171d367f204d8908d">&#9670;&#160;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::const_reverse_iterator =  typename base_type::const_reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the basic string const reverse iterator type. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6bbc2dc030748cdd71c255645df68db7" name="a6bbc2dc030748cdd71c255645df68db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bbc2dc030748cdd71c255645df68db7">&#9670;&#160;</a></span>basic_string_builder() <span class="overload">[1/29]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string_builder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. </p>
<dl class="section user"><dt>Examples</dt><dd>The following example demonstrates how to call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> constructor with no parameters. <div class="fragment"><div class="line"><span class="keyword">auto</span> sb = <a class="code hl_typedef" href="group__strings.html#ga01dd8c7bcd2cfe43dec73df5b56f9d57">string_builder</a>();</div>
<div class="ttc" id="agroup__strings_html_ga01dd8c7bcd2cfe43dec73df5b56f9d57"><div class="ttname"><a href="group__strings.html#ga01dd8c7bcd2cfe43dec73df5b56f9d57">xtd::text::string_builder</a></div><div class="ttdeci">xtd::text::basic_string_builder&lt; char &gt; string_builder</div><div class="ttdoc">Represents text as a sequence of UTF-8 code units.</div><div class="ttdef"><b>Definition</b> string_builder.hpp:20</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a34138ab1b00c5623fd78d2e3a3737764" name="a34138ab1b00c5623fd78d2e3a3737764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34138ab1b00c5623fd78d2e3a3737764">&#9670;&#160;</a></span>basic_string_builder() <span class="overload">[2/29]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string_builder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> class using the specified capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The suggested starting size of this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">argument_out_of_range_exception</a></td><td>`capacity` is greater than <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following example demonstrates how to call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> constructor with a specified capacity. <div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a1fc6dca79d34264f29e710ffe3ce6e89">capacity</a> = 255_z;</div>
<div class="line"><span class="keyword">auto</span> sb = <a class="code hl_typedef" href="group__strings.html#ga01dd8c7bcd2cfe43dec73df5b56f9d57">string_builder</a>(<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a1fc6dca79d34264f29e710ffe3ce6e89">capacity</a>);</div>
<div class="ttc" id="aclassxtd_1_1text_1_1basic__string__builder_html_a1fc6dca79d34264f29e710ffe3ce6e89"><div class="ttname"><a href="classxtd_1_1text_1_1basic__string__builder.html#a1fc6dca79d34264f29e710ffe3ce6e89">xtd::text::basic_string_builder::capacity</a></div><div class="ttdeci">size_type capacity() const noexcept</div><div class="ttdoc">Returns the number of characters that the string has currently allocated space for.</div><div class="ttdef"><b>Definition</b> basic_string_builder.hpp:324</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <code>capacity</code> parameter defines the maximum number of characters that can be stored in the memory allocated by the current instance. Its value is assigned to the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a1fc6dca79d34264f29e710ffe3ce6e89" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::capacity</a> property. If the number of characters to be stored in the current instance exceeds this capacity value, the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object allocates additional memory to store them. </dd>
<dd>
The string value of this instance is set to <a class="el" href="classxtd_1_1basic__string.html#a0ae9e9b0cbe9df3f4fc03f7e4682ef2e" title="Represents the empty basic_string.">xtd::string::empty_string</a>. If capacity is zero, the implementation-specific default capacity is used. </dd></dl>

</div>
</div>
<a id="a3c8c9b34721a5dce3830f0e76d94d517" name="a3c8c9b34721a5dce3830f0e76d94d517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8c9b34721a5dce3830f0e76d94d517">&#9670;&#160;</a></span>basic_string_builder() <span class="overload">[3/29]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string_builder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>max_capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> class that starts with a specified capacity and can grow to a specified maximum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The suggested starting size of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>.. </td></tr>
    <tr><td class="paramname">max_capacity</td><td>The maximum number of characters the current string can contain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`capacity` is greater than `max_capacity`. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following example demonstrates how to call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> constructor with a specified capacity and maximum capacity. <div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a1fc6dca79d34264f29e710ffe3ce6e89">capacity</a> = 255_z;</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e">max_capacity</a> = 1024_z</div>
<div class="line"><span class="keyword">auto</span> sb = <a class="code hl_typedef" href="group__strings.html#ga01dd8c7bcd2cfe43dec73df5b56f9d57">string_builder</a>(<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a1fc6dca79d34264f29e710ffe3ce6e89">capacity</a>, <a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e">max_capacity</a>);</div>
<div class="ttc" id="aclassxtd_1_1text_1_1basic__string__builder_html_a82a9b0e909ef5975e6ac07821b8b100e"><div class="ttname"><a href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e">xtd::text::basic_string_builder::max_capacity</a></div><div class="ttdeci">size_type max_capacity() const noexcept</div><div class="ttdoc">Returns the number of characters that the string has currently allocated space for.</div><div class="ttdef"><b>Definition</b> basic_string_builder.hpp:409</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <code>capacity</code> parameter defines the maximum number of characters that can be stored in the memory allocated by the current instance. Its value is assigned to the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a1fc6dca79d34264f29e710ffe3ce6e89" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::capacity</a> property. If the number of characters to be stored in the current instance exceeds this capacity value, the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object allocates additional memory to store them. </dd>
<dd>
If <code>capacity</code> is zero, the implementation-specific default capacity is used. </dd>
<dd>
The <code>max_capacity</code> parameter defines the maximum number of characters that the current instance can hold. Its value is assigned to the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a> property. If the number of characters to be stored in the current instance exceeds this <code>max_capacity</code> value, the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object does not allocate additional memory, but instead throws an exception. </dd></dl>

</div>
</div>
<a id="a4a982761414718b3de9e273d2ffa0bb9" name="a4a982761414718b3de9e273d2ffa0bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a982761414718b3de9e273d2ffa0bb9">&#9670;&#160;</a></span>basic_string_builder() <span class="overload">[4/29]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string_builder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> class using the specified string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string used to initialize the value of the instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following example demonstrates how to call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> constructor with the specified string. <div class="fragment"><div class="line"><span class="keyword">auto</span> initial_string = <span class="stringliteral">&quot;Initial string.&quot;</span>_s;</div>
<div class="line"><span class="keyword">auto</span> sb = <a class="code hl_typedef" href="group__strings.html#ga01dd8c7bcd2cfe43dec73df5b56f9d57">string_builder</a>(initial_string);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a9cf3305b60b88f2f2da9a27d89bec228" name="a9cf3305b60b88f2f2da9a27d89bec228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf3305b60b88f2f2da9a27d89bec228">&#9670;&#160;</a></span>basic_string_builder() <span class="overload">[5/29]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string_builder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> class using the specified string and capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string used to initialize the value of the instance. </td></tr>
    <tr><td class="paramname">capacity</td><td>The suggested starting size of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following example demonstrates how to call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> constructor with an initial string and a specified capacity. <div class="fragment"><div class="line"><span class="keyword">auto</span> initial_string = <span class="stringliteral">&quot;Initial string.&quot;</span>_s;</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a1fc6dca79d34264f29e710ffe3ce6e89">capacity</a> = 255_z;</div>
<div class="line"><span class="keyword">auto</span> sb = <a class="code hl_typedef" href="group__strings.html#ga01dd8c7bcd2cfe43dec73df5b56f9d57">string_builder</a>(initial_string, <a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a1fc6dca79d34264f29e710ffe3ce6e89">capacity</a>);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <code>capacity</code> parameter defines the maximum number of characters that can be stored in the memory allocated by the current instance. Its value is assigned to the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a1fc6dca79d34264f29e710ffe3ce6e89" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::capacity</a> property. If the number of characters to be stored in the current instance exceeds this capacity value, the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object allocates additional memory to store them. </dd></dl>

</div>
</div>
<a id="a092c81a4ac625c0e2a7302e229d70afe" name="a092c81a4ac625c0e2a7302e229d70afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a092c81a4ac625c0e2a7302e229d70afe">&#9670;&#160;</a></span>basic_string_builder() <span class="overload">[6/29]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string_builder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> class from the specified substring and capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string that contains the substring used to initialize the value of this instance. </td></tr>
    <tr><td class="paramname">start_index</td><td>The position within value where the substring begins. </td></tr>
    <tr><td class="paramname">length</td><td>The number of characters in the substring. </td></tr>
    <tr><td class="paramname">capacity</td><td>The suggested starting size of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`start_index` plus `length` is not a position within `value`. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following example demonstrates how to call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> constructor with an initial string and a specified capacity. <div class="fragment"><div class="line"><span class="keyword">auto</span> initial_string = <span class="stringliteral">&quot;Initial string for stringbuilder.&quot;</span>_s;</div>
<div class="line"><span class="keyword">auto</span> start_index = 0_z;</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a69a83b009389b1b5706ce202a2989afd">length</a> = 14_z;</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a1fc6dca79d34264f29e710ffe3ce6e89">capacity</a> = 255_z;</div>
<div class="line"><span class="keyword">auto</span> sb = <a class="code hl_typedef" href="group__strings.html#ga01dd8c7bcd2cfe43dec73df5b56f9d57">string_builder</a>(initial_string, start_index, <a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a69a83b009389b1b5706ce202a2989afd">length</a>, <a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a1fc6dca79d34264f29e710ffe3ce6e89">capacity</a>);</div>
<div class="ttc" id="aclassxtd_1_1text_1_1basic__string__builder_html_a69a83b009389b1b5706ce202a2989afd"><div class="ttname"><a href="classxtd_1_1text_1_1basic__string__builder.html#a69a83b009389b1b5706ce202a2989afd">xtd::text::basic_string_builder::length</a></div><div class="ttdeci">size_type length() const noexcept</div><div class="ttdoc">Gets or sets the length of the current xtd::text::basic_string_builder object.</div><div class="ttdef"><b>Definition</b> basic_string_builder.hpp:392</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <code>capacity</code> parameter defines the maximum number of characters that can be stored in the memory allocated by the current instance. Its value is assigned to the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a1fc6dca79d34264f29e710ffe3ce6e89" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::capacity</a> property. If the number of characters to be stored in the current instance exceeds this capacity value, the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object allocates additional memory to store them. </dd></dl>

</div>
</div>
<a id="ab95cd1bd91463f31ace42004beafe7dd" name="ab95cd1bd91463f31ace42004beafe7dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab95cd1bd91463f31ace42004beafe7dd">&#9670;&#160;</a></span>basic_string_builder() <span class="overload">[7/29]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string_builder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aeb22ca3eb2fea9a222bddac1b5282675">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4f315a639b6c053a7a6c7fa64f0d7d8" name="ab4f315a639b6c053a7a6c7fa64f0d7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f315a639b6c053a7a6c7fa64f0d7d8">&#9670;&#160;</a></span>basic_string_builder() <span class="overload">[8/29]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string_builder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified string to copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af20ff6e0d2e0c4f2249b011b9dc57c15" name="af20ff6e0d2e0c4f2249b011b9dc57c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af20ff6e0d2e0c4f2249b011b9dc57c15">&#9670;&#160;</a></span>basic_string_builder() <span class="overload">[9/29]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string_builder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aeb22ca3eb2fea9a222bddac1b5282675">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified string to copy and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2eaaca7b4913f37dedbb0193b1fb1f3" name="ac2eaaca7b4913f37dedbb0193b1fb1f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2eaaca7b4913f37dedbb0193b1fb1f3">&#9670;&#160;</a></span>basic_string_builder() <span class="overload">[10/29]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string_builder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified substring at index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>`index` is greater or equal than `str` size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74e01bf4600fcf39d0fd6f655a5e7d48" name="a74e01bf4600fcf39d0fd6f655a5e7d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e01bf4600fcf39d0fd6f655a5e7d48">&#9670;&#160;</a></span>basic_string_builder() <span class="overload">[11/29]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string_builder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aeb22ca3eb2fea9a222bddac1b5282675">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified substring at index and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>`index` is greater or equal than `str` size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3b1349c7b1ec9e5e4a951d63e6efdf3" name="ab3b1349c7b1ec9e5e4a951d63e6efdf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3b1349c7b1ec9e5e4a951d63e6efdf3">&#9670;&#160;</a></span>basic_string_builder() <span class="overload">[12/29]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string_builder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified substring at index and count characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>`index` + `count`is greater or equal than `str` size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4bc92a0f7ba80c74866fb05686f38458" name="a4bc92a0f7ba80c74866fb05686f38458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc92a0f7ba80c74866fb05686f38458">&#9670;&#160;</a></span>basic_string_builder() <span class="overload">[13/29]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string_builder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aeb22ca3eb2fea9a222bddac1b5282675">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified substring at index, count characters and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>`index` + `count`is greater or equal than `str` size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa41137d5915ae8dee52557e6b0804e81" name="aa41137d5915ae8dee52557e6b0804e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa41137d5915ae8dee52557e6b0804e81">&#9670;&#160;</a></span>basic_string_builder() <span class="overload">[14/29]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string_builder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified string to move. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a> to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a616f2a3c09f7ba771fece8d01e27caf0" name="a616f2a3c09f7ba771fece8d01e27caf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616f2a3c09f7ba771fece8d01e27caf0">&#9670;&#160;</a></span>basic_string_builder() <span class="overload">[15/29]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string_builder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aeb22ca3eb2fea9a222bddac1b5282675">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified string to move and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a> to move. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5dcb91cdaddda62137663dcbaad59e4" name="aa5dcb91cdaddda62137663dcbaad59e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5dcb91cdaddda62137663dcbaad59e4">&#9670;&#160;</a></span>basic_string_builder() <span class="overload">[16/29]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string_builder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>character</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afabace22c8a1a6c4cd4bb18d983e7d48" name="afabace22c8a1a6c4cd4bb18d983e7d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afabace22c8a1a6c4cd4bb18d983e7d48">&#9670;&#160;</a></span>basic_string_builder() <span class="overload">[17/29]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string_builder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aeb22ca3eb2fea9a222bddac1b5282675">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified count copies of character and specified allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7c12587ba88777f36f0294887119931" name="af7c12587ba88777f36f0294887119931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c12587ba88777f36f0294887119931">&#9670;&#160;</a></span>basic_string_builder() <span class="overload">[18/29]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string_builder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified count copies of character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d1fe22bb536b67af64a42aeba74c9b3" name="a5d1fe22bb536b67af64a42aeba74c9b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1fe22bb536b67af64a42aeba74c9b3">&#9670;&#160;</a></span>basic_string_builder() <span class="overload">[19/29]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string_builder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aeb22ca3eb2fea9a222bddac1b5282675">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified count copies of character and specified allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab918a3b6ff903ef3e016ef52d2e45860" name="ab918a3b6ff903ef3e016ef52d2e45860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab918a3b6ff903ef3e016ef52d2e45860">&#9670;&#160;</a></span>basic_string_builder() <span class="overload">[20/29]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string_builder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified string to copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefaf1bb131ee0f2c41f827936e8b34c7" name="aefaf1bb131ee0f2c41f827936e8b34c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefaf1bb131ee0f2c41f827936e8b34c7">&#9670;&#160;</a></span>basic_string_builder() <span class="overload">[21/29]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string_builder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aeb22ca3eb2fea9a222bddac1b5282675">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified string to copy, and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3f09400b466cc35471381198fb4bdbe" name="ab3f09400b466cc35471381198fb4bdbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f09400b466cc35471381198fb4bdbe">&#9670;&#160;</a></span>basic_string_builder() <span class="overload">[22/29]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string_builder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified substring and count characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61ae8d1b9af820c62e746a683c966ccb" name="a61ae8d1b9af820c62e746a683c966ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61ae8d1b9af820c62e746a683c966ccb">&#9670;&#160;</a></span>basic_string_builder() <span class="overload">[23/29]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string_builder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aeb22ca3eb2fea9a222bddac1b5282675">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified substring, count characters and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56b43fccbf6aebef6e176b699a44c63e" name="a56b43fccbf6aebef6e176b699a44c63e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b43fccbf6aebef6e176b699a44c63e">&#9670;&#160;</a></span>basic_string_builder() <span class="overload">[24/29]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string_builder </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified string to copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e09d04571bf80582564efa57e5de001" name="a3e09d04571bf80582564efa57e5de001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e09d04571bf80582564efa57e5de001">&#9670;&#160;</a></span>basic_string_builder() <span class="overload">[25/29]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string_builder </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aeb22ca3eb2fea9a222bddac1b5282675">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified string to copy and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a124dac9dfd4970e6409eb140fb4d21c3" name="a124dac9dfd4970e6409eb140fb4d21c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a124dac9dfd4970e6409eb140fb4d21c3">&#9670;&#160;</a></span>basic_string_builder() <span class="overload">[26/29]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string_builder </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified first and last iterators of substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator of substring. </td></tr>
    <tr><td class="paramname">last</td><td>The first iterator of substring. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abca9835968f490d8e16087d3a3374768" name="abca9835968f490d8e16087d3a3374768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abca9835968f490d8e16087d3a3374768">&#9670;&#160;</a></span>basic_string_builder() <span class="overload">[27/29]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string_builder </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aeb22ca3eb2fea9a222bddac1b5282675">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified first and last iterators of substring and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator of substring. </td></tr>
    <tr><td class="paramname">last</td><td>The first iterator of substring. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe22469b9a3a43e3c96898f3f6fbbf65" name="abe22469b9a3a43e3c96898f3f6fbbf65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe22469b9a3a43e3c96898f3f6fbbf65">&#9670;&#160;</a></span>basic_string_builder() <span class="overload">[28/29]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string_builder </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to fill. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada7cf422a1119c0190cab3c9de2b7363" name="ada7cf422a1119c0190cab3c9de2b7363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7cf422a1119c0190cab3c9de2b7363">&#9670;&#160;</a></span>basic_string_builder() <span class="overload">[29/29]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string_builder </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aeb22ca3eb2fea9a222bddac1b5282675">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> with specified initializer list and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to fill. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8ceb59751b0c5fcc1ea228015d4d2b5b" name="a8ceb59751b0c5fcc1ea228015d4d2b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ceb59751b0c5fcc1ea228015d4d2b5b">&#9670;&#160;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a7a9fff0c8a14fc2115fe86547402e0b4">const_reference</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns reference to the last character in the string. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last character, equivalent to <code>operator[](<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a> - 1)</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>If is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea8d874509ba8435d025a1a3c2c1cb56" name="aea8d874509ba8435d025a1a3c2c1cb56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea8d874509ba8435d025a1a3c2c1cb56">&#9670;&#160;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a9b9b46ae1d66c7d5c9ac716899c0be58">reference</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns reference to the last character in the string. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last character, equivalent to <code>operator[](<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a> - 1)</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>If is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab20a8cc18d7386e351fd5e3850efa269" name="ab20a8cc18d7386e351fd5e3850efa269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20a8cc18d7386e351fd5e3850efa269">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first character of the string. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first character. </dd></dl>

</div>
</div>
<a id="acd10efd565a623e44c46e4b8ffb76bfd" name="acd10efd565a623e44c46e4b8ffb76bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd10efd565a623e44c46e4b8ffb76bfd">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aae7df40d1cb269bbcdd170dde0f5dc20">iterator</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first character of the string. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first character. </dd></dl>

</div>
</div>
<a id="a8cb10a6f59a4c7ba5d4b65ccca8f6695" name="a8cb10a6f59a4c7ba5d4b65ccca8f6695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb10a6f59a4c7ba5d4b65ccca8f6695">&#9670;&#160;</a></span>c_str()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::c_str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to a null-terminated character array with data equivalent to those stored in the string. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the underlying character storage. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The pointer is such that the range [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a8cb10a6f59a4c7ba5d4b65ccca8f6695" title="Returns a pointer to a null-terminated character array with data equivalent to those stored in the st...">c_str()</a></code>, <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a8cb10a6f59a4c7ba5d4b65ccca8f6695" title="Returns a pointer to a null-terminated character array with data equivalent to those stored in the st...">c_str()</a> + <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a></code>] is valid and the values in it correspond to the values stored in the string with an additional null character after the last position. </dd>
<dd>
The pointer obtained from <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a8cb10a6f59a4c7ba5d4b65ccca8f6695" title="Returns a pointer to a null-terminated character array with data equivalent to those stored in the st...">c_str()</a> may be invalidated by:<ul>
<li>Passing a non-const reference to the string to any standard library function, or</li>
<li>Calling non-const member functions on the string, excluding operator[], <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a4874895a2538a2e3e197128c6d3ec0b1" title="Returns a reference to the character at specified location pos.">at()</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a69b43937b0cd6ab3199960fd2bb86d56" title="Returns reference to the first character in the string. The behavior is undefined if empty() is true.">front()</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aea8d874509ba8435d025a1a3c2c1cb56" title="Returns reference to the last character in the string.">back()</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a>, rbegin(), <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a32e986bfe09f3fef3a459b2a7a7b866b" title="Returns an iterator to the character following the last character of the string. This character acts ...">end()</a> and rend(). </li>
</ul>
</dd>
<dd>
Writing to the character array accessed through <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a8cb10a6f59a4c7ba5d4b65ccca8f6695" title="Returns a pointer to a null-terminated character array with data equivalent to those stored in the st...">c_str()</a> is undefined behavior. </dd>
<dd>
<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a8cb10a6f59a4c7ba5d4b65ccca8f6695" title="Returns a pointer to a null-terminated character array with data equivalent to those stored in the st...">c_str()</a> and <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad361d27ed3369d1359dc34e135dede8a" title="Returns a pointer to the underlying array serving as character storage. The pointer is such that the ...">data()</a> perform the same function. </dd></dl>

</div>
</div>
<a id="a1fc6dca79d34264f29e710ffe3ce6e89" name="a1fc6dca79d34264f29e710ffe3ce6e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc6dca79d34264f29e710ffe3ce6e89">&#9670;&#160;</a></span>capacity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of characters that the string has currently allocated space for. </p>
<dl class="section return"><dt>Returns</dt><dd>Capacity of the currently allocated storage, i.e. the storage available for storing elements. </dd></dl>

</div>
</div>
<a id="a1abc22d3c5615941bc4d8030dedbff77" name="a1abc22d3c5615941bc4d8030dedbff77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1abc22d3c5615941bc4d8030dedbff77">&#9670;&#160;</a></span>capacity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the number of characters that the string has currently allocated space for. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Capacity of the currently allocated storage, i.e. the storage available for storing elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa588349c0f4a4068b662b5b0d168bda6" name="aa588349c0f4a4068b662b5b0d168bda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa588349c0f4a4068b662b5b0d168bda6">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first character of the string. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first character. </dd></dl>

</div>
</div>
<a id="abe5944beeb6ea364aeef256dc0089c7c" name="abe5944beeb6ea364aeef256dc0089c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5944beeb6ea364aeef256dc0089c7c">&#9670;&#160;</a></span>chars() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ac9f39b0cc8b359570352fb6c86f17424">base_type</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::chars </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the underlying base type. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the underlying base type. </dd></dl>

</div>
</div>
<a id="a05538f86dee6b57b195ac7dc6030fc50" name="a05538f86dee6b57b195ac7dc6030fc50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05538f86dee6b57b195ac7dc6030fc50">&#9670;&#160;</a></span>chars() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ac9f39b0cc8b359570352fb6c86f17424">base_type</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::chars </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the underlying base type. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the underlying base type. </dd></dl>

</div>
</div>
<a id="aebf812628211c7c6282f30ba9e9ce642" name="aebf812628211c7c6282f30ba9e9ce642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf812628211c7c6282f30ba9e9ce642">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the character following the last character of the string. This character acts as a placeholder, attempting to access it results in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the character following the last character. </dd></dl>

</div>
</div>
<a id="ad1f01d6712b1503a85e4afb98b217f5f" name="ad1f01d6712b1503a85e4afb98b217f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f01d6712b1503a85e4afb98b217f5f">&#9670;&#160;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the underlying array serving as character storage. The pointer is such that the range [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad361d27ed3369d1359dc34e135dede8a" title="Returns a pointer to the underlying array serving as character storage. The pointer is such that the ...">data()</a></code>, <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad361d27ed3369d1359dc34e135dede8a" title="Returns a pointer to the underlying array serving as character storage. The pointer is such that the ...">data()</a> + <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a></code>] is valid and the values in it correspond to the values stored in the string. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the underlying character storage. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The pointer obtained from <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad361d27ed3369d1359dc34e135dede8a" title="Returns a pointer to the underlying array serving as character storage. The pointer is such that the ...">data()</a></code> may be invalidated by:<ul>
<li>Passing a non-const reference to the string to any standard library function, or</li>
<li>Calling non-const member functions on the string, excluding <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3d162b34eefce8985ad367f3ca78e4dc" title="Returns a reference to the character at specified location index.">operator[]()</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a4874895a2538a2e3e197128c6d3ec0b1" title="Returns a reference to the character at specified location pos.">at()</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a69b43937b0cd6ab3199960fd2bb86d56" title="Returns reference to the first character in the string. The behavior is undefined if empty() is true.">front()</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aea8d874509ba8435d025a1a3c2c1cb56" title="Returns reference to the last character in the string.">back()</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a32e986bfe09f3fef3a459b2a7a7b866b" title="Returns an iterator to the character following the last character of the string. This character acts ...">end()</a>, rbegin(), rend().<ol type="1">
<li>Modifying the character array accessed through the const overload of data has undefined behavior.</li>
<li>Modifying the past-the-end null terminator stored at <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad361d27ed3369d1359dc34e135dede8a" title="Returns a pointer to the underlying array serving as character storage. The pointer is such that the ...">data()</a> + <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a> to any value other than char_t() has undefined behavior. </li>
</ol>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad361d27ed3369d1359dc34e135dede8a" name="ad361d27ed3369d1359dc34e135dede8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad361d27ed3369d1359dc34e135dede8a">&#9670;&#160;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aa62aee9e769ee262f5deae94ff8ea03d">pointer</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the underlying array serving as character storage. The pointer is such that the range [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad361d27ed3369d1359dc34e135dede8a" title="Returns a pointer to the underlying array serving as character storage. The pointer is such that the ...">data()</a></code>, <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad361d27ed3369d1359dc34e135dede8a" title="Returns a pointer to the underlying array serving as character storage. The pointer is such that the ...">data()</a> + <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a></code>] is valid and the values in it correspond to the values stored in the string. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the underlying character storage. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The pointer obtained from <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad361d27ed3369d1359dc34e135dede8a" title="Returns a pointer to the underlying array serving as character storage. The pointer is such that the ...">data()</a></code> may be invalidated by:<ul>
<li>Passing a non-const reference to the string to any standard library function, or</li>
<li>Calling non-const member functions on the string, excluding <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3d162b34eefce8985ad367f3ca78e4dc" title="Returns a reference to the character at specified location index.">operator[]()</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a4874895a2538a2e3e197128c6d3ec0b1" title="Returns a reference to the character at specified location pos.">at()</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a69b43937b0cd6ab3199960fd2bb86d56" title="Returns reference to the first character in the string. The behavior is undefined if empty() is true.">front()</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aea8d874509ba8435d025a1a3c2c1cb56" title="Returns reference to the last character in the string.">back()</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a32e986bfe09f3fef3a459b2a7a7b866b" title="Returns an iterator to the character following the last character of the string. This character acts ...">end()</a>, rbegin(), rend().<ol type="1">
<li>Modifying the character array accessed through the const overload of data has undefined behavior.</li>
<li>Modifying the past-the-end null terminator stored at <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad361d27ed3369d1359dc34e135dede8a" title="Returns a pointer to the underlying array serving as character storage. The pointer is such that the ...">data()</a> + <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a> to any value other than char_t() has undefined behavior. </li>
</ol>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac79077a3108f556f2ce8e4231c607fde" name="ac79077a3108f556f2ce8e4231c607fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac79077a3108f556f2ce8e4231c607fde">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the string has no characters, i.e. whether <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> == <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a32e986bfe09f3fef3a459b2a7a7b866b" title="Returns an iterator to the character following the last character of the string. This character acts ...">end()</a></code>. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the string is empty; otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="aeef3ac5569a780cc93f3abb76f74fef2" name="aeef3ac5569a780cc93f3abb76f74fef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef3ac5569a780cc93f3abb76f74fef2">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the character following the last character of the string. This character acts as a placeholder, attempting to access it results in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the character following the last character. </dd></dl>

</div>
</div>
<a id="a32e986bfe09f3fef3a459b2a7a7b866b" name="a32e986bfe09f3fef3a459b2a7a7b866b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32e986bfe09f3fef3a459b2a7a7b866b">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aae7df40d1cb269bbcdd170dde0f5dc20">iterator</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the character following the last character of the string. This character acts as a placeholder, attempting to access it results in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the character following the last character. </dd></dl>

</div>
</div>
<a id="ac33db704e732528f8711c29847c1a36e" name="ac33db704e732528f8711c29847c1a36e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac33db704e732528f8711c29847c1a36e">&#9670;&#160;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a7a9fff0c8a14fc2115fe86547402e0b4">const_reference</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns reference to the first character in the string. The behavior is undefined if <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ac79077a3108f556f2ce8e4231c607fde" title="Checks if the string has no characters, i.e. whether begin() == end().">empty()</a> is <code>true</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first character, equivalent to <code>operator[](0)</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>If is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69b43937b0cd6ab3199960fd2bb86d56" name="a69b43937b0cd6ab3199960fd2bb86d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b43937b0cd6ab3199960fd2bb86d56">&#9670;&#160;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a9b9b46ae1d66c7d5c9ac716899c0be58">reference</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns reference to the first character in the string. The behavior is undefined if <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ac79077a3108f556f2ce8e4231c607fde" title="Checks if the string has no characters, i.e. whether begin() == end().">empty()</a> is <code>true</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first character, equivalent to <code>operator[](0)</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>If is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69a83b009389b1b5706ce202a2989afd" name="a69a83b009389b1b5706ce202a2989afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69a83b009389b1b5706ce202a2989afd">&#9670;&#160;</a></span>length() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets or sets the length of the current <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>The length of this instance. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The length of a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object is defined by its number of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc" title="Represents the basic string value type.">xtd::text::basic_string_builder::value_type</a> objects. </dd>
<dd>
Like the <a class="el" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232" title="Gets the number of characters in the current xtd::basic_string object.">xtd::basic_string::length</a> property, the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a69a83b009389b1b5706ce202a2989afd" title="Gets or sets the length of the current xtd::text::basic_string_builder object.">xtd::text::basic_string_builder::length</a> property indicates the length of the current string object. Unlike the <a class="el" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232" title="Gets the number of characters in the current xtd::basic_string object.">xtd::basic_string::length</a> property, which is read-only, the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a69a83b009389b1b5706ce202a2989afd" title="Gets or sets the length of the current xtd::text::basic_string_builder object.">xtd::text::basic_string_builder::length</a> property allows you to modify the length of the string stored to the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object. </dd>
<dd>
If the specified length is less than the current length, the current <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object is truncated to the specified length. If the specified length is greater than the current length, the end of the string value of the current <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object is padded with the Unicode NULL character (U+0000). </dd>
<dd>
If the specified length is greater than the current capacity, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a1fc6dca79d34264f29e710ffe3ce6e89" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::capacity</a> increases so that it is greater than or equal to the specified length. </dd>
<dd>
The <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a69a83b009389b1b5706ce202a2989afd" title="Gets or sets the length of the current xtd::text::basic_string_builder object.">xtd::text::basic_string_builder::length</a> property returns the number of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc" title="Represents the basic string value type.">xtd::text::basic_string_builder::value_type</a> objects in this instance, not the number of Unicode characters. The reason is that a Unicode character might be represented by more than one <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc" title="Represents the basic string value type.">xtd::text::basic_string_builder::value_type</a>. </dd></dl>

</div>
</div>
<a id="a259a72058d7f426ff10ba30079c26ead" name="a259a72058d7f426ff10ba30079c26ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259a72058d7f426ff10ba30079c26ead">&#9670;&#160;</a></span>length() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets or sets the length of the current <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The length of this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the length has been modified. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>The value specified for a set operation is less than zero or greater than <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The length of a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object is defined by its number of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc" title="Represents the basic string value type.">xtd::text::basic_string_builder::value_type</a> objects. </dd>
<dd>
Like the <a class="el" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232" title="Gets the number of characters in the current xtd::basic_string object.">xtd::basic_string::length</a> property, the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a69a83b009389b1b5706ce202a2989afd" title="Gets or sets the length of the current xtd::text::basic_string_builder object.">xtd::text::basic_string_builder::length</a> property indicates the length of the current string object. Unlike the <a class="el" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232" title="Gets the number of characters in the current xtd::basic_string object.">xtd::basic_string::length</a> property, which is read-only, the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a69a83b009389b1b5706ce202a2989afd" title="Gets or sets the length of the current xtd::text::basic_string_builder object.">xtd::text::basic_string_builder::length</a> property allows you to modify the length of the string stored to the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object. </dd>
<dd>
If the specified length is less than the current length, the current <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object is truncated to the specified length. If the specified length is greater than the current length, the end of the string value of the current <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object is padded with the Unicode NULL character (U+0000). </dd>
<dd>
If the specified length is greater than the current capacity, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a1fc6dca79d34264f29e710ffe3ce6e89" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::capacity</a> increases so that it is greater than or equal to the specified length. </dd>
<dd>
The <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a69a83b009389b1b5706ce202a2989afd" title="Gets or sets the length of the current xtd::text::basic_string_builder object.">xtd::text::basic_string_builder::length</a> property returns the number of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc" title="Represents the basic string value type.">xtd::text::basic_string_builder::value_type</a> objects in this instance, not the number of Unicode characters. The reason is that a Unicode character might be represented by more than one <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc" title="Represents the basic string value type.">xtd::text::basic_string_builder::value_type</a>. </dd></dl>

</div>
</div>
<a id="a82a9b0e909ef5975e6ac07821b8b100e" name="a82a9b0e909ef5975e6ac07821b8b100e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a9b0e909ef5975e6ac07821b8b100e">&#9670;&#160;</a></span>max_capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::max_capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of characters that the string has currently allocated space for. </p>
<dl class="section return"><dt>Returns</dt><dd>Capacity of the currently allocated storage, i.e. the storage available for storing elements. </dd></dl>

</div>
</div>
<a id="aa36eabe6c7e3276bcd466f1fbb78e623" name="aa36eabe6c7e3276bcd466f1fbb78e623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa36eabe6c7e3276bcd466f1fbb78e623">&#9670;&#160;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of elements the string is able to hold due to system or library implementation limitations, i.e. <code>std::distance(<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a32e986bfe09f3fef3a459b2a7a7b866b" title="Returns an iterator to the character following the last character of the string. This character acts ...">end()</a>)</code> for the largest string. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of characters. </dd></dl>

</div>
</div>
<a id="ad0bcb20cc5e977d053c10714929242c6" name="ad0bcb20cc5e977d053c10714929242c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0bcb20cc5e977d053c10714929242c6">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of <code>char_t</code> elements in the string, i.e. <code>std::distance(<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a32e986bfe09f3fef3a459b2a7a7b866b" title="Returns an iterator to the character following the last character of the string. This character acts ...">end()</a>)</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of <code>char_t</code> elements in the string. </dd></dl>

</div>
</div>
<a id="a74b530fbbad4b6b67da525a5b401219d" name="a74b530fbbad4b6b67da525a5b401219d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b530fbbad4b6b67da525a5b401219d">&#9670;&#160;</a></span>append() <span class="overload">[1/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a copy of the specified string to this instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> (const <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>&amp;) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. <div class="fragment"><div class="line"><span class="keyword">auto</span> flag = <span class="keyword">false</span>;</div>
<div class="line"><span class="keyword">auto</span> sb = <a class="code hl_class" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::string_builder</a> {};</div>
<div class="line">sb.<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(<span class="stringliteral">&quot;The value of the flag is &quot;</span>).<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(flag).<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(<span class="stringliteral">&quot;.&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(sb.to_string());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The example displays the following output:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The value of the flag is `false`.</span></div>
<div class="ttc" id="aclassxtd_1_1console_html_ae0ccd7fef284ccda33a88576c8a35a37"><div class="ttname"><a href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">xtd::console::write_line</a></div><div class="ttdeci">static void write_line()</div><div class="ttdoc">Writes the current line terminator to the standard output stream using the specified format informati...</div></div>
<div class="ttc" id="aclassxtd_1_1text_1_1basic__string__builder_html"><div class="ttname"><a href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a></div><div class="ttdoc">Represents a mutable string of characters. This class cannot be inherited.</div><div class="ttdef"><b>Definition</b> basic_string_builder.hpp:35</div></div>
<div class="ttc" id="aclassxtd_1_1text_1_1basic__string__builder_html_a74b530fbbad4b6b67da525a5b401219d"><div class="ttname"><a href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">xtd::text::basic_string_builder::append</a></div><div class="ttdeci">basic_string_builder &amp; append(const xtd::basic_string&lt; char_t &gt; &amp;value)</div><div class="ttdoc">Appends a copy of the specified string to this instance.</div><div class="ttdef"><b>Definition</b> basic_string_builder.hpp:442</div></div>
</div><!-- fragment --> </dd>
<dd>
If <code>value</code> is <code>empty</code>, no changes are made. </dd>
<dd>
The capacity of this instance is adjusted as needed. </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3c8c9b34721a5dce3830f0e76d94d517" title="Initializes a new instance of the xtd::text::basic_string_builder class that starts with a specified ...">xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size)</a> constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a> property. This can occur particularly when you call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> and <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afdea991b3a89ae01e8c998481fa987d3" title="Appends the string returned by processing a composite format string, which contains zero or more form...">xtd::text::basic_string_builder::append_format</a> methods to append small strings. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="string_builder_append_8cpp-example.html#a2">string_builder_append.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a4da9e6a8896481aabbb6dce74a762416" name="a4da9e6a8896481aabbb6dce74a762416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da9e6a8896481aabbb6dce74a762416">&#9670;&#160;</a></span>append() <span class="overload">[2/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a copy of a specified substring to this instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string that contains the substring to append. </td></tr>
    <tr><td class="paramname">start_index</td><td>The starting position of the substring within <code>value</code>. </td></tr>
    <tr><td class="paramname">count</td><td>The number of characters in <code>value</code> to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>.<br  />
-or-<br  />
`start_index` + `count` is greater than the length of `value`. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method appends the specified range of characters in value to the current instance. If <code>value</code> is <code>empty</code> and <code>start_index</code> and <code>count</code> are both zero, no changes are made. </dd>
<dd>
The <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> (const <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>&amp;, size_type, size_type) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. <div class="fragment"><div class="line"><span class="keyword">auto</span> str = <span class="stringliteral">&quot;First;George Washington;1789;1797&quot;</span>_s;</div>
<div class="line"><span class="keyword">auto</span> index = 0_z;</div>
<div class="line"><span class="keyword">auto</span> sb = <a class="code hl_class" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::string_builder</a> {};</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a69a83b009389b1b5706ce202a2989afd">length</a> = str.index_of(<span class="charliteral">&#39;;&#39;</span>, index);</div>
<div class="line">sb.append(str, index, <a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a69a83b009389b1b5706ce202a2989afd">length</a>).append(<span class="stringliteral">&quot; President of the United States: &quot;</span>);</div>
<div class="line">index += <a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a69a83b009389b1b5706ce202a2989afd">length</a> + 1;</div>
<div class="line"><a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a69a83b009389b1b5706ce202a2989afd">length</a> = str.index_of(<span class="charliteral">&#39;;&#39;</span>, index) - index;</div>
<div class="line">sb.append(str, index, <a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a69a83b009389b1b5706ce202a2989afd">length</a>).append(<span class="stringliteral">&quot;, from &quot;</span>);</div>
<div class="line">index += <a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a69a83b009389b1b5706ce202a2989afd">length</a> + 1;</div>
<div class="line"><a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a69a83b009389b1b5706ce202a2989afd">length</a> = str.index_of(<span class="charliteral">&#39;;&#39;</span>, index) - index;</div>
<div class="line">sb.append(str, index, <a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a69a83b009389b1b5706ce202a2989afd">length</a>).append(<span class="stringliteral">&quot; to &quot;</span>);</div>
<div class="line">index += <a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a69a83b009389b1b5706ce202a2989afd">length</a> + 1;</div>
<div class="line">sb.append(str, index, str.length() - index);</div>
<div class="line"><a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(sb);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The example displays the following output:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// First President of the United States: George Washington, from 1789 to 1797</span></div>
</div><!-- fragment --> </dd>
<dd>
The capacity of this instance is adjusted as needed. </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3c8c9b34721a5dce3830f0e76d94d517" title="Initializes a new instance of the xtd::text::basic_string_builder class that starts with a specified ...">xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size)</a> constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a> property. This can occur particularly when you call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> and <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afdea991b3a89ae01e8c998481fa987d3" title="Appends the string returned by processing a composite format string, which contains zero or more form...">xtd::text::basic_string_builder::append_format</a> methods to append small strings. </dd></dl>

</div>
</div>
<a id="afcca2132d878dd94d8994e7ef8fad237" name="afcca2132d878dd94d8994e7ef8fad237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcca2132d878dd94d8994e7ef8fad237">&#9670;&#160;</a></span>append() <span class="overload">[3/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#gab7230dbe491f8bcef5e5f8bdaba5e27f">xtd::boolean</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the string representation of a specified boolean value to this instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The boolean value to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> (<a class="el" href="group__types.html#gab7230dbe491f8bcef5e5f8bdaba5e27f" title="Represents a boolean.">xtd::boolean</a>) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. <div class="fragment"><div class="line"><span class="keyword">auto</span> flag = <span class="keyword">false</span>;</div>
<div class="line"><span class="keyword">auto</span> sb = <a class="code hl_class" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::string_builder</a> {};</div>
<div class="line">sb.<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(<span class="stringliteral">&quot;The value of the flag is &quot;</span>).<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(flag).<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(<span class="stringliteral">&quot;.&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(sb.to_string());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The example displays the following output:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The value of the flag is `false`.</span></div>
</div><!-- fragment --> </dd>
<dd>
The capacity of this instance is adjusted as needed. </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3c8c9b34721a5dce3830f0e76d94d517" title="Initializes a new instance of the xtd::text::basic_string_builder class that starts with a specified ...">xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size)</a> constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a> property. This can occur particularly when you call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> and <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afdea991b3a89ae01e8c998481fa987d3" title="Appends the string returned by processing a composite format string, which contains zero or more form...">xtd::text::basic_string_builder::append_format</a> methods to append small strings. </dd></dl>

</div>
</div>
<a id="a7f2eccf50e17279bf21511fd60903ab2" name="a7f2eccf50e17279bf21511fd60903ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f2eccf50e17279bf21511fd60903ab2">&#9670;&#160;</a></span>append() <span class="overload">[4/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#gabb9d3031d62e3725b4265c7e5d2a98e1">xtd::byte</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the string representation of a specified 8-bit unsigned value to this instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The 8-bit unsigned value to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> (<a class="el" href="group__types.html#gabb9d3031d62e3725b4265c7e5d2a98e1" title="Represents a 8-bit unsigned integer.">xtd::byte</a>) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. <div class="fragment"><div class="line"><span class="keyword">auto</span> bytes = <a class="code hl_class" href="classxtd_1_1array.html">array&lt;byte&gt;</a> {16, 132, 27, 253};</div>
<div class="line"><span class="keyword">auto</span> sb = <a class="code hl_class" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::string_builder</a> {};</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> value : bytes)</div>
<div class="line">  sb.<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(value).<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(<span class="stringliteral">&quot; &quot;</span>);</div>
<div class="line"><a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The byte array: {0}&quot;</span>, sb.to_string());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The example displays the following output:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The byte array: 16 132 27 253</span></div>
<div class="ttc" id="aclassxtd_1_1array_html"><div class="ttname"><a href="classxtd_1_1array.html">xtd::array</a></div><div class="ttdoc">Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...</div><div class="ttdef"><b>Definition</b> array.hpp:59</div></div>
</div><!-- fragment --> </dd>
<dd>
The capacity of this instance is adjusted as needed. </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3c8c9b34721a5dce3830f0e76d94d517" title="Initializes a new instance of the xtd::text::basic_string_builder class that starts with a specified ...">xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size)</a> constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a> property. This can occur particularly when you call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> and <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afdea991b3a89ae01e8c998481fa987d3" title="Appends the string returned by processing a composite format string, which contains zero or more form...">xtd::text::basic_string_builder::append_format</a> methods to append small strings. </dd></dl>

</div>
</div>
<a id="a665936538d24374216c72ac789df1a94" name="a665936538d24374216c72ac789df1a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665936538d24374216c72ac789df1a94">&#9670;&#160;</a></span>append() <span class="overload">[5/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a">xtd::decimal</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the string representation of a specified decimal value to this instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The decimal value to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> (<a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a" title="Represents a decimal-precision floating-point number.">xtd::decimal</a>) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. <div class="fragment"><div class="line"><span class="keyword">auto</span> value = 1346.19l;</div>
<div class="line"><span class="keyword">auto</span> sb = <a class="code hl_class" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::string_builder</a> {};</div>
<div class="line">sb.<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(<span class="charliteral">&#39;*&#39;</span>, 5).<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(value).<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(<span class="charliteral">&#39;*&#39;</span>, 5);</div>
<div class="line"><a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(sb);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The example displays the following output:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// *****1346.19*****</span></div>
</div><!-- fragment --> </dd>
<dd>
The capacity of this instance is adjusted as needed. </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3c8c9b34721a5dce3830f0e76d94d517" title="Initializes a new instance of the xtd::text::basic_string_builder class that starts with a specified ...">xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size)</a> constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a> property. This can occur particularly when you call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> and <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afdea991b3a89ae01e8c998481fa987d3" title="Appends the string returned by processing a composite format string, which contains zero or more form...">xtd::text::basic_string_builder::append_format</a> methods to append small strings. </dd></dl>

</div>
</div>
<a id="a31334474f22063e04a4113319f8b33b6" name="a31334474f22063e04a4113319f8b33b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31334474f22063e04a4113319f8b33b6">&#9670;&#160;</a></span>append() <span class="overload">[6/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::append </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the string representation of a specified double value to this instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The double value to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> (double) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. <div class="fragment"><div class="line"><span class="keyword">auto</span> value = 1346.19;</div>
<div class="line"><span class="keyword">auto</span> sb = <a class="code hl_class" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::string_builder</a> {};</div>
<div class="line">sb.<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(<span class="charliteral">&#39;*&#39;</span>, 5).<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(value).<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(<span class="charliteral">&#39;*&#39;</span>, 5);</div>
<div class="line"><a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(sb);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The example displays the following output:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// *****1346.19*****</span></div>
</div><!-- fragment --> </dd>
<dd>
The capacity of this instance is adjusted as needed. </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3c8c9b34721a5dce3830f0e76d94d517" title="Initializes a new instance of the xtd::text::basic_string_builder class that starts with a specified ...">xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size)</a> constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a> property. This can occur particularly when you call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> and <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afdea991b3a89ae01e8c998481fa987d3" title="Appends the string returned by processing a composite format string, which contains zero or more form...">xtd::text::basic_string_builder::append_format</a> methods to append small strings. </dd></dl>

</div>
</div>
<a id="ae63a690e346ea38d7215307e9583d98e" name="ae63a690e346ea38d7215307e9583d98e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae63a690e346ea38d7215307e9583d98e">&#9670;&#160;</a></span>append() <span class="overload">[7/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga4c9f72f7ab9ea9919c93a1a2b245ab71">xtd::single</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the string representation of a specified single value to this instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The single value to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> (<a class="el" href="group__types.html#ga4c9f72f7ab9ea9919c93a1a2b245ab71" title="Represents a single-precision floating-point number.">xtd::single</a>) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. <div class="fragment"><div class="line"><span class="keyword">auto</span> value = 1346.19f;</div>
<div class="line"><span class="keyword">auto</span> sb = <a class="code hl_class" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::string_builder</a> {};</div>
<div class="line">sb.<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(<span class="charliteral">&#39;*&#39;</span>, 5).<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(value).<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(<span class="charliteral">&#39;*&#39;</span>, 5);</div>
<div class="line"><a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(sb);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The example displays the following output:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// *****1346.19*****</span></div>
</div><!-- fragment --> </dd>
<dd>
The capacity of this instance is adjusted as needed. </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3c8c9b34721a5dce3830f0e76d94d517" title="Initializes a new instance of the xtd::text::basic_string_builder class that starts with a specified ...">xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size)</a> constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a> property. This can occur particularly when you call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> and <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afdea991b3a89ae01e8c998481fa987d3" title="Appends the string returned by processing a composite format string, which contains zero or more form...">xtd::text::basic_string_builder::append_format</a> methods to append small strings. </dd></dl>

</div>
</div>
<a id="a2432a93c66bd22b0e7e92318109d0821" name="a2432a93c66bd22b0e7e92318109d0821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2432a93c66bd22b0e7e92318109d0821">&#9670;&#160;</a></span>append() <span class="overload">[8/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga09d26135a9af4f7a5f4cae382627d6d1">xtd::int16</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the string representation of a specified 16-bit signed integer value to this instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The 16-bit signed value to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> (<a class="el" href="group__types.html#ga09d26135a9af4f7a5f4cae382627d6d1" title="Represents a 16-bit signed integer.">xtd::int16</a>) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. <div class="fragment"><div class="line"><span class="keyword">auto</span> value = 1346_s16;</div>
<div class="line"><span class="keyword">auto</span> sb = <a class="code hl_class" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::string_builder</a> {};</div>
<div class="line">sb.<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(<span class="charliteral">&#39;*&#39;</span>, 5).<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(value).<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(<span class="charliteral">&#39;*&#39;</span>, 5);</div>
<div class="line"><a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(sb);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The example displays the following output:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// *****1346*****</span></div>
</div><!-- fragment --> </dd>
<dd>
The capacity of this instance is adjusted as needed. </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3c8c9b34721a5dce3830f0e76d94d517" title="Initializes a new instance of the xtd::text::basic_string_builder class that starts with a specified ...">xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size)</a> constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a> property. This can occur particularly when you call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> and <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afdea991b3a89ae01e8c998481fa987d3" title="Appends the string returned by processing a composite format string, which contains zero or more form...">xtd::text::basic_string_builder::append_format</a> methods to append small strings. </dd></dl>

</div>
</div>
<a id="a391439e1450dd6677d8eb32a6c2b67d7" name="a391439e1450dd6677d8eb32a6c2b67d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391439e1450dd6677d8eb32a6c2b67d7">&#9670;&#160;</a></span>append() <span class="overload">[9/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the string representation of a specified 32-bit signed integer value to this instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The 32-bit signed value to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> (<a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e" title="Represents a 32-bit signed integer.">xtd::int32</a>) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. <div class="fragment"><div class="line"><span class="keyword">auto</span> value = 1346;</div>
<div class="line"><span class="keyword">auto</span> sb = <a class="code hl_class" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::string_builder</a> {};</div>
<div class="line">sb.<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(<span class="charliteral">&#39;*&#39;</span>, 5).<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(value).<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(<span class="charliteral">&#39;*&#39;</span>, 5);</div>
<div class="line"><a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(sb);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The example displays the following output:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// *****1346*****</span></div>
</div><!-- fragment --> </dd>
<dd>
The capacity of this instance is adjusted as needed. </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3c8c9b34721a5dce3830f0e76d94d517" title="Initializes a new instance of the xtd::text::basic_string_builder class that starts with a specified ...">xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size)</a> constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a> property. This can occur particularly when you call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> and <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afdea991b3a89ae01e8c998481fa987d3" title="Appends the string returned by processing a composite format string, which contains zero or more form...">xtd::text::basic_string_builder::append_format</a> methods to append small strings. </dd></dl>

</div>
</div>
<a id="a8c74d861600b24e5c2356537b5a50473" name="a8c74d861600b24e5c2356537b5a50473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c74d861600b24e5c2356537b5a50473">&#9670;&#160;</a></span>append() <span class="overload">[10/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4">xtd::int64</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the string representation of a specified 64-bit signed integer value to this instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The 64-bit signed value to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> (<a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4" title="Represents a 64-bit signed integer.">xtd::int64</a>) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. <div class="fragment"><div class="line"><span class="keyword">auto</span> value = 1346_s64;</div>
<div class="line"><span class="keyword">auto</span> sb = <a class="code hl_class" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::string_builder</a> {};</div>
<div class="line">sb.<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(<span class="charliteral">&#39;*&#39;</span>, 5).<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(value).<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(<span class="charliteral">&#39;*&#39;</span>, 5);</div>
<div class="line"><a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(sb);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The example displays the following output:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// *****1346*****</span></div>
</div><!-- fragment --> </dd>
<dd>
The capacity of this instance is adjusted as needed. </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3c8c9b34721a5dce3830f0e76d94d517" title="Initializes a new instance of the xtd::text::basic_string_builder class that starts with a specified ...">xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size)</a> constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a> property. This can occur particularly when you call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> and <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afdea991b3a89ae01e8c998481fa987d3" title="Appends the string returned by processing a composite format string, which contains zero or more form...">xtd::text::basic_string_builder::append_format</a> methods to append small strings. </dd></dl>

</div>
</div>
<a id="a3dc9f3ddffa40df1d58f755211c6b1ac" name="a3dc9f3ddffa40df1d58f755211c6b1ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc9f3ddffa40df1d58f755211c6b1ac">&#9670;&#160;</a></span>append() <span class="overload">[11/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga37e983ceedf5a7f73bc4568eaeae0aa2">xtd::sbyte</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the string representation of a specified 8-bit signed integer value to this instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The 8-bit signed integer value to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> (<a class="el" href="group__types.html#ga37e983ceedf5a7f73bc4568eaeae0aa2" title="Represents a 8-bit signed integer.">xtd::sbyte</a>) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. <div class="fragment"><div class="line"><span class="keyword">auto</span> bytes = <a class="code hl_class" href="classxtd_1_1array.html">array&lt;sbyte&gt;</a> {16, 132, 27, 253};</div>
<div class="line"><span class="keyword">auto</span> sb = <a class="code hl_class" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::string_builder</a> {};</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> value : bytes)</div>
<div class="line">  sb.<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(value).<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(<span class="stringliteral">&quot; &quot;</span>);</div>
<div class="line"><a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The byte array: {0}&quot;</span>, sb.to_string());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The example displays the following output:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The byte array: 16 132 27 253</span></div>
</div><!-- fragment --> </dd>
<dd>
The capacity of this instance is adjusted as needed. </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3c8c9b34721a5dce3830f0e76d94d517" title="Initializes a new instance of the xtd::text::basic_string_builder class that starts with a specified ...">xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size)</a> constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a> property. This can occur particularly when you call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> and <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afdea991b3a89ae01e8c998481fa987d3" title="Appends the string returned by processing a composite format string, which contains zero or more form...">xtd::text::basic_string_builder::append_format</a> methods to append small strings. </dd></dl>

</div>
</div>
<a id="ae86f131b2cd185c31f509e37d2a91e18" name="ae86f131b2cd185c31f509e37d2a91e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae86f131b2cd185c31f509e37d2a91e18">&#9670;&#160;</a></span>append() <span class="overload">[12/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#gad8523b51611f0fac793f78f16b155b21">xtd::uint16</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the string representation of a specified 16-bit unsigned integer value to this instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The 16-bit unsigned value to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> (<a class="el" href="group__types.html#gad8523b51611f0fac793f78f16b155b21" title="Represents a 16-bit unsigned integer.">xtd::uint16</a>) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. <div class="fragment"><div class="line"><span class="keyword">auto</span> value = 1346_u16;</div>
<div class="line"><span class="keyword">auto</span> sb = <a class="code hl_class" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::string_builder</a> {};</div>
<div class="line">sb.<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(<span class="charliteral">&#39;*&#39;</span>, 5).<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(value).<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(<span class="charliteral">&#39;*&#39;</span>, 5);</div>
<div class="line"><a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(sb);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The example displays the following output:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// *****1346*****</span></div>
</div><!-- fragment --> </dd>
<dd>
The capacity of this instance is adjusted as needed. </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3c8c9b34721a5dce3830f0e76d94d517" title="Initializes a new instance of the xtd::text::basic_string_builder class that starts with a specified ...">xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size)</a> constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a> property. This can occur particularly when you call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> and <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afdea991b3a89ae01e8c998481fa987d3" title="Appends the string returned by processing a composite format string, which contains zero or more form...">xtd::text::basic_string_builder::append_format</a> methods to append small strings. </dd></dl>

</div>
</div>
<a id="a6d074c80b3939ba408e9fb552181eec6" name="a6d074c80b3939ba408e9fb552181eec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d074c80b3939ba408e9fb552181eec6">&#9670;&#160;</a></span>append() <span class="overload">[13/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga41c5d8b5d999ac5a2ff06fe57f38d5f5">xtd::uint32</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the string representation of a specified 32-bit unsigned integer value to this instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The 32-bit unsigned value to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> (<a class="el" href="group__types.html#ga41c5d8b5d999ac5a2ff06fe57f38d5f5" title="Represents a 32-bit unsigned integer.">xtd::uint32</a>) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. <div class="fragment"><div class="line"><span class="keyword">auto</span> value = 1346_u32;</div>
<div class="line"><span class="keyword">auto</span> sb = <a class="code hl_class" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::string_builder</a> {};</div>
<div class="line">sb.<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(<span class="charliteral">&#39;*&#39;</span>, 5).<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(value).<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(<span class="charliteral">&#39;*&#39;</span>, 5);</div>
<div class="line"><a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(sb);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The example displays the following output:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// *****1346*****</span></div>
</div><!-- fragment --> </dd>
<dd>
The capacity of this instance is adjusted as needed. </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3c8c9b34721a5dce3830f0e76d94d517" title="Initializes a new instance of the xtd::text::basic_string_builder class that starts with a specified ...">xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size)</a> constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a> property. This can occur particularly when you call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> and <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afdea991b3a89ae01e8c998481fa987d3" title="Appends the string returned by processing a composite format string, which contains zero or more form...">xtd::text::basic_string_builder::append_format</a> methods to append small strings. </dd></dl>

</div>
</div>
<a id="a6b234771b2201b8fbfb1644f7aa531b7" name="a6b234771b2201b8fbfb1644f7aa531b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b234771b2201b8fbfb1644f7aa531b7">&#9670;&#160;</a></span>append() <span class="overload">[14/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#gab5833228ed21371660af349c9b1fe797">xtd::uint64</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the string representation of a specified 64-bit unsigned integer value to this instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The 64-bit unsigned value to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> (<a class="el" href="group__types.html#gab5833228ed21371660af349c9b1fe797" title="Represents a 64-bit unsigned integer.">xtd::uint64</a>) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. <div class="fragment"><div class="line"><span class="keyword">auto</span> value = 1346_u64;</div>
<div class="line"><span class="keyword">auto</span> sb = <a class="code hl_class" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::string_builder</a> {};</div>
<div class="line">sb.<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(<span class="charliteral">&#39;*&#39;</span>, 5).<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(value).<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(<span class="charliteral">&#39;*&#39;</span>, 5);</div>
<div class="line"><a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(sb);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The example displays the following output:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// *****1346*****</span></div>
</div><!-- fragment --> </dd>
<dd>
The capacity of this instance is adjusted as needed. </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3c8c9b34721a5dce3830f0e76d94d517" title="Initializes a new instance of the xtd::text::basic_string_builder class that starts with a specified ...">xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size)</a> constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a> property. This can occur particularly when you call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> and <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afdea991b3a89ae01e8c998481fa987d3" title="Appends the string returned by processing a composite format string, which contains zero or more form...">xtd::text::basic_string_builder::append_format</a> methods to append small strings. </dd></dl>

</div>
</div>
<a id="a54cc64a71cbc139d592a9c0fdf6b05e3" name="a54cc64a71cbc139d592a9c0fdf6b05e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54cc64a71cbc139d592a9c0fdf6b05e3">&#9670;&#160;</a></span>append() <span class="overload">[15/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the string representation of a specified <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc" title="Represents the basic string value type.">xtd::text::basic_string_builder::value_type</a> value to this instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc" title="Represents the basic string value type.">xtd::text::basic_string_builder::value_type</a> value to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc" title="Represents the basic string value type.">xtd::text::basic_string_builder::value_type</a>) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. <div class="fragment"><div class="line"><span class="keyword">auto</span> str = <span class="stringliteral">&quot;Characters in a string.&quot;</span>;</div>
<div class="line"><span class="keyword">auto</span> sb = <a class="code hl_class" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::string_builder</a> {};</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> ch : str)</div>
<div class="line">  sb.<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(<span class="stringliteral">&quot; &#39;&quot;</span>).<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(ch).<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(<span class="stringliteral">&quot;&#39; &quot;</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;Characters in the string:&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;  {}&quot;</span>, sb);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The example displays the following output:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Characters in the string:</span></div>
<div class="line"><span class="comment">//   &#39;C&#39;  &#39;h&#39;  &#39;a&#39;  &#39;r&#39;  &#39;a&#39;  &#39;c&#39;  &#39;t&#39;  &#39;e&#39;  &#39;r&#39;  &#39;s&#39;  &#39; &#39;  &#39;i&#39;  &#39;n&#39;  &#39; &#39;  &#39;a&#39;  &#39; &#39;  &#39;s&#39;  &#39;t&#39; &#39;r&#39;  &#39;i&#39;  &#39;n&#39;  &#39;g&#39;  &#39;.&#39;</span></div>
</div><!-- fragment --> </dd>
<dd>
The capacity of this instance is adjusted as needed. </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3c8c9b34721a5dce3830f0e76d94d517" title="Initializes a new instance of the xtd::text::basic_string_builder class that starts with a specified ...">xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size)</a> constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a> property. This can occur particularly when you call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> and <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afdea991b3a89ae01e8c998481fa987d3" title="Appends the string returned by processing a composite format string, which contains zero or more form...">xtd::text::basic_string_builder::append_format</a> methods to append small strings. </dd></dl>

</div>
</div>
<a id="a50a45a2aeb5cc6bf291cda4785c37bc4" name="a50a45a2aeb5cc6bf291cda4785c37bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a45a2aeb5cc6bf291cda4785c37bc4">&#9670;&#160;</a></span>append() <span class="overload">[16/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>repeat_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a specified number of copies of the string representation of a Unicode character to this instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The character to append. </td></tr>
    <tr><td class="paramname">repeat_count</td><td>The number of times to append <code>value</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc" title="Represents the basic string value type.">xtd::text::basic_string_builder::value_type</a>, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f" title="Represents the basic string size type.">xtd::text::basic_string_builder::size_type</a>) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. <div class="fragment"><div class="line"><span class="keyword">auto</span> value = 1346.19;</div>
<div class="line"><span class="keyword">auto</span> sb = <a class="code hl_class" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::string_builder</a> {};</div>
<div class="line">sb.<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(<span class="charliteral">&#39;*&#39;</span>, 5).<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(value).<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(<span class="charliteral">&#39;*&#39;</span>, 5);</div>
<div class="line"><a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(sb);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The example displays the following output:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// *****1346.19*****</span></div>
</div><!-- fragment --> </dd>
<dd>
The capacity of this instance is adjusted as needed. </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3c8c9b34721a5dce3830f0e76d94d517" title="Initializes a new instance of the xtd::text::basic_string_builder class that starts with a specified ...">xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size)</a> constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a> property. This can occur particularly when you call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> and <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afdea991b3a89ae01e8c998481fa987d3" title="Appends the string returned by processing a composite format string, which contains zero or more form...">xtd::text::basic_string_builder::append_format</a> methods to append small strings. </dd></dl>

</div>
</div>
<a id="a01a81c0e4a6288fe54b854c98ad485b8" name="a01a81c0e4a6288fe54b854c98ad485b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a81c0e4a6288fe54b854c98ad485b8">&#9670;&#160;</a></span>append() <span class="overload">[17/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class object_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::append </td>
          <td>(</td>
          <td class="paramtype">object_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the string representation of a specified object to this instance. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">object_t</td><td>The type of object to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The object to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> (object_t) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. It defines a <code>dog</code> class, creates a <code>dog</code> object, and makes three calls to the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> method to create a string that contains the dog's name and breed. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/text/string_builder&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/istringable&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>dog : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1istringable.html">istringable</a> {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">string</span> dog_breed;</div>
<div class="line">  <span class="keywordtype">string</span> dog_name;</div>
<div class="line">  </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  dog(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; breed) : dog_breed(breed), dog_name(name) {}</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; breed() const noexcept {<span class="keywordflow">return</span> dog_breed;}</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name() const noexcept {<span class="keywordflow">return</span> dog_name;}</div>
<div class="line">  </div>
<div class="line">  <span class="keywordtype">string</span> to_string() const noexcept<span class="keyword"> override </span>{<span class="keywordflow">return</span> dog_name;}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> dog1 = dog {<span class="stringliteral">&quot;Mocka&quot;</span>, <span class="stringliteral">&quot;American Shepherd&quot;</span>};</div>
<div class="line">  <span class="keyword">auto</span> sb = <a class="code hl_class" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::string_builder</a> {};</div>
<div class="line">  sb.<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(dog1).<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(<span class="stringliteral">&quot;, breed: &quot;</span>).<a class="code hl_function" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d">append</a>(dog1.breed());</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(sb);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Mocka, breed: American Shepherd</span></div>
<div class="ttc" id="aclassxtd_1_1istringable_html"><div class="ttname"><a href="classxtd_1_1istringable.html">xtd::istringable</a></div><div class="ttdoc">Provides a way to represent the current object as a string.</div><div class="ttdef"><b>Definition</b> istringable.hpp:23</div></div>
<div class="ttc" id="anamespacextd_html"><div class="ttname"><a href="namespacextd.html">xtd</a></div><div class="ttdoc">The xtd namespace contains all fundamental classes to access Hardware, Os, System,...</div><div class="ttdef"><b>Definition</b> xtd_about_box.hpp:10</div></div>
</div><!-- fragment --> </dd>
<dd>
The capacity of this instance is adjusted as needed. </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3c8c9b34721a5dce3830f0e76d94d517" title="Initializes a new instance of the xtd::text::basic_string_builder class that starts with a specified ...">xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size)</a> constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a> property. This can occur particularly when you call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> and <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afdea991b3a89ae01e8c998481fa987d3" title="Appends the string returned by processing a composite format string, which contains zero or more form...">xtd::text::basic_string_builder::append_format</a> methods to append small strings. </dd></dl>

</div>
</div>
<a id="aff714472cf75a0223adea8f73bc48573" name="aff714472cf75a0223adea8f73bc48573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff714472cf75a0223adea8f73bc48573">&#9670;&#160;</a></span>append() <span class="overload">[18/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of characters to append. </td></tr>
    <tr><td class="paramname">ch</td><td>The character value to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Appends <code>count</code> copies of character <code>ch</code>. </dd>
<dd>
The capacity of this instance is adjusted as needed. </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3c8c9b34721a5dce3830f0e76d94d517" title="Initializes a new instance of the xtd::text::basic_string_builder class that starts with a specified ...">xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size)</a> constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a> property. This can occur particularly when you call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> and <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afdea991b3a89ae01e8c998481fa987d3" title="Appends the string returned by processing a composite format string, which contains zero or more form...">xtd::text::basic_string_builder::append_format</a> methods to append small strings. </dd></dl>

</div>
</div>
<a id="a597a810e2423dbc847e86d163394e386" name="a597a810e2423dbc847e86d163394e386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a597a810e2423dbc847e86d163394e386">&#9670;&#160;</a></span>append() <span class="overload">[19/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Appends string <code>str</code>. </dd>
<dd>
The capacity of this instance is adjusted as needed. </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3c8c9b34721a5dce3830f0e76d94d517" title="Initializes a new instance of the xtd::text::basic_string_builder class that starts with a specified ...">xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size)</a> constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a> property. This can occur particularly when you call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> and <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afdea991b3a89ae01e8c998481fa987d3" title="Appends the string returned by processing a composite format string, which contains zero or more form...">xtd::text::basic_string_builder::append_format</a> methods to append small strings. </dd></dl>

</div>
</div>
<a id="a126d93539fcf8d3d17c9f883d960828a" name="a126d93539fcf8d3d17c9f883d960828a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a126d93539fcf8d3d17c9f883d960828a">&#9670;&#160;</a></span>append() <span class="overload">[20/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to append. </td></tr>
    <tr><td class="paramname">pos</td><td>The index of the first character to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Appends a substring [<code>pos</code>, <code>pos</code> + <code>count</code>) of <code>str</code>. </dd>
<dd>
If the requested substring lasts past the end of the string, or if <code>count == npos</code>, the appended substring is [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). </dd>
<dd>
If <code>pos &gt; str.size()</code>, <code>std::out_of_range</code> is thrown. </dd>
<dd>
The capacity of this instance is adjusted as needed. </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3c8c9b34721a5dce3830f0e76d94d517" title="Initializes a new instance of the xtd::text::basic_string_builder class that starts with a specified ...">xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size)</a> constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a> property. This can occur particularly when you call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> and <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afdea991b3a89ae01e8c998481fa987d3" title="Appends the string returned by processing a composite format string, which contains zero or more form...">xtd::text::basic_string_builder::append_format</a> methods to append small strings. </dd></dl>

</div>
</div>
<a id="a2279334b8f5bce4bc235485e683adf7f" name="a2279334b8f5bce4bc235485e683adf7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2279334b8f5bce4bc235485e683adf7f">&#9670;&#160;</a></span>append() <span class="overload">[21/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to append. </td></tr>
    <tr><td class="paramname">pos</td><td>The index of the first character to append. </td></tr>
    <tr><td class="paramname">count</td><td>The number of characters to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Appends a substring [<code>pos</code>, <code>pos</code> + <code>count</code>) of <code>str</code>. </dd>
<dd>
If the requested substring lasts past the end of the string, or if <code>count == npos</code>, the appended substring is [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). </dd>
<dd>
If <code>pos &gt; str.size()</code>, <code>std::out_of_range</code> is thrown. </dd>
<dd>
The capacity of this instance is adjusted as needed. </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3c8c9b34721a5dce3830f0e76d94d517" title="Initializes a new instance of the xtd::text::basic_string_builder class that starts with a specified ...">xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size)</a> constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a> property. This can occur particularly when you call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> and <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afdea991b3a89ae01e8c998481fa987d3" title="Appends the string returned by processing a composite format string, which contains zero or more form...">xtd::text::basic_string_builder::append_format</a> methods to append small strings. </dd></dl>

</div>
</div>
<a id="a1faae533546f74f439cc3c6fd6eb6747" name="a1faae533546f74f439cc3c6fd6eb6747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1faae533546f74f439cc3c6fd6eb6747">&#9670;&#160;</a></span>append() <span class="overload">[22/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to the character string to append. </td></tr>
    <tr><td class="paramname">count</td><td>The number of characters to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Appends characters in the range [<code>s</code>, <code>s + count</code>). This range can contain null characters. </dd>
<dd>
If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd>
<dd>
The capacity of this instance is adjusted as needed. </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3c8c9b34721a5dce3830f0e76d94d517" title="Initializes a new instance of the xtd::text::basic_string_builder class that starts with a specified ...">xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size)</a> constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a> property. This can occur particularly when you call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> and <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afdea991b3a89ae01e8c998481fa987d3" title="Appends the string returned by processing a composite format string, which contains zero or more form...">xtd::text::basic_string_builder::append_format</a> methods to append small strings. </dd></dl>

</div>
</div>
<a id="a7eb64cb2156c53cafb1a1f44176a6c54" name="a7eb64cb2156c53cafb1a1f44176a6c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eb64cb2156c53cafb1a1f44176a6c54">&#9670;&#160;</a></span>append() <span class="overload">[23/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to the character string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Appends the null-terminated character string pointed to by <code>s</code>, as if by <code>append(s, traits_t::length(s))</code>. </dd>
<dd>
The capacity of this instance is adjusted as needed. </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3c8c9b34721a5dce3830f0e76d94d517" title="Initializes a new instance of the xtd::text::basic_string_builder class that starts with a specified ...">xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size)</a> constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a> property. This can occur particularly when you call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> and <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afdea991b3a89ae01e8c998481fa987d3" title="Appends the string returned by processing a composite format string, which contains zero or more form...">xtd::text::basic_string_builder::append_format</a> methods to append small strings. </dd></dl>

</div>
</div>
<a id="a6198aa2543faceea31519407dc22dd72" name="a6198aa2543faceea31519407dc22dd72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6198aa2543faceea31519407dc22dd72">&#9670;&#160;</a></span>append() <span class="overload">[24/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::append </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator of the range of characters to append. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator of the range of characters to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Appends characters in the range [<code>first</code>, <code>last</code>). </dd>
<dd>
This overload only participates in overload resolution if <code>input_iterator_t</code> qualifies as a <a href="https://en.cppreference.com/w/cpp/named_req/InputIterator">LegacyInputIterator</a>. </dd>
<dd>
The capacity of this instance is adjusted as needed. </dd></dl>

</div>
</div>
<a id="a7d6267fe16a67d3534248d92508d1f9a" name="a7d6267fe16a67d3534248d92508d1f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6267fe16a67d3534248d92508d1f9a">&#9670;&#160;</a></span>append() <span class="overload">[25/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::append </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>The initializer list with the characters to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Appends characters from the initializer list <code>ilist</code>. </dd>
<dd>
The capacity of this instance is adjusted as needed. </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3c8c9b34721a5dce3830f0e76d94d517" title="Initializes a new instance of the xtd::text::basic_string_builder class that starts with a specified ...">xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size)</a> constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a> property. This can occur particularly when you call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> and <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afdea991b3a89ae01e8c998481fa987d3" title="Appends the string returned by processing a composite format string, which contains zero or more form...">xtd::text::basic_string_builder::append_format</a> methods to append small strings. </dd></dl>

</div>
</div>
<a id="afdea991b3a89ae01e8c998481fa987d3" name="afdea991b3a89ae01e8c998481fa987d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdea991b3a89ae01e8c998481fa987d3">&#9670;&#160;</a></span>append_format()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ... args_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::append_format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">args_t &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance. Each format item is replaced by the string representation of a corresponding argument in a parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...args_t</td><td>Types of the values to format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>A composite format string. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance with format appended. Each format item in format is replaced by the string representation of the corresponding object argument. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1format__exception.html" title="The exception that is thrown when the format of an argument does not meet the parameter specification...">xtd::format_exception</a></td><td>`format` is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method uses the composite formatting feature of the xtd framework to convert the value of an object to its text representation and embed that representation in the current <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object. </dd>
<dd>
The <code>format</code> parameter consists of optional zero or more runs of text intermixed with zero or more indexed placeholders, called format items, that correspond to objects in the parameter list of this method. The formatting process replaces each format item with the string representation of the corresponding object. </dd>
<dd>
The syntax of a format item is as follows: <code>{[index][,length][:format_string]}</code> </dd>
<dd>
Elements in square brackets are optional. The following table describes each element. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Element   </th><th class="markdownTableHeadNone">Â Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">index   </td><td class="markdownTableBodyNone">The optional zero-based position in the parameter list of the object to be formatted. If there is no parameter in the index position, a <a class="el" href="classxtd_1_1format__exception.html" title="The exception that is thrown when the format of an argument does not meet the parameter specification...">xtd::format_exception</a> is thrown.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">length   </td><td class="markdownTableBodyNone">The minimum number of characters in the string representation of the parameter. If positive, the parameter is right-aligned; if negative, it is left-aligned.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">:format_string   </td><td class="markdownTableBodyNone">A standard or custom format string that is supported by the parameter.   </td></tr>
</table>
</dd>
<dd>
The capacity of this instance is adjusted as needed. </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3c8c9b34721a5dce3830f0e76d94d517" title="Initializes a new instance of the xtd::text::basic_string_builder class that starts with a specified ...">xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size)</a> constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a> property. This can occur particularly when you call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> and <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afdea991b3a89ae01e8c998481fa987d3" title="Appends the string returned by processing a composite format string, which contains zero or more form...">xtd::text::basic_string_builder::append_format</a> methods to append small strings. </dd></dl>

</div>
</div>
<a id="aacb8078255c5b4308703ec56e604b447" name="aacb8078255c5b4308703ec56e604b447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb8078255c5b4308703ec56e604b447">&#9670;&#160;</a></span>append_join() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::append_join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates and appends the members of a collection, using the specified separator between each member. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>The string to use as a separator. <code>separator</code> is included in the concatenated and appended strings only if <code>values</code> has more than one element. </td></tr>
    <tr><td class="paramname">values</td><td>A collection that contains the objects to concatenate and append to the current instance of the string builder. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The capacity of this instance is adjusted as needed. </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3c8c9b34721a5dce3830f0e76d94d517" title="Initializes a new instance of the xtd::text::basic_string_builder class that starts with a specified ...">xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size)</a> constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a> property. This can occur particularly when you call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> and <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afdea991b3a89ae01e8c998481fa987d3" title="Appends the string returned by processing a composite format string, which contains zero or more form...">xtd::text::basic_string_builder::append_format</a> methods to append small strings. </dd></dl>

</div>
</div>
<a id="a7f3028a3e141c23684354b44777e3ff8" name="a7f3028a3e141c23684354b44777e3ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3028a3e141c23684354b44777e3ff8">&#9670;&#160;</a></span>append_join() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::append_join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates and appends the members of a collection, using the specified xtd::basic_string_builder::value_type separator between each member. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>The xtd::basic_string_builder::value_type to use as a separator. <code>separator</code> is included in the concatenated and appended strings only if <code>values</code> has more than one element. </td></tr>
    <tr><td class="paramname">values</td><td>A collection that contains the objects to concatenate and append to the current instance of the string builder. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The capacity of this instance is adjusted as needed. </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3c8c9b34721a5dce3830f0e76d94d517" title="Initializes a new instance of the xtd::text::basic_string_builder class that starts with a specified ...">xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size)</a> constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a> property. This can occur particularly when you call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> and <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afdea991b3a89ae01e8c998481fa987d3" title="Appends the string returned by processing a composite format string, which contains zero or more form...">xtd::text::basic_string_builder::append_format</a> methods to append small strings. </dd></dl>

</div>
</div>
<a id="ad848c2e409fe2fcaaa4f1066c3faa655" name="ad848c2e409fe2fcaaa4f1066c3faa655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad848c2e409fe2fcaaa4f1066c3faa655">&#9670;&#160;</a></span>append_line() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::append_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the default line terminator to the end of the current <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The capacity of this instance is adjusted as needed. </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3c8c9b34721a5dce3830f0e76d94d517" title="Initializes a new instance of the xtd::text::basic_string_builder class that starts with a specified ...">xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size)</a> constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a> property. This can occur particularly when you call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> and <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afdea991b3a89ae01e8c998481fa987d3" title="Appends the string returned by processing a composite format string, which contains zero or more form...">xtd::text::basic_string_builder::append_format</a> methods to append small strings. </dd></dl>

</div>
</div>
<a id="a34fedf9b31b7064396a6e1b8162cd6b9" name="a34fedf9b31b7064396a6e1b8162cd6b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34fedf9b31b7064396a6e1b8162cd6b9">&#9670;&#160;</a></span>append_line() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::append_line </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a copy of the specified string followed by the default line terminator to the end of the current <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The capacity of this instance is adjusted as needed. </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a3c8c9b34721a5dce3830f0e76d94d517" title="Initializes a new instance of the xtd::text::basic_string_builder class that starts with a specified ...">xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size)</a> constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a> property. This can occur particularly when you call the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a74b530fbbad4b6b67da525a5b401219d" title="Appends a copy of the specified string to this instance.">xtd::text::basic_string_builder::append</a> and <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afdea991b3a89ae01e8c998481fa987d3" title="Appends the string returned by processing a composite format string, which contains zero or more form...">xtd::text::basic_string_builder::append_format</a> methods to append small strings. </dd></dl>

</div>
</div>
<a id="a4874895a2538a2e3e197128c6d3ec0b1" name="a4874895a2538a2e3e197128c6d3ec0b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4874895a2538a2e3e197128c6d3ec0b1">&#9670;&#160;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a7a9fff0c8a14fc2115fe86547402e0b4">const_reference</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the character at specified location <code>pos</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested character. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>If `index` is not within the range of the string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70b9ffd98bb38650acf1485acce992bc" name="a70b9ffd98bb38650acf1485acce992bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b9ffd98bb38650acf1485acce992bc">&#9670;&#160;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a9b9b46ae1d66c7d5c9ac716899c0be58">reference</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the character at specified location <code>pos</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested character. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>If `index` is not within the range of the string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a889d0621a11daabdcfd36f0b15f5a8ad" name="a889d0621a11daabdcfd36f0b15f5a8ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a889d0621a11daabdcfd36f0b15f5a8ad">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all characters from the current <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance. </p>
<dl class="section return"><dt>Returns</dt><dd>An object whose <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a69a83b009389b1b5706ce202a2989afd" title="Gets or sets the length of the current xtd::text::basic_string_builder object.">xtd::text::basic_string_builder::length</a> is 0 (zero). </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a889d0621a11daabdcfd36f0b15f5a8ad" title="Removes all characters from the current xtd::text::basic_string_builder instance.">xtd::text::basic_string_builder::clear</a> is a convenience method that is equivalent to setting the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a69a83b009389b1b5706ce202a2989afd" title="Gets or sets the length of the current xtd::text::basic_string_builder object.">xtd::text::basic_string_builder::length</a> property of the current instance to 0 (zero). </dd>
<dd>
All pointers, references, and iterators are invalidated. </dd></dl>

</div>
</div>
<a id="adcb3c07e3514242c5441eac7bead3d70" name="adcb3c07e3514242c5441eac7bead3d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcb3c07e3514242c5441eac7bead3d70">&#9670;&#160;</a></span>compare() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two character sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The other string to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order.</li>
<li>Zero if both character sequences compare equivalent.</li>
<li>Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares this string to str. </dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows:<ul>
<li>First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>.</li>
<li>Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: </li>
</ul>
</dd>
<dd>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Condition   </th><th class="markdownTableHeadNone">Result   </th><th class="markdownTableHeadNone">Return value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &lt; 0   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 == size2   </td><td class="markdownTableBodyNone">data1 is <b>equal to</b> data2   </td><td class="markdownTableBodyNone">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &gt; 0   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="ac602163d39c8c3cdb6b409f1fde49c7f" name="ac602163d39c8c3cdb6b409f1fde49c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac602163d39c8c3cdb6b409f1fde49c7f">&#9670;&#160;</a></span>compare() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two character sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The position of the first character in this string to compare. </td></tr>
    <tr><td class="paramname">count1</td><td>The number of characters of this string to compare. </td></tr>
    <tr><td class="paramname">str</td><td>The other string to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order.</li>
<li>Zero if both character sequences compare equivalent.</li>
<li>Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares a [<code>pos1</code>, <code>pos1 + count1</code>) substring of this string to <code>str</code>.<ul>
<li>If <code>count1 &gt; <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a> - pos1</code>, the substring is [<code>pos1</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). </li>
</ul>
</dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows:<ul>
<li>First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>.</li>
<li>Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: </li>
</ul>
</dd>
<dd>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Condition   </th><th class="markdownTableHeadNone">Result   </th><th class="markdownTableHeadNone">Return value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &lt; 0   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 == size2   </td><td class="markdownTableBodyNone">data1 is <b>equal to</b> data2   </td><td class="markdownTableBodyNone">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &gt; 0   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a935248e98bf33fdfcc1fae68d198a2f1" name="a935248e98bf33fdfcc1fae68d198a2f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935248e98bf33fdfcc1fae68d198a2f1">&#9670;&#160;</a></span>compare() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two character sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The position of the first character in this string to compare. </td></tr>
    <tr><td class="paramname">count1</td><td>The number of characters of this string to compare. </td></tr>
    <tr><td class="paramname">str</td><td>The other string to compare to. </td></tr>
    <tr><td class="paramname">pos2</td><td>The position of the first character of the given string to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order.</li>
<li>Zero if both character sequences compare equivalent.</li>
<li>Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares a [<code>pos1</code>, <code>pos1 + count1</code>) substring of this string to a substring [<code>pos2</code>, <code>pos2 + count2</code>) of <code>str</code>.<ul>
<li>If <code>count1 &gt; <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a> - pos1</code>, the first substring is [<code>pos1</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>).</li>
<li>If <code>count2 &gt; str.size() - pos2</code>, the second substring is [<code>pos2</code>, <code>str.size()</code>). </li>
</ul>
</dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows:<ul>
<li>First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>.</li>
<li>Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: </li>
</ul>
</dd>
<dd>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Condition   </th><th class="markdownTableHeadNone">Result   </th><th class="markdownTableHeadNone">Return value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &lt; 0   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 == size2   </td><td class="markdownTableBodyNone">data1 is <b>equal to</b> data2   </td><td class="markdownTableBodyNone">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &gt; 0   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="afb00b052cf70d3ee4df156ed4707e841" name="afb00b052cf70d3ee4df156ed4707e841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb00b052cf70d3ee4df156ed4707e841">&#9670;&#160;</a></span>compare() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two character sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The position of the first character in this string to compare. </td></tr>
    <tr><td class="paramname">count1</td><td>The number of characters of this string to compare. </td></tr>
    <tr><td class="paramname">str</td><td>The other string to compare to. </td></tr>
    <tr><td class="paramname">pos2</td><td>The position of the first character of the given string to compare. </td></tr>
    <tr><td class="paramname">count2</td><td>The number of characters of the given string to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the value parameter:<ul>
<li>Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order.</li>
<li>Zero if both character sequences compare equivalent.</li>
<li>Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares a [<code>pos1</code>, <code>pos1 + count1</code>) substring of this string to a substring [<code>pos2</code>, <code>pos2 + count2</code>) of <code>str</code>.<ul>
<li>If <code>count1 &gt; <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a> - pos1</code>, the first substring is [<code>pos1</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>).</li>
<li>If <code>count2 &gt; str.size() - pos2</code>, the second substring is [<code>pos2</code>, <code>str.size()</code>). </li>
</ul>
</dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows:<ul>
<li>First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>.</li>
<li>Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: </li>
</ul>
</dd>
<dd>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Condition   </th><th class="markdownTableHeadNone">Result   </th><th class="markdownTableHeadNone">Return value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &lt; 0   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 == size2   </td><td class="markdownTableBodyNone">data1 is <b>equal to</b> data2   </td><td class="markdownTableBodyNone">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &gt; 0   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a1a4e44756cc5852ef2a75ed7e4763f9c" name="a1a4e44756cc5852ef2a75ed7e4763f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4e44756cc5852ef2a75ed7e4763f9c">&#9670;&#160;</a></span>compare() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two character sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to the character string to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order.</li>
<li>Zero if both character sequences compare equivalent.</li>
<li>Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares this string to the null-terminated character sequence beginning at the character pointed to by <code>s</code> with length <code>traits_t::length(s)</code>. </dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows:<ul>
<li>First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>.</li>
<li>Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: </li>
</ul>
</dd>
<dd>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Condition   </th><th class="markdownTableHeadNone">Result   </th><th class="markdownTableHeadNone">Return value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &lt; 0   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 == size2   </td><td class="markdownTableBodyNone">data1 is <b>equal to</b> data2   </td><td class="markdownTableBodyNone">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &gt; 0   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a7e43fb14da06fe4c8abdfb096538347c" name="a7e43fb14da06fe4c8abdfb096538347c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e43fb14da06fe4c8abdfb096538347c">&#9670;&#160;</a></span>compare() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two character sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The position of the first character in this string to compare. </td></tr>
    <tr><td class="paramname">count1</td><td>The number of characters of this string to compare. </td></tr>
    <tr><td class="paramname">s</td><td>pointer to the character string to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order.</li>
<li>Zero if both character sequences compare equivalent.</li>
<li>Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares a [<code>pos1</code>, <code>pos1 + count1</code>) substring of this string to the null-terminated character sequence beginning at the character pointed to by <code>s</code> with length <code>traits_t::length(s)</code>.<ul>
<li>If <code>count1 &gt; <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a> - pos1</code>, the substring is [<code>pos1$ , <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). @remarks A character sequence consisting of</code>count1<code>characters starting at</code>data1<code>is compared to a character sequence consisting of</code>count2<code>characters starting at</code>data2<code>as follows:</code></li>
<li><code>First, calculate the number of characters to compare, as if by</code>size_type rlen = std::min(count1, count2)<code>.</code></li>
<li><code>Then compare the sequences by calling</code>traits_t::compare(data1, data2, rlen)`. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: </li>
</ul>
</dd>
<dd>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Condition   </th><th class="markdownTableHeadNone">Result   </th><th class="markdownTableHeadNone">Return value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &lt; 0   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 == size2   </td><td class="markdownTableBodyNone">data1 is <b>equal to</b> data2   </td><td class="markdownTableBodyNone">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &gt; 0   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="aa32da0105edfb4de7d7a4e03702bdd01" name="aa32da0105edfb4de7d7a4e03702bdd01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa32da0105edfb4de7d7a4e03702bdd01">&#9670;&#160;</a></span>compare() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two character sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The position of the first character in this string to compare. </td></tr>
    <tr><td class="paramname">count1</td><td>The number of characters of this string to compare. </td></tr>
    <tr><td class="paramname">s</td><td>pointer to the character string to compare to. </td></tr>
    <tr><td class="paramname">count2</td><td>The number of characters of the given string to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order.</li>
<li>Zero if both character sequences compare equivalent.</li>
<li>Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares a [<code>pos1</code>, <code>pos1 + count1</code>) substring of this string to the characters in the range [<code>s</code>, <code>s + count2</code>). The characters in [<code>s</code>, <code>s + count2</code>) may include null characters.<ul>
<li>If <code>count1 &gt; <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a> - pos1</code>, the substring is [<code>pos1</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). </li>
</ul>
</dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows:<ul>
<li>First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>.</li>
<li>Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: </li>
</ul>
</dd>
<dd>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Condition   </th><th class="markdownTableHeadNone">Result   </th><th class="markdownTableHeadNone">Return value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &lt; 0   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 == size2   </td><td class="markdownTableBodyNone">data1 is <b>equal to</b> data2   </td><td class="markdownTableBodyNone">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &gt; 0   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="ae0daf0e5823acccf7dc869e1e542d7e4" name="ae0daf0e5823acccf7dc869e1e542d7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0daf0e5823acccf7dc869e1e542d7e4">&#9670;&#160;</a></span>copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aa62aee9e769ee262f5deae94ff8ea03d">pointer</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a substring [<code>pos</code>, <code>pos + count</code>) to character string pointed to by <code>dest</code>. If the requested substring lasts past the end of the string, or if <code>count == npos</code>, the copied substring is [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The pointer to the destination character string. </td></tr>
    <tr><td class="paramname">count</td><td>length of the substring. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters copied. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The resulting character string is not null-terminated. </dd></dl>

</div>
</div>
<a id="a68eec80ec1a4223dc129301eb889e6a4" name="a68eec80ec1a4223dc129301eb889e6a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68eec80ec1a4223dc129301eb889e6a4">&#9670;&#160;</a></span>copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aa62aee9e769ee262f5deae94ff8ea03d">pointer</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a substring [<code>pos</code>, <code>pos + count</code>) to character string pointed to by <code>dest</code>. If the requested substring lasts past the end of the string, or if <code>count == npos</code>, the copied substring is [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The pointer to the destination character string. </td></tr>
    <tr><td class="paramname">count</td><td>length of the substring. </td></tr>
    <tr><td class="paramname">pos</td><td>The position of the first character to include. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters copied. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The resulting character string is not null-terminated. </dd></dl>

</div>
</div>
<a id="ab371da2a717b123bae6b1d802ef8493c" name="ab371da2a717b123bae6b1d802ef8493c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab371da2a717b123bae6b1d802ef8493c">&#9670;&#160;</a></span>copy_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::copy_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>source_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>destination_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>destination_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the characters from a specified segment of this instance to a specified segment of a destination <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc" title="Represents the basic string value type.">xtd::text::basic_string_builder::value_type</a> array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_index</td><td>The starting position in this instance where characters will be copied from. The index is zero-based. </td></tr>
    <tr><td class="paramname">destination</td><td>The array where characters will be copied. </td></tr>
    <tr><td class="paramname">destination_index</td><td>The starting position in destination where characters will be copied. The index is zero-based. </td></tr>
    <tr><td class="paramname">destination_count</td><td>The number of characters to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`source_index` is greater than length <br  />
-or-<br  />
`destination_index` + 'destination_count' greater than destination size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ab371da2a717b123bae6b1d802ef8493c" title="Copies the characters from a specified segment of this instance to a specified segment of a destinati...">xtd::text::basic_string_builder::copy_to</a> method is intended to be used in the rare situation when you need to efficiently copy successive sections of a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object to an array. The array should be a fixed size, preallocated, reusable, and possibly globally accessible. </dd>
<dd>
For example, your code could populate a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object with a large number of characters then use the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ab371da2a717b123bae6b1d802ef8493c" title="Copies the characters from a specified segment of this instance to a specified segment of a destinati...">xtd::text::basic_string_builder::copy_to</a> method to copy small, successive pieces of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object to an array where the pieces are processed. When all the data in the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object is processed, the size of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object is set to zero and the cycle is repeated. </dd></dl>

</div>
</div>
<a id="af96c2ac833670b1180ac068212ad9f4f" name="af96c2ac833670b1180ac068212ad9f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af96c2ac833670b1180ac068212ad9f4f">&#9670;&#160;</a></span>equals() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1object.html">object</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this instance and a specified object, which must also be a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, have the same value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a> to compare to this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>obj</code> is a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> and its value is the same as this instance; otherwise, <code>false</code>. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1object.html#a2743b6f75405882c28eebe2456f3837b">xtd::object</a>.</p>

</div>
</div>
<a id="a0d34f9d4cd8a741fe9db2eee6c5aefd5" name="a0d34f9d4cd8a741fe9db2eee6c5aefd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d34f9d4cd8a741fe9db2eee6c5aefd5">&#9670;&#160;</a></span>equals() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this instance and another specified <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object have the same value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a> to compare to this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <code>value</code> of the value parameter is the same as the value of this instance; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method performs an ordinal (case-sensitive) comparison. </dd></dl>

</div>
</div>
<a id="abbeb4cc1cfd200606618eb6739608942" name="abbeb4cc1cfd200606618eb6739608942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbeb4cc1cfd200606618eb6739608942">&#9670;&#160;</a></span>ensure_capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::ensure_capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that the capacity of this instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is at least the specified value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The minimum capacity to ensure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new capacity of this instance. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed Enlarging the value of this instance would exceed MaxCapacity.<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the current capacity is less than the <code>capacity</code> parameter, memory for this instance is reallocated to hold at least <code>capacity</code> number of characters; otherwise, no memory is changed. </dd></dl>

</div>
</div>
<a id="a5b5c9fcc11b456758adcff89a37db3d6" name="a5b5c9fcc11b456758adcff89a37db3d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b5c9fcc11b456758adcff89a37db3d6">&#9670;&#160;</a></span>erase() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::erase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes specified characters from the string. </p>
<dl class="section return"><dt>Returns</dt><dd>This current instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Removes <code>std::min(count, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a> - index)</code> characters starting at index. </dd></dl>

</div>
</div>
<a id="aa98036eb33b9f5efccea8f3ab0c4260d" name="aa98036eb33b9f5efccea8f3ab0c4260d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa98036eb33b9f5efccea8f3ab0c4260d">&#9670;&#160;</a></span>erase() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes specified characters from the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The first character to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Removes <code>std::min(count, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a> - index)</code> characters starting at index. </dd></dl>

</div>
</div>
<a id="aba63b5048abc857d0ef9fec7202868e2" name="aba63b5048abc857d0ef9fec7202868e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba63b5048abc857d0ef9fec7202868e2">&#9670;&#160;</a></span>erase() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes specified characters from the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The first character to remove. </td></tr>
    <tr><td class="paramname">count</td><td>The number of characters to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Removes <code>std::min(count, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a> - index)</code> characters starting at index. </dd></dl>

</div>
</div>
<a id="a0b4a2cd3ac7315702ee353559ca0a826" name="a0b4a2cd3ac7315702ee353559ca0a826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b4a2cd3ac7315702ee353559ca0a826">&#9670;&#160;</a></span>erase() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aae7df40d1cb269bbcdd170dde0f5dc20">iterator</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes specified characters from the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The iterator to the character to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Iterator pointing to the character immediately following the character erased, or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a32e986bfe09f3fef3a459b2a7a7b866b" title="Returns an iterator to the character following the last character of the string. This character acts ...">end()</a> if no such character exists. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Removes the character at <code>position</code>. </dd>
<dd>
If <code>position</code> is not a dereferenceable iterator on <code>*this</code>, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a43cc268cc3bbc170e27fb9890960ecfd" name="a43cc268cc3bbc170e27fb9890960ecfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43cc268cc3bbc170e27fb9890960ecfd">&#9670;&#160;</a></span>erase() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aae7df40d1cb269bbcdd170dde0f5dc20">iterator</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes specified characters from the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator of the range of the characters to remove. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator of the range of the characters to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator pointing to the character last pointed to before the erase, or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a32e986bfe09f3fef3a459b2a7a7b866b" title="Returns an iterator to the character following the last character of the string. This character acts ...">end()</a> if no such character exists. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Removes the characters in the range [<code>first</code>, <code>last</code>). </dd>
<dd>
If <code>first</code> or <code>last</code> is not a valid iterator on <code>*this</code>, or [<code>first</code>, <code>last</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="addd010f465e21bfe02a37a72327fcb8b" name="addd010f465e21bfe02a37a72327fcb8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd010f465e21bfe02a37a72327fcb8b">&#9670;&#160;</a></span>find() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to <code>str</code>. </dd></dl>

</div>
</div>
<a id="aca4056d79afbf4cd7427b088ff37fd73" name="aca4056d79afbf4cd7427b088ff37fd73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4056d79afbf4cd7427b088ff37fd73">&#9670;&#160;</a></span>find() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to <code>str</code>. </dd></dl>

</div>
</div>
<a id="a871f4dcc9e986d3391773e94001d4424" name="a871f4dcc9e986d3391773e94001d4424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871f4dcc9e986d3391773e94001d4424">&#9670;&#160;</a></span>find() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
    <tr><td class="paramname">count</td><td>The length of substring to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to the range [s, s + count). </dd>
<dd>
This range may contain null characters. If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="aa516a25b121ca140f4e32b25686ee448" name="aa516a25b121ca140f4e32b25686ee448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa516a25b121ca140f4e32b25686ee448">&#9670;&#160;</a></span>find() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to the character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a375a366e73b0bb4a472a54e55b7820b5" name="a375a366e73b0bb4a472a54e55b7820b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a375a366e73b0bb4a472a54e55b7820b5">&#9670;&#160;</a></span>find() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to the character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a1dde10776af5e4236d17f723f5e16272" name="a1dde10776af5e4236d17f723f5e16272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dde10776af5e4236d17f723f5e16272">&#9670;&#160;</a></span>find() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character <code>ch</code> (treated as a single-character substring by the formal rules below). </dd></dl>

</div>
</div>
<a id="acdb87f140c3fb2c99c9213e41bdf6c7a" name="acdb87f140c3fb2c99c9213e41bdf6c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb87f140c3fb2c99c9213e41bdf6c7a">&#9670;&#160;</a></span>find() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character <code>ch</code> (treated as a single-character substring by the formal rules below). </dd></dl>

</div>
</div>
<a id="a1193f4f61458f636924c8c12e37c389e" name="a1193f4f61458f636924c8c12e37c389e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1193f4f61458f636924c8c12e37c389e">&#9670;&#160;</a></span>find_first_of() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="a01193dda07e43b164b2162867e8af66e" name="a01193dda07e43b164b2162867e8af66e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01193dda07e43b164b2162867e8af66e">&#9670;&#160;</a></span>find_first_of() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="a5f4930ea45a844d0194dc6becc05f910" name="a5f4930ea45a844d0194dc6becc05f910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f4930ea45a844d0194dc6becc05f910">&#9670;&#160;</a></span>find_first_of() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
    <tr><td class="paramname">count</td><td>The length of character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in the range [<code>s</code>, <code>s + count</code>). This range can include null characters. </dd>
<dd>
If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a0f6486e9aa4f41fd50996a84103e643f" name="a0f6486e9aa4f41fd50996a84103e643f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6486e9aa4f41fd50996a84103e643f">&#9670;&#160;</a></span>find_first_of() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a5822b12952b2e94f633ed23864a033b1" name="a5822b12952b2e94f633ed23864a033b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5822b12952b2e94f633ed23864a033b1">&#9670;&#160;</a></span>find_first_of() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a173cc774d0d51ce3b178e057384bd785" name="a173cc774d0d51ce3b178e057384bd785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173cc774d0d51ce3b178e057384bd785">&#9670;&#160;</a></span>find_first_of() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a021c75422a879b861ed2e6d70a87056d" name="a021c75422a879b861ed2e6d70a87056d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a021c75422a879b861ed2e6d70a87056d">&#9670;&#160;</a></span>find_first_of() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a782483099e1899cde8dcdd99d33874a8" name="a782483099e1899cde8dcdd99d33874a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782483099e1899cde8dcdd99d33874a8">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="a64ea74d485358c59e05a8a4c166b9d57" name="a64ea74d485358c59e05a8a4c166b9d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ea74d485358c59e05a8a4c166b9d57">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="acd3c984bc0ecb97d0b7b043aef7e342c" name="acd3c984bc0ecb97d0b7b043aef7e342c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd3c984bc0ecb97d0b7b043aef7e342c">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
    <tr><td class="paramname">count</td><td>The length of character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in the range [<code>s</code>, <code>s + count</code>). This range can include null characters. </dd>
<dd>
If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a59823a9dd0e8f7198911cb405d1fd5d9" name="a59823a9dd0e8f7198911cb405d1fd5d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59823a9dd0e8f7198911cb405d1fd5d9">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a59b3ddb2b4b520bbb17977b9aa40abdd" name="a59b3ddb2b4b520bbb17977b9aa40abdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b3ddb2b4b520bbb17977b9aa40abdd">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a341d07800aea00111e68dc05f9e53b25" name="a341d07800aea00111e68dc05f9e53b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a341d07800aea00111e68dc05f9e53b25">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a253195d4dd86e68c524904601b299455" name="a253195d4dd86e68c524904601b299455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253195d4dd86e68c524904601b299455">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a14020567dcd6804b6cdcb44195921e08" name="a14020567dcd6804b6cdcb44195921e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14020567dcd6804b6cdcb44195921e08">&#9670;&#160;</a></span>find_last_of() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="a695e88d8d0a58a53f73959164c6d6880" name="a695e88d8d0a58a53f73959164c6d6880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a695e88d8d0a58a53f73959164c6d6880">&#9670;&#160;</a></span>find_last_of() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="af4c85187149a417bd2f31d6a22acf2ce" name="af4c85187149a417bd2f31d6a22acf2ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c85187149a417bd2f31d6a22acf2ce">&#9670;&#160;</a></span>find_last_of() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
    <tr><td class="paramname">count</td><td>The length of character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in the range [<code>s</code>, <code>s + count</code>). This range can include null characters. </dd>
<dd>
If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a448a629104e7ce594fd1a23aa00c6626" name="a448a629104e7ce594fd1a23aa00c6626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448a629104e7ce594fd1a23aa00c6626">&#9670;&#160;</a></span>find_last_of() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a5f81f8edf0cf5a8ca3e544026074ef68" name="a5f81f8edf0cf5a8ca3e544026074ef68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f81f8edf0cf5a8ca3e544026074ef68">&#9670;&#160;</a></span>find_last_of() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a3b96875455b6f3b0f2d1142ffbbacd25" name="a3b96875455b6f3b0f2d1142ffbbacd25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b96875455b6f3b0f2d1142ffbbacd25">&#9670;&#160;</a></span>find_last_of() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="af81c01bf59e08e245516c40ebc2ee842" name="af81c01bf59e08e245516c40ebc2ee842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af81c01bf59e08e245516c40ebc2ee842">&#9670;&#160;</a></span>find_last_of() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a5b045db53e2ee1951e28b54df69a1cc9" name="a5b045db53e2ee1951e28b54df69a1cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b045db53e2ee1951e28b54df69a1cc9">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="a7dbef564df0bc8b53eb5af4c5d4d743f" name="a7dbef564df0bc8b53eb5af4c5d4d743f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dbef564df0bc8b53eb5af4c5d4d743f">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="adce1bca49f91f2cbaf6cd55afb394a07" name="adce1bca49f91f2cbaf6cd55afb394a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce1bca49f91f2cbaf6cd55afb394a07">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
    <tr><td class="paramname">count</td><td>The length of character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in the range [<code>s</code>, <code>s + count</code>). This range can include null characters. </dd>
<dd>
If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a36b25d4d6d8b1112152fed3d5a8675fb" name="a36b25d4d6d8b1112152fed3d5a8675fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b25d4d6d8b1112152fed3d5a8675fb">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="aa3ada4c383c61f1705fed87a7a517f56" name="aa3ada4c383c61f1705fed87a7a517f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ada4c383c61f1705fed87a7a517f56">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a09746cee91ee1b9de5560cc055a0ba67" name="a09746cee91ee1b9de5560cc055a0ba67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09746cee91ee1b9de5560cc055a0ba67">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a4cf963ad4b8dbdb486ce6d9861323568" name="a4cf963ad4b8dbdb486ce6d9861323568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf963ad4b8dbdb486ce6d9861323568">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="ab74555342c1e71644a8c85221c22a253" name="ab74555342c1e71644a8c85221c22a253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74555342c1e71644a8c85221c22a253">&#9670;&#160;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aeb22ca3eb2fea9a222bddac1b5282675">allocator_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the allocator associated with the string. </p>
<dl class="section return"><dt>Returns</dt><dd>The associated allocator. </dd></dl>

</div>
</div>
<a id="a255284f6f267ad0dec0b3ce000012406" name="a255284f6f267ad0dec0b3ce000012406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a255284f6f267ad0dec0b3ce000012406">&#9670;&#160;</a></span>get_base_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ac9f39b0cc8b359570352fb6c86f17424">base_type</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::get_base_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying base type. </p>
<dl class="section return"><dt>Returns</dt><dd>The underlying base type. </dd></dl>

</div>
</div>
<a id="a62861111a3dbc4a98fad55c9d550f1c0" name="a62861111a3dbc4a98fad55c9d550f1c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62861111a3dbc4a98fad55c9d550f1c0">&#9670;&#160;</a></span>get_hash_code()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::get_hash_code </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the hash code for this <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A hash code. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1object.html#a1fea096f8a49ac5eef1f2431806109ca">xtd::object</a>.</p>

</div>
</div>
<a id="ad6adb1caf7d21ef5cf838abf7d1fe3a1" name="ad6adb1caf7d21ef5cf838abf7d1fe3a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6adb1caf7d21ef5cf838abf7d1fe3a1">&#9670;&#160;</a></span>insert() <span class="overload">[1/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a string into this instance at the specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The string to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </dd></dl>

</div>
</div>
<a id="ac98ed3d1bcec424cc1ced4248256f1dc" name="ac98ed3d1bcec424cc1ced4248256f1dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98ed3d1bcec424cc1ced4248256f1dc">&#9670;&#160;</a></span>insert() <span class="overload">[2/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts one or more copies of a specified string into this instance at the specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The string to insert. </td></tr>
    <tr><td class="paramname">count</td><td>The number of times to insert <code>value</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </dd></dl>

</div>
</div>
<a id="a71672fd9dc758a885e3ceffc79aa610e" name="a71672fd9dc758a885e3ceffc79aa610e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71672fd9dc758a885e3ceffc79aa610e">&#9670;&#160;</a></span>insert() <span class="overload">[3/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#gab7230dbe491f8bcef5e5f8bdaba5e27f">xtd::boolean</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the string representation of a boolean value into this instance at the specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </dd></dl>

</div>
</div>
<a id="ab81221aa31d3902af34338c7d5703087" name="ab81221aa31d3902af34338c7d5703087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab81221aa31d3902af34338c7d5703087">&#9670;&#160;</a></span>insert() <span class="overload">[4/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#gabb9d3031d62e3725b4265c7e5d2a98e1">xtd::byte</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the string representation of a specified 8-bit unsigned integer into this instance at the specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </dd></dl>

</div>
</div>
<a id="a3b977f8e3d9556c431a732382a12077f" name="a3b977f8e3d9556c431a732382a12077f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b977f8e3d9556c431a732382a12077f">&#9670;&#160;</a></span>insert() <span class="overload">[5/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a">xtd::decimal</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the string representation of a specified 8decimal into this instance at the specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </dd></dl>

</div>
</div>
<a id="a1998f21c817095eae59166547f564e6a" name="a1998f21c817095eae59166547f564e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1998f21c817095eae59166547f564e6a">&#9670;&#160;</a></span>insert() <span class="overload">[6/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the string representation of a specified double into this instance at the specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </dd></dl>

</div>
</div>
<a id="af4a136db945714bedcd09586014bc0a3" name="af4a136db945714bedcd09586014bc0a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a136db945714bedcd09586014bc0a3">&#9670;&#160;</a></span>insert() <span class="overload">[7/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga4c9f72f7ab9ea9919c93a1a2b245ab71">xtd::single</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the string representation of a specified single into this instance at the specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </dd></dl>

</div>
</div>
<a id="aebade1d7099ea019449faa5959c7c66e" name="aebade1d7099ea019449faa5959c7c66e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebade1d7099ea019449faa5959c7c66e">&#9670;&#160;</a></span>insert() <span class="overload">[8/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga09d26135a9af4f7a5f4cae382627d6d1">xtd::int16</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the string representation of a specified 16-bit signed integer into this instance at the specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </dd></dl>

</div>
</div>
<a id="a8e3ab96abfdc0853a7239ace614ee4bc" name="a8e3ab96abfdc0853a7239ace614ee4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e3ab96abfdc0853a7239ace614ee4bc">&#9670;&#160;</a></span>insert() <span class="overload">[9/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the string representation of a specified 32-bit signed integer into this instance at the specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </dd></dl>

</div>
</div>
<a id="ae935ba62175a9d015ff0cdb3bdde036f" name="ae935ba62175a9d015ff0cdb3bdde036f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae935ba62175a9d015ff0cdb3bdde036f">&#9670;&#160;</a></span>insert() <span class="overload">[10/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4">xtd::int64</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the string representation of a specified 64-bit signed integer into this instance at the specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </dd></dl>

</div>
</div>
<a id="abe16b4a827b8c7451b6adeeb12c98822" name="abe16b4a827b8c7451b6adeeb12c98822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe16b4a827b8c7451b6adeeb12c98822">&#9670;&#160;</a></span>insert() <span class="overload">[11/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga37e983ceedf5a7f73bc4568eaeae0aa2">xtd::sbyte</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the string representation of a specified 8-bit signed integer into this instance at the specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </dd></dl>

</div>
</div>
<a id="a12493726c9d996c346d2015c8879b667" name="a12493726c9d996c346d2015c8879b667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12493726c9d996c346d2015c8879b667">&#9670;&#160;</a></span>insert() <span class="overload">[12/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#gad8523b51611f0fac793f78f16b155b21">xtd::uint16</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the string representation of a specified 16-bit unsigned integer into this instance at the specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </dd></dl>

</div>
</div>
<a id="ae6ea5dab524bc80c779ae9f8e7e0418f" name="ae6ea5dab524bc80c779ae9f8e7e0418f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ea5dab524bc80c779ae9f8e7e0418f">&#9670;&#160;</a></span>insert() <span class="overload">[13/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga41c5d8b5d999ac5a2ff06fe57f38d5f5">xtd::uint32</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the string representation of a specified 32-bit unsigned integer into this instance at the specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </dd></dl>

</div>
</div>
<a id="a8182b9785bb3bcdb7b85bb816c1feacf" name="a8182b9785bb3bcdb7b85bb816c1feacf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8182b9785bb3bcdb7b85bb816c1feacf">&#9670;&#160;</a></span>insert() <span class="overload">[14/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#gab5833228ed21371660af349c9b1fe797">xtd::uint64</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the string representation of a specified 64-bit unsigned integer into this instance at the specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </dd></dl>

</div>
</div>
<a id="a7af88ec0b5a9a9507d434f01c88081ca" name="a7af88ec0b5a9a9507d434f01c88081ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7af88ec0b5a9a9507d434f01c88081ca">&#9670;&#160;</a></span>insert() <span class="overload">[15/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the string representation of a specified Unicode character into this instance at the specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </dd></dl>

</div>
</div>
<a id="a4a543f5eb24f0ce4efb0241346a6077b" name="a4a543f5eb24f0ce4efb0241346a6077b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a543f5eb24f0ce4efb0241346a6077b">&#9670;&#160;</a></span>insert() <span class="overload">[16/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>repeat_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a specified number of copies of the string representation of a Unicode character to this instance at the specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The character to insert. </td></tr>
    <tr><td class="paramname">repeat_count</td><td>The number of times to append value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </dd></dl>

</div>
</div>
<a id="a8e26ca656cb16b1a051d29bbc6c0b8cd" name="a8e26ca656cb16b1a051d29bbc6c0b8cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e26ca656cb16b1a051d29bbc6c0b8cd">&#9670;&#160;</a></span>insert() <span class="overload">[17/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class object_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the string representation of a specified object into this instance at the specified character position. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">object_t</td><td>The type of object to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </dd></dl>

</div>
</div>
<a id="a4d09df18594f89f4ffc30414acdd611a" name="a4d09df18594f89f4ffc30414acdd611a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d09df18594f89f4ffc30414acdd611a">&#9670;&#160;</a></span>insert() <span class="overload">[18/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts characters into the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position at which the content will be inserted. </td></tr>
    <tr><td class="paramname">count</td><td>The number of characters to insert. </td></tr>
    <tr><td class="paramname">ch</td><td>The character to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts <code>count</code> copies of character <code>ch</code> at the position <code>index</code>. </dd></dl>

</div>
</div>
<a id="ae2402d5c4a4e5387741556e7fda742be" name="ae2402d5c4a4e5387741556e7fda742be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2402d5c4a4e5387741556e7fda742be">&#9670;&#160;</a></span>insert() <span class="overload">[19/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts characters into the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position at which the content will be inserted. </td></tr>
    <tr><td class="paramname">s</td><td>The pointer to the character string to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts null-terminated character string pointed to by <code>s</code> at the position <code>index</code>. The length of the string is determined by the first null character using `traits_t::length(s). </dd></dl>

</div>
</div>
<a id="a0d53654f3dcd914ea3082bdf4118558f" name="a0d53654f3dcd914ea3082bdf4118558f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d53654f3dcd914ea3082bdf4118558f">&#9670;&#160;</a></span>insert() <span class="overload">[20/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts characters into the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position at which the content will be inserted. </td></tr>
    <tr><td class="paramname">s</td><td>The pointer to the character string to insert. </td></tr>
    <tr><td class="paramname">count</td><td>The number of characters to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts the characters in the range [<code>s</code>, <code>s + count</code>) at the position <code>index</code>. The range can contain null characters. </dd></dl>

</div>
</div>
<a id="a1b040b19ef40b307d698b783dea5e915" name="a1b040b19ef40b307d698b783dea5e915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b040b19ef40b307d698b783dea5e915">&#9670;&#160;</a></span>insert() <span class="overload">[21/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts characters into the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position at which the content will be inserted. </td></tr>
    <tr><td class="paramname">str</td><td>The string to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts string <code>str</code> at the position <code>index</code>. </dd></dl>

</div>
</div>
<a id="a67b0e31251aca8ac7d1c995a4d310acf" name="a67b0e31251aca8ac7d1c995a4d310acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67b0e31251aca8ac7d1c995a4d310acf">&#9670;&#160;</a></span>insert() <span class="overload">[22/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>s_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts characters into the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position at which the content will be inserted. </td></tr>
    <tr><td class="paramname">str</td><td>The string to insert. </td></tr>
    <tr><td class="paramname">s_index</td><td>The position of the first character in str to insert. </td></tr>
    <tr><td class="paramname">count</td><td>The number of characters to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts a string, obtained by <code>str.substr(s_index, count)</code> at the position `index. </dd></dl>

</div>
</div>
<a id="a36684de7f76f8c67b3f9061825817be4" name="a36684de7f76f8c67b3f9061825817be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36684de7f76f8c67b3f9061825817be4">&#9670;&#160;</a></span>insert() <span class="overload">[23/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>s_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts characters into the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position at which the content will be inserted. </td></tr>
    <tr><td class="paramname">str</td><td>The string to insert. </td></tr>
    <tr><td class="paramname">s_index</td><td>The position of the first character in str to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts a string, obtained by <code>str.substr(s_index, str.length())</code> at the position `index. </dd></dl>

</div>
</div>
<a id="aafe673712687e609844a2cc13af4d225" name="aafe673712687e609844a2cc13af4d225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe673712687e609844a2cc13af4d225">&#9670;&#160;</a></span>insert() <span class="overload">[24/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aae7df40d1cb269bbcdd170dde0f5dc20">iterator</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts characters into the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The iterator before which the characters will be inserted. </td></tr>
    <tr><td class="paramname">ch</td><td>The character to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator which refers to the copy of the first inserted character or <code>pos</code> if no characters were inserted (<code>count == 0</code> or <code>first == last</code> or <code>ilist.size() == 0</code>) </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`pos` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts character <code>ch</code> before the character pointed by <code>pos</code>. </dd></dl>

</div>
</div>
<a id="a75785f232f852c4f1fefc2af75473480" name="a75785f232f852c4f1fefc2af75473480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75785f232f852c4f1fefc2af75473480">&#9670;&#160;</a></span>insert() <span class="overload">[25/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aae7df40d1cb269bbcdd170dde0f5dc20">iterator</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts characters into the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The iterator before which the characters will be inserted. </td></tr>
    <tr><td class="paramname">count</td><td>The number of characters to insert. </td></tr>
    <tr><td class="paramname">ch</td><td>The character to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator which refers to the copy of the first inserted character or <code>pos</code> if no characters were inserted (<code>count == 0</code> or <code>first == last</code> or <code>ilist.size() == 0</code>) </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`pos` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts <code>count</code> copies of character <code>ch</code> before the element (if any) pointed by <code>pos</code>. </dd></dl>

</div>
</div>
<a id="a7c4c4a8641108b8ffea1f2fef33e3af0" name="a7c4c4a8641108b8ffea1f2fef33e3af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c4c4a8641108b8ffea1f2fef33e3af0">&#9670;&#160;</a></span>insert() <span class="overload">[26/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aae7df40d1cb269bbcdd170dde0f5dc20">iterator</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts characters into the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The iterator before which the characters will be inserted. </td></tr>
    <tr><td class="paramname">first</td><td>The firs position of range defining characters to insert. </td></tr>
    <tr><td class="paramname">last</td><td>The last position of range defining characters to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator which refers to the copy of the first inserted character or <code>pos</code> if no characters were inserted (<code>count == 0</code> or <code>first == last</code> or <code>ilist.size() == 0</code>) </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`pos` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts characters from the range [<code>first</code>, <code>last</code>) before the element (if any) pointed by <code>pos</code>, as if by <code>insert(pos - <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a>, basic_string(first, last, get_allocator()))</code>. </dd>
<dd>
This overload does not participate in overload resolution if input_iterator_t does not satisfy <a href="https://en.cppreference.com/w/cpp/named_req/InputIterator">LegacyInputIterator</a>. </dd></dl>

</div>
</div>
<a id="a589e207eda41349a89b4bc5f73f38359" name="a589e207eda41349a89b4bc5f73f38359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589e207eda41349a89b4bc5f73f38359">&#9670;&#160;</a></span>insert() <span class="overload">[27/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aae7df40d1cb269bbcdd170dde0f5dc20">iterator</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts characters into the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The iterator before which the characters will be inserted. </td></tr>
    <tr><td class="paramname">ilist</td><td>The <a href="https://en.cppreference.com/w/cpp/utility/initializer_list">std::initializer_list</a> to insert the characters from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator which refers to the copy of the first inserted character or <code>pos</code> if no characters were inserted (<code>count == 0</code> or <code>first == last</code> or <code>ilist.size() == 0</code>) </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`pos` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts elements from initializer list <code>ilist</code> before the element (if any) pointed by <code>pos</code>. </dd></dl>

</div>
</div>
<a id="ab655758dbc96bb5b3b2fc9316b43af44" name="ab655758dbc96bb5b3b2fc9316b43af44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab655758dbc96bb5b3b2fc9316b43af44">&#9670;&#160;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the last character from the string. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Equivalent to <code>erase(<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a32e986bfe09f3fef3a459b2a7a7b866b" title="Returns an iterator to the character following the last character of the string. This character acts ...">end()</a> - 1)</code>. The behavior is undefined if the string is empty. </dd></dl>

</div>
</div>
<a id="a06d7995728250775b7047fff4d2bfb3d" name="a06d7995728250775b7047fff4d2bfb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d7995728250775b7047fff4d2bfb3d">&#9670;&#160;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given character ch to the end of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to append. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad2fa6b7bb8ecb46f5e7d391c4f101d0" name="aad2fa6b7bb8ecb46f5e7d391c4f101d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad2fa6b7bb8ecb46f5e7d391c4f101d0">&#9670;&#160;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the specified range of characters from this instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The zero-based position in this instance where removal begins. </td></tr>
    <tr><td class="paramname">length</td><td>The number of characters to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the excise operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>If `start_index` + `length` is greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The current method removes the specified range of characters from the current instance. The characters at (<code>start_index</code> + <code>length</code>) are moved to <code>start_index</code>, and the string value of the current instance is shortened by <code>length</code>. The capacity of the current instance is unaffected. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#aad2fa6b7bb8ecb46f5e7d391c4f101d0" title="Removes the specified range of characters from this instance.">xtd::text::basic_string_builder::remove</a> method modifies the value of the current <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance and returns that instance. It does not create and return a new <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object. </dd></dl>

</div>
</div>
<a id="a230379fc4c043d52efe193008e83467d" name="a230379fc4c043d52efe193008e83467d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a230379fc4c043d52efe193008e83467d">&#9670;&#160;</a></span>replace() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>old_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>new_char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces all occurrences of a specified character in this instance with another specified character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_char</td><td>The character to replace. </td></tr>
    <tr><td class="paramname">new_char</td><td>The character that replaces <code>old_char</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance with <code>old_char</code> replaced by <code>new_char</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method performs an ordinal, case-sensitive comparison to identify occurrences of <code>old_char</code> in the current instance. The size of the current <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance is unchanged after the replacement. </dd></dl>

</div>
</div>
<a id="a681fbefc0f94da898a3b0a9001cc9a2d" name="a681fbefc0f94da898a3b0a9001cc9a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a681fbefc0f94da898a3b0a9001cc9a2d">&#9670;&#160;</a></span>replace() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>old_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>new_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces, within a substring of this instance, all occurrences of a specified character with another specified character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_char</td><td>The character to replace. </td></tr>
    <tr><td class="paramname">new_char</td><td>The character that replaces <code>old_char</code>. </td></tr>
    <tr><td class="paramname">start_index</td><td>The position in this instance where the substring begins. </td></tr>
    <tr><td class="paramname">count</td><td>The length of the substring. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance with <code>old_char</code> replaced by <code>new_char</code> in the range from <code>start_ index</code> to <code>start_index</code> + <code>count</code> - 1. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method performs an ordinal, case-sensitive comparison to identify occurrences of <code>old_char</code> in the current instance. The size of the current <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object is unchanged after the replacement. </dd></dl>

</div>
</div>
<a id="a88cea578a9167bdb678a53d3caee7ae7" name="a88cea578a9167bdb678a53d3caee7ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88cea578a9167bdb678a53d3caee7ae7">&#9670;&#160;</a></span>replace() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>old_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces all occurrences of a specified string in this instance with another specified string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_value</td><td>The string to replace. </td></tr>
    <tr><td class="paramname">new_value</td><td>The string that replaces 'old_value<code>. @return A reference to this instance with all instances of</code>old_value<code>replaced by</code>new_value<code>. @exception <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. @remarks This method performs an ordinal, case-sensitive comparison to identify occurrences of</code>old_value<code>in the current instance. If</code>new_value<code>is <a class="el" href="classxtd_1_1basic__string.html#a0ae9e9b0cbe9df3f4fc03f7e4682ef2e" title="Represents the empty basic_string.">xtd::basic_string::empty_string</a>, all occurrences of</code>old_value` are removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3a81ae8fccafc2206050c3ca0c46122" name="ad3a81ae8fccafc2206050c3ca0c46122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a81ae8fccafc2206050c3ca0c46122">&#9670;&#160;</a></span>replace() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>old_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces, within a substring of this instance, all occurrences of a specified string with another specified string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_value</td><td>The string to replace. </td></tr>
    <tr><td class="paramname">new_value</td><td>The string that replaces 'old_value<code>. @param start_index The position in this instance where the substring begins. @param count The length of the substring. @return A reference to this instance with all instances of</code>old_value<code>replaced by</code>new_value<code>in the range from</code>start_index<code>to</code>start_index<code>+</code>count<code>- 1. @exception <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></code>start_index<code>plus</code>count<code>indicates a character position not within this instance.&lt;br&gt;-or-&lt;br&gt;Enlarging the value of this instance would exceed <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a82a9b0e909ef5975e6ac07821b8b100e" title="Returns the number of characters that the string has currently allocated space for.">xtd::text::basic_string_builder::max_capacity</a>. @remarks This method performs an ordinal, case-sensitive comparison to identify occurrences of</code>old_value<code>in the substring of this current instance. If</code>new_value<code>is <a class="el" href="classxtd_1_1basic__string.html#a0ae9e9b0cbe9df3f4fc03f7e4682ef2e" title="Represents the empty basic_string.">xtd::basic_string::empty_string</a>, all occurrences of</code>old_value` are removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b199ea7cfb5a58d7404585abc06e4af" name="a2b199ea7cfb5a58d7404585abc06e4af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b199ea7cfb5a58d7404585abc06e4af">&#9670;&#160;</a></span>replace() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the characters in the range [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + pos</code>, <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The start of the substring that is going to be replaced. </td></tr>
    <tr><td class="paramname">count</td><td>The length of the substring that is going to be replaced. </td></tr>
    <tr><td class="paramname">str</td><td>The string to use for replacement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Those characters are replaced with <code>str</code>. </dd></dl>

</div>
</div>
<a id="a7b5d1e871c0993f1d447d2ee567e523d" name="a7b5d1e871c0993f1d447d2ee567e523d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5d1e871c0993f1d447d2ee567e523d">&#9670;&#160;</a></span>replace() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the characters in the range [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + pos</code>, <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first itrator of range of characters that is going to be replaced. </td></tr>
    <tr><td class="paramname">last</td><td>The last itrator of range of characters that is going to be replaced. </td></tr>
    <tr><td class="paramname">str</td><td>The string to use for replacement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Those characters are replaced with <code>str</code>. </dd>
<dd>
If [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a></code>, <code>first</code>) or [<code>first</code>, last`) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a0f15b2e74550cadf3a03adb10bbbbced" name="a0f15b2e74550cadf3a03adb10bbbbced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f15b2e74550cadf3a03adb10bbbbced">&#9670;&#160;</a></span>replace() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the characters in the range [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + pos</code>, <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The start of the substring that is going to be replaced. </td></tr>
    <tr><td class="paramname">count</td><td>The length of the substring that is going to be replaced. </td></tr>
    <tr><td class="paramname">str</td><td>The string to use for replacement. </td></tr>
    <tr><td class="paramname">pos2</td><td>The start of the substring to replace with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Those characters are replaced with a substring [<code>pos2</code>, <code>std::min(pos2 + count2, str.size())</code>) of <code>str</code>. </dd></dl>

</div>
</div>
<a id="a3759d0dbdb288f6d9516aefe8878b525" name="a3759d0dbdb288f6d9516aefe8878b525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3759d0dbdb288f6d9516aefe8878b525">&#9670;&#160;</a></span>replace() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the characters in the range [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + pos</code>, <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The start of the substring that is going to be replaced. </td></tr>
    <tr><td class="paramname">count</td><td>The length of the substring that is going to be replaced. </td></tr>
    <tr><td class="paramname">str</td><td>The string to use for replacement. </td></tr>
    <tr><td class="paramname">pos2</td><td>The start of the substring to replace with. </td></tr>
    <tr><td class="paramname">count2</td><td>The number of characters to replace with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Those characters are replaced with a substring [<code>pos2</code>, <code>std::min(pos2 + count2, str.size())</code>) of <code>str</code>. </dd></dl>

</div>
</div>
<a id="a1ee9f691c22dcd1658803d4496117255" name="a1ee9f691c22dcd1658803d4496117255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee9f691c22dcd1658803d4496117255">&#9670;&#160;</a></span>replace() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>cstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the characters in the range [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + pos</code>, <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The start of the substring that is going to be replaced. </td></tr>
    <tr><td class="paramname">count</td><td>The length of the substring that is going to be replaced. </td></tr>
    <tr><td class="paramname">cstr</td><td>The pointer to the character string to use for replacement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Those characters are replaced with the characters in the range [<code>cstr</code>, <code>cstr + count2</code>). </dd>
<dd>
If [<code>cstr</code>, <code>cstr + count2</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="aaa91c883f69a8b3f7810c07ac8421f98" name="aaa91c883f69a8b3f7810c07ac8421f98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa91c883f69a8b3f7810c07ac8421f98">&#9670;&#160;</a></span>replace() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>cstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the characters in the range [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + pos</code>, <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first itrator of range of characters that is going to be replaced. </td></tr>
    <tr><td class="paramname">last</td><td>The last itrator of range of characters that is going to be replaced. </td></tr>
    <tr><td class="paramname">cstr</td><td>The pointer to the character string to use for replacement. </td></tr>
    <tr><td class="paramname">count2</td><td>The number of characters to replace with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Those characters are replaced with the characters in the range [<code>cstr</code>, <code>cstr + count2</code>). </dd>
<dd>
If [<code>cstr</code>, <code>cstr + count2</code>) is not a valid range, the behavior is undefined. </dd>
<dd>
If [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a></code>, <code>first</code>) or [<code>first</code>, last`) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="abb13f23d390a47081a00e137355a6aff" name="abb13f23d390a47081a00e137355a6aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb13f23d390a47081a00e137355a6aff">&#9670;&#160;</a></span>replace() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>cstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the characters in the range [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + pos</code>, <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The start of the substring that is going to be replaced. </td></tr>
    <tr><td class="paramname">count</td><td>The length of the substring that is going to be replaced. </td></tr>
    <tr><td class="paramname">cstr</td><td>The pointer to the character string to use for replacement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Those characters are replaced with the characters in the range [<code>cstr</code>, <code>cstr + Traits::length(cstr)</code>). </dd></dl>

</div>
</div>
<a id="a34c7af9db7caa09b5f865b9d20e95c7c" name="a34c7af9db7caa09b5f865b9d20e95c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c7af9db7caa09b5f865b9d20e95c7c">&#9670;&#160;</a></span>replace() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>cstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the characters in the range [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + pos</code>, <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first itrator of range of characters that is going to be replaced. </td></tr>
    <tr><td class="paramname">last</td><td>The last itrator of range of characters that is going to be replaced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Those characters are replaced with the characters in the range [<code>cstr</code>, <code>cstr + Traits::length(cstr)</code>). </dd>
<dd>
If [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a></code>, <code>first</code>) or [<code>first</code>, last`) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a9e630d3858ea0aad67093fb1f51a3977" name="a9e630d3858ea0aad67093fb1f51a3977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e630d3858ea0aad67093fb1f51a3977">&#9670;&#160;</a></span>replace() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the characters in the range [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + pos</code>, <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The start of the substring that is going to be replaced. </td></tr>
    <tr><td class="paramname">count</td><td>The length of the substring that is going to be replaced. </td></tr>
    <tr><td class="paramname">count2</td><td>The number of characters to replace with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Those characters are replaced with <code>count2</code> copies of <code>ch</code>. </dd></dl>

</div>
</div>
<a id="ae7fb6a59a499e18aca19812d4b209e74" name="ae7fb6a59a499e18aca19812d4b209e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7fb6a59a499e18aca19812d4b209e74">&#9670;&#160;</a></span>replace() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the characters in the range [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + pos</code>, <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first itrator of range of characters that is going to be replaced. </td></tr>
    <tr><td class="paramname">last</td><td>The last itrator of range of characters that is going to be replaced. </td></tr>
    <tr><td class="paramname">count2</td><td>The number of characters to replace with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Those characters are replaced with <code>count2</code> copies of <code>ch</code>. </dd>
<dd>
If [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a></code>, <code>first</code>) or [<code>first</code>, last`) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a111f0dbc2b4811ecdd92f884e9cbc578" name="a111f0dbc2b4811ecdd92f884e9cbc578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a111f0dbc2b4811ecdd92f884e9cbc578">&#9670;&#160;</a></span>replace() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the characters in the range [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + pos</code>, <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first itrator of range of characters that is going to be replaced. </td></tr>
    <tr><td class="paramname">last</td><td>The last itrator of range of characters that is going to be replaced. </td></tr>
    <tr><td class="paramname">first2</td><td>The first itrator of range of characters to use for replacement. </td></tr>
    <tr><td class="paramname">last2</td><td>The last itrator of range of characters to use for replacement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Those characters are replaced with the characters in the range [<code>first2</code>, <code>last2</code>) as if by <code>replace(first, last, basic_string(first2, last2, get_allocator()))</code>. </dd>
<dd>
If [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a></code>, <code>first</code>) or [<code>first</code>, last`) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a8a8cb03254df88645e72e8bdcde862dd" name="a8a8cb03254df88645e72e8bdcde862dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a8cb03254df88645e72e8bdcde862dd">&#9670;&#160;</a></span>replace() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ae5600ab3681a2caadbce6938ea712fa1">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the characters in the range [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + pos</code>, <code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first itrator of range of characters that is going to be replaced. </td></tr>
    <tr><td class="paramname">last</td><td>The last itrator of range of characters that is going to be replaced. </td></tr>
    <tr><td class="paramname">ilist</td><td>The initializer list with the characters to use for replacement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Those characters are replaced with the characters in <code>ilist</code>. </dd>
<dd>
If [<code><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#acd10efd565a623e44c46e4b8ffb76bfd" title="Returns an iterator to the first character of the string.">begin()</a></code>, <code>first</code>) or [<code>first</code>, last`) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="aafb5c5a986bb7a0ca537de53f074be54" name="aafb5c5a986bb7a0ca537de53f074be54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb5c5a986bb7a0ca537de53f074be54">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>new_cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Informs a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object of a planned change in size, so that it can manage the storage allocation appropriately. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_cap</td><td>The new capacity of the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If <code>new_cap</code> is greater than the current <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a1fc6dca79d34264f29e710ffe3ce6e89" title="Returns the number of characters that the string has currently allocated space for.">capacity()</a>, new storage is allocated, and <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a1fc6dca79d34264f29e710ffe3ce6e89" title="Returns the number of characters that the string has currently allocated space for.">capacity()</a> is made equal or greater than <code>new_cap</code>. </dd>
<dd>
If <code>new_cap</code> is less than or equal to the current <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a1fc6dca79d34264f29e710ffe3ce6e89" title="Returns the number of characters that the string has currently allocated space for.">capacity()</a>, there is no effect. </dd>
<dd>
If a capacity change takes place, all iterators and references, including the past-the-end iterator, are invalidated. </dd></dl>

</div>
</div>
<a id="a14d03294134f9f849d74e8d303d261ac" name="a14d03294134f9f849d74e8d303d261ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d03294134f9f849d74e8d303d261ac">&#9670;&#160;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the string to contain count characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The new size of the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the current size is less than <code>count</code>, additional characters are appended: </dd>
<dd>
Initializes appended characters to <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc" title="Represents the basic string value type.">value_type()</a> ('\0' if value_type is char). </dd></dl>

</div>
</div>
<a id="ab478619bd3d3a456619a9b9b1d9ef3a7" name="ab478619bd3d3a456619a9b9b1d9ef3a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab478619bd3d3a456619a9b9b1d9ef3a7">&#9670;&#160;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the string to contain count characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The new size of the string. </td></tr>
    <tr><td class="paramname">ch</td><td>The character to initialize the new characters with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the current size is less than <code>count</code>, additional characters are appended: </dd>
<dd>
Initializes appended characters to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="afd2785748c9a606a2c0c724086b3b7a3" name="afd2785748c9a606a2c0c724086b3b7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd2785748c9a606a2c0c724086b3b7a3">&#9670;&#160;</a></span>rfind() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last substring that is equal to the given character sequence. The search begins at <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a><code>and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a>). If <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> or any value not smaller than <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad0bcb20cc5e977d053c10714929242c6" title="Returns the number of char_t elements in the string, i.e. std::distance(begin(), end()).">xtd::text::basic_string_builder::size()</a> - 1 is passed as <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a>, the whole string will be searched. @return Position of the first character of the found substring or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such substring is found. @remarks Finds the first substring equal to</code>str`. </p>

</div>
</div>
<a id="a50146eee209c5eeef9ea1a6eaebb2459" name="a50146eee209c5eeef9ea1a6eaebb2459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50146eee209c5eeef9ea1a6eaebb2459">&#9670;&#160;</a></span>rfind() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> or any value not smaller than <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad0bcb20cc5e977d053c10714929242c6" title="Returns the number of char_t elements in the string, i.e. std::distance(begin(), end()).">xtd::text::basic_string_builder::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to <code>str</code>. </dd></dl>

</div>
</div>
<a id="aa0aad3615278f80f49b1a999a6317f13" name="aa0aad3615278f80f49b1a999a6317f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0aad3615278f80f49b1a999a6317f13">&#9670;&#160;</a></span>rfind() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> or any value not smaller than <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad0bcb20cc5e977d053c10714929242c6" title="Returns the number of char_t elements in the string, i.e. std::distance(begin(), end()).">xtd::text::basic_string_builder::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
    <tr><td class="paramname">count</td><td>The length of substring to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to the range [s, s + count). </dd>
<dd>
This range may contain null characters. If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a00668ba07c172dcadfb3ce3d1371f3cd" name="a00668ba07c172dcadfb3ce3d1371f3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00668ba07c172dcadfb3ce3d1371f3cd">&#9670;&#160;</a></span>rfind() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last substring that is equal to the given character sequence. The search begins at <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a><code>and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a>). If <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> or any value not smaller than <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad0bcb20cc5e977d053c10714929242c6" title="Returns the number of char_t elements in the string, i.e. std::distance(begin(), end()).">xtd::text::basic_string_builder::size()</a> - 1 is passed as <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a>, the whole string will be searched. @param s The pointer to a character string to search for. @return Position of the first character of the found substring or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such substring is found. @remarks Finds the first substring equal to the character string pointed to by</code>s<code>. The length of the string is determined by the first null character using</code>traits_t::length(s)<code>. @remarks If [</code>s<code>,</code>s + traits_t::length(s)`) is not a valid range, the behavior is undefined. </p>

</div>
</div>
<a id="ab026da2f2056155bb144787f950ca3e7" name="ab026da2f2056155bb144787f950ca3e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab026da2f2056155bb144787f950ca3e7">&#9670;&#160;</a></span>rfind() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> or any value not smaller than <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad0bcb20cc5e977d053c10714929242c6" title="Returns the number of char_t elements in the string, i.e. std::distance(begin(), end()).">xtd::text::basic_string_builder::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to the character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a2ee1570674497bc4871d7ad3b9b17ed7" name="a2ee1570674497bc4871d7ad3b9b17ed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee1570674497bc4871d7ad3b9b17ed7">&#9670;&#160;</a></span>rfind() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last substring that is equal to the given character sequence. The search begins at <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a><code>and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a>). If <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> or any value not smaller than <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad0bcb20cc5e977d053c10714929242c6" title="Returns the number of char_t elements in the string, i.e. std::distance(begin(), end()).">xtd::text::basic_string_builder::size()</a> - 1 is passed as <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a>, the whole string will be searched. @param ch The character to search for. @return Position of the first character of the found substring or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such substring is found. @remarks Finds the first character</code>ch` (treated as a single-character substring by the formal rules below). </p>

</div>
</div>
<a id="adcd5950f09061481c41efd222922d8ce" name="adcd5950f09061481c41efd222922d8ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd5950f09061481c41efd222922d8ce">&#9670;&#160;</a></span>rfind() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> or any value not smaller than <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ad0bcb20cc5e977d053c10714929242c6" title="Returns the number of char_t elements in the string, i.e. std::distance(begin(), end()).">xtd::text::basic_string_builder::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character <code>ch</code> (treated as a single-character substring by the formal rules below). </dd></dl>

</div>
</div>
<a id="a3fa3478a9e5c14cf145652dae38ef19f" name="a3fa3478a9e5c14cf145652dae38ef19f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa3478a9e5c14cf145652dae38ef19f">&#9670;&#160;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests the removal of unused capacity. </p>
<dl class="section remark"><dt>Remarks</dt><dd>It is a non-binding request to reduce <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a1fc6dca79d34264f29e710ffe3ce6e89" title="Returns the number of characters that the string has currently allocated space for.">capacity()</a> to <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>. It depends on the implementation if the request is fulfilled. </dd>
<dd>
If (and only if) reallocation takes place, all pointers, references, and iterators are invalidated. </dd></dl>

</div>
</div>
<a id="a168d97f3252db3d6706fa324190fbcd8" name="a168d97f3252db3d6706fa324190fbcd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168d97f3252db3d6706fa324190fbcd8">&#9670;&#160;</a></span>substr() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::substr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a substring [<code>pos</code>, <code>pos + count</code>). If the requested substring extends past the end of the string, i.e. the <code>count</code> is greater than <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a> - pos (e.g. if <code>count</code> == <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a>), the returned substring is [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). </p>
<dl class="section return"><dt>Returns</dt><dd>String containing the substring [<code>pos</code>, <code>pos + count</code>) or [pos, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">`std::out_of_range`</td><td>if `pos &gt; <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>`. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Equivalent to return <code>basic_string_builder(*this, pos, count);</code>. </dd></dl>

</div>
</div>
<a id="aa6b6033babf65f6afa93c1fa114fae88" name="aa6b6033babf65f6afa93c1fa114fae88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b6033babf65f6afa93c1fa114fae88">&#9670;&#160;</a></span>substr() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::substr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a substring [<code>pos</code>, <code>pos + count</code>). If the requested substring extends past the end of the string, i.e. the <code>count</code> is greater than <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a> - pos (e.g. if <code>count</code> == <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a>), the returned substring is [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position of the first character to include. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String containing the substring [<code>pos</code>, <code>pos + count</code>) or [pos, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">`std::out_of_range`</td><td>if `pos &gt; <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>`. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Equivalent to return <code>basic_string_builder(*this, pos, count);</code>. </dd></dl>

</div>
</div>
<a id="a40cd57b1e78f411c904144725389941a" name="a40cd57b1e78f411c904144725389941a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40cd57b1e78f411c904144725389941a">&#9670;&#160;</a></span>substr() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::substr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a substring [<code>pos</code>, <code>pos + count</code>). If the requested substring extends past the end of the string, i.e. the <code>count</code> is greater than <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a> - pos (e.g. if <code>count</code> == <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a08bf02d73655eeb3dbc8eac397b81123" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::text::basic_string_builder::npos</a>), the returned substring is [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position of the first character to include. </td></tr>
    <tr><td class="paramname">count</td><td>The length of the substring. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String containing the substring [<code>pos</code>, <code>pos + count</code>) or [pos, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">`std::out_of_range`</td><td>if `pos &gt; <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>`. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Equivalent to return <code>basic_string_builder(*this, pos, count);</code>. </dd></dl>

</div>
</div>
<a id="aa4adcc8a4f6c42434091cc96fcc49061" name="aa4adcc8a4f6c42434091cc96fcc49061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4adcc8a4f6c42434091cc96fcc49061">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents of the string with those of other. All iterators and references may be invalidated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to exchange the contents with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a877feeab7ac0df07e40be12990dec52d" name="a877feeab7ac0df07e40be12990dec52d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877feeab7ac0df07e40be12990dec52d">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the value of this instance to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> &lt;char&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>The current string. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000038">Todo:</a></b></dt><dd>Uncomment the folllowing line and remove the next.. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1object.html#af2d19ef177db62351b58a42f22138dbe">xtd::object</a>.</p>

</div>
</div>
<a id="a3d162b34eefce8985ad367f3ca78e4dc" name="a3d162b34eefce8985ad367f3ca78e4dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d162b34eefce8985ad367f3ca78e4dc">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a7a9fff0c8a14fc2115fe86547402e0b4">const_reference</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the character at specified location index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position of the character to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested character. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>If `index` is not within the range of the string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99facb90b642227990bd5b1f94bb1750" name="a99facb90b642227990bd5b1f94bb1750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99facb90b642227990bd5b1f94bb1750">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a9b9b46ae1d66c7d5c9ac716899c0be58">reference</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the character at specified location index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position of the character to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested character. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>If `index` is not within the range of the string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1f8e06524f9fa65f9c7017a9d9e4619" name="ab1f8e06524f9fa65f9c7017a9d9e4619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f8e06524f9fa65f9c7017a9d9e4619">&#9670;&#160;</a></span>operator const base_type &amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ac9f39b0cc8b359570352fb6c86f17424">base_type</a> &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the underlying base type. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the underlying base type. </dd></dl>

</div>
</div>
<a id="a6f826690bfb0d112064bfdd5cb0e0f88" name="a6f826690bfb0d112064bfdd5cb0e0f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f826690bfb0d112064bfdd5cb0e0f88">&#9670;&#160;</a></span>operator base_type &amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#ac9f39b0cc8b359570352fb6c86f17424">base_type</a> &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the underlying base type. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the underlying base type. </dd></dl>

</div>
</div>
<a id="a1ecaa8470016180805e8aae60741be04" name="a1ecaa8470016180805e8aae60741be04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ecaa8470016180805e8aae60741be04">&#9670;&#160;</a></span>operator=() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="afea8f1950013cfa7b62845ed804eadf2" name="afea8f1950013cfa7b62845ed804eadf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea8f1950013cfa7b62845ed804eadf2">&#9670;&#160;</a></span>operator=() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in <code>str</code> is moved from <code>str</code> into this string). <code>str</code> is in a valid but unspecified state afterwards. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="aeb76aa90b3febf78d306d5eae58c0aaa" name="aeb76aa90b3febf78d306d5eae58c0aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb76aa90b3febf78d306d5eae58c0aaa">&#9670;&#160;</a></span>operator=() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a8cba958ff90c1eae4110b211598479ed" name="a8cba958ff90c1eae4110b211598479ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cba958ff90c1eae4110b211598479ed">&#9670;&#160;</a></span>operator=() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a361314e49ff5adb0ece44b9ebeaa068d" name="a361314e49ff5adb0ece44b9ebeaa068d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a361314e49ff5adb0ece44b9ebeaa068d">&#9670;&#160;</a></span>operator=() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a7c7b1d4ebec4fcf9da9d90ea3c3219cb" name="a7c7b1d4ebec4fcf9da9d90ea3c3219cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7b1d4ebec4fcf9da9d90ea3c3219cb">&#9670;&#160;</a></span>operator=() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a9440ad97280090e604efa6d926641189" name="a9440ad97280090e604efa6d926641189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9440ad97280090e604efa6d926641189">&#9670;&#160;</a></span>operator=() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String litteral pointer to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">xtd::tring_null_pointer_exception</td><td>The `str` is null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="ad8965763778b83efc5a9f7557806f2a1" name="ad8965763778b83efc5a9f7557806f2a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8965763778b83efc5a9f7557806f2a1">&#9670;&#160;</a></span>operator=() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>character</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with the specified character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a628c15f570caf7d2efa10554d1fde169" name="a628c15f570caf7d2efa10554d1fde169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a628c15f570caf7d2efa10554d1fde169">&#9670;&#160;</a></span>operator=() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of the specified initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initialiazer list to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a091ac07faa8b98417e11d70f4272d1c1" name="a091ac07faa8b98417e11d70f4272d1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a091ac07faa8b98417e11d70f4272d1c1">&#9670;&#160;</a></span>operator+=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="af2b9d25941d4757dc74bb5b1a956d79f" name="af2b9d25941d4757dc74bb5b1a956d79f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b9d25941d4757dc74bb5b1a956d79f">&#9670;&#160;</a></span>operator+=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a446536be6df64bb7da260de2891a3993" name="a446536be6df64bb7da260de2891a3993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446536be6df64bb7da260de2891a3993">&#9670;&#160;</a></span>operator+=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a5c11cf7a49f5f7c9bea14c37f003fafa">const_pointer</a>&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="aad64103e7fd14893e78d8ccd8e71bb82" name="aad64103e7fd14893e78d8ccd8e71bb82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad64103e7fd14893e78d8ccd8e71bb82">&#9670;&#160;</a></span>operator+=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#afc4750931de93fb98ca4024209bd18cc">value_type</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character value to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a08bf02d73655eeb3dbc8eac397b81123" name="a08bf02d73655eeb3dbc8eac397b81123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08bf02d73655eeb3dbc8eac397b81123">&#9670;&#160;</a></span>npos</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t  = std::char_traits&lt;char_t&gt;, class allocator_t  = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html#a00d3525c87b582cd9dbf27852cf1199f">size_type</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::npos</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a special value equal to the maximum value representable by the type <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">xtd::size</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/text/<a class="el" href="basic__string__builder_8hpp_source.html">basic_string_builder.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Feb 1 2025 20:21:38 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
