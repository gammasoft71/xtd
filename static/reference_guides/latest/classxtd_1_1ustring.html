<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::ustring Class Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="classxtd_1_1ustring.html">ustring</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classxtd_1_1ustring-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::ustring Class Reference<div class="ingroups"><a class="el" href="group__libraries.html">libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::ustring:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1ustring.png" usemap="#xtd::ustring_map" alt=""/>
  <map id="xtd::ustring_map" name="xtd::ustring_map">
<area href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes...." alt="xtd::object" shape="rect" coords="0,56,165,80"/>
<area href="classxtd_1_1icomparable.html" alt="xtd::icomparable&lt; ustring &gt;" shape="rect" coords="175,56,340,80"/>
<area href="classxtd_1_1interface.html" title="Represent an interface class." alt="xtd::interface" shape="rect" coords="175,0,340,24"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><p>Represents text as a sequence of UTF-8 code units. </p>
<dl class="section user"><dt>Namespace</dt><dd>xtd </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>A string is a sequential collection of characters that's used to represent text. A <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> object is a sequential collection of char that represent a string; a char corresponds to a UTF-8 code unit. The value of the <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> object is the content of the sequential collection of char, and unlike std::basic_string that value is immutable (that is, it is read-only). </dd>
<dd>
If you want the same mutable string class, you can use xtd::text::ustring_builder class. </dd>
<dd>
<a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> is inherited from std::basic_string&lt;char&gt; and therefore offers the full (immutable) API of std::string. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="action_8cpp-example.html#_a0">action.cpp</a>, <a class="el" href="action1_8cpp-example.html#_a0">action1.cpp</a>, <a class="el" href="action2_8cpp-example.html#_a0">action2.cpp</a>, <a class="el" href="action3_8cpp-example.html#_a0">action3.cpp</a>, <a class="el" href="application_enable_dark_mode_8cpp-example.html#_a8">application_enable_dark_mode.cpp</a>, <a class="el" href="application_enable_light_mode_8cpp-example.html#_a8">application_enable_light_mode.cpp</a>, <a class="el" href="as_8cpp-example.html#_a0">as.cpp</a>, <a class="el" href="auto_reset_event_8cpp-example.html#_a0">auto_reset_event.cpp</a>, <a class="el" href="binary_reader_8cpp-example.html#_a0">binary_reader.cpp</a>, <a class="el" href="binary_reader2_8cpp-example.html#_a0">binary_reader2.cpp</a>, <a class="el" href="binary_reader3_8cpp-example.html#_a0">binary_reader3.cpp</a>, <a class="el" href="boxed_info_8cpp-example.html#_a0">boxed_info.cpp</a>, <a class="el" href="boxing_8cpp-example.html#_a1">boxing.cpp</a>, <a class="el" href="console_clear_8cpp-example.html#_a0">console_clear.cpp</a>, <a class="el" href="console_cursor_8cpp-example.html#_a0">console_cursor.cpp</a>, <a class="el" href="console_firework_8cpp-example.html#_a1">console_firework.cpp</a>, <a class="el" href="console_read_line_8cpp-example.html#_a0">console_read_line.cpp</a>, <a class="el" href="console_read_line2_8cpp-example.html#_a0">console_read_line2.cpp</a>, <a class="el" href="contains_8cpp-example.html#_a0">contains.cpp</a>, <a class="el" href="csf_8cpp-example.html#_a0">csf.cpp</a>, <a class="el" href="current_stack_frame_8cpp-example.html#_a0">current_stack_frame.cpp</a>, <a class="el" href="date_time_specify_kind_8cpp-example.html#_a1">date_time_specify_kind.cpp</a>, <a class="el" href="delegate_8cpp-example.html#_a0">delegate.cpp</a>, <a class="el" href="delegate_begin_invoke_8cpp-example.html#_a0">delegate_begin_invoke.cpp</a>, <a class="el" href="delegate_lambda_8cpp-example.html#_a0">delegate_lambda.cpp</a>, <a class="el" href="delegate_member_method_8cpp-example.html#_a0">delegate_member_method.cpp</a>, <a class="el" href="delegate_multicast_8cpp-example.html#_a0">delegate_multicast.cpp</a>, <a class="el" href="event_8cpp-example.html#_a2">event.cpp</a>, <a class="el" href="file_info_move_to_8cpp-example.html#_a0">file_info_move_to.cpp</a>, <a class="el" href="file_info_replace_8cpp-example.html#_a1">file_info_replace.cpp</a>, <a class="el" href="folder_browser_box_8cpp-example.html#_a3">folder_browser_box.cpp</a>, <a class="el" href="folder_browser_dialog_8cpp-example.html#_a5">folder_browser_dialog.cpp</a>, <a class="el" href="format_any_8cpp-example.html#_a0">format_any.cpp</a>, <a class="el" href="format_class_8cpp-example.html#_a0">format_class.cpp</a>, <a class="el" href="format_class_object_8cpp-example.html#_a1">format_class_object.cpp</a>, <a class="el" href="format_class_with_specified_formating_8cpp-example.html#_a0">format_class_with_specified_formating.cpp</a>, <a class="el" href="interface_8cpp-example.html#_a1">interface.cpp</a>, <a class="el" href="interface2_8cpp-example.html#_a1">interface2.cpp</a>, <a class="el" href="interlocked_8cpp-example.html#_a1">interlocked.cpp</a>, <a class="el" href="iobservable_iobserver_8cpp-example.html#_a3">iobservable_iobserver.cpp</a>, <a class="el" href="ip_address_8cpp-example.html#_a0">ip_address.cpp</a>, <a class="el" href="iprogress_8cpp-example.html#_a0">iprogress.cpp</a>, <a class="el" href="manual_reset_event_8cpp-example.html#_a1">manual_reset_event.cpp</a>, <a class="el" href="minesweeper_8cpp-example.html#_a24">minesweeper.cpp</a>, <a class="el" href="mixing_std_and_xtd_threads_8cpp-example.html#_a0">mixing_std_and_xtd_threads.cpp</a>, <a class="el" href="open_file_box_8cpp-example.html#_a1">open_file_box.cpp</a>, <a class="el" href="open_file_dialog_8cpp-example.html#_a5">open_file_dialog.cpp</a>, <a class="el" href="socket_tcp_ip_v4_8cpp-example.html#_a4">socket_tcp_ip_v4.cpp</a>, <a class="el" href="socket_tcp_ip_v4_without_thread_8cpp-example.html#_a3">socket_tcp_ip_v4_without_thread.cpp</a>, <a class="el" href="socket_tcp_ip_v6_8cpp-example.html#_a4">socket_tcp_ip_v6.cpp</a>, <a class="el" href="socket_udp_ip_v4_8cpp-example.html#_a4">socket_udp_ip_v4.cpp</a>, <a class="el" href="socket_udp_ip_v6_8cpp-example.html#_a4">socket_udp_ip_v6.cpp</a>, <a class="el" href="some_controls_8cpp-example.html#_a8">some_controls.cpp</a>, <a class="el" href="some_system_controls_8cpp-example.html#_a8">some_system_controls.cpp</a>, <a class="el" href="split_8cpp-example.html#_a0">split.cpp</a>, <a class="el" href="sprintf_class_8cpp-example.html#_a0">sprintf_class.cpp</a>, <a class="el" href="sprintf_class_with_specified_formating_8cpp-example.html#_a0">sprintf_class_with_specified_formating.cpp</a>, <a class="el" href="stack_trace_simple_8cpp-example.html#_a2">stack_trace_simple.cpp</a>, <a class="el" href="static_8cpp-example.html#_a1">static.cpp</a>, <a class="el" href="static_object_8cpp-example.html#_a1">static_object.cpp</a>, <a class="el" href="static_object2_8cpp-example.html#_a1">static_object2.cpp</a>, <a class="el" href="test_forms_8cpp-example.html#_a27">test_forms.cpp</a>, <a class="el" href="test_tunit_8cpp-example.html#_a2">test_tunit.cpp</a>, <a class="el" href="themes_8cpp-example.html#_a8">themes.cpp</a>, <a class="el" href="time_span_from_hours_8cpp-example.html#_a1">time_span_from_hours.cpp</a>, <a class="el" href="timers_timer_synchronizing_object_8cpp-example.html#_a10">timers_timer_synchronizing_object.cpp</a>, <a class="el" href="udp_client_ip_v4_8cpp-example.html#_a3">udp_client_ip_v4.cpp</a>, <a class="el" href="udp_client_ip_v6_8cpp-example.html#_a3">udp_client_ip_v6.cpp</a>, <a class="el" href="user_dialog_8cpp-example.html#_a1">user_dialog.cpp</a>, <a class="el" href="user_dialog_show_sheet_8cpp-example.html#_a1">user_dialog_show_sheet.cpp</a>, <a class="el" href="wconsole_8cpp-example.html#_a0">wconsole.cpp</a>, and <a class="el" href="wconsole2_8cpp-example.html#_a0">wconsole2.cpp</a>.</dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Fields</h2></td></tr>
<tr class="memitem:ad2a9ab2b0dea8ef1ad59d47a49647d5b"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ad2a9ab2b0dea8ef1ad59d47a49647d5b">empty_string</a></td></tr>
<tr class="memdesc:ad2a9ab2b0dea8ef1ad59d47a49647d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the empty string.  <br /></td></tr>
<tr class="separator:ad2a9ab2b0dea8ef1ad59d47a49647d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Constructors</h2></td></tr>
<tr class="memitem:add61d5146149ee689a7f9bed1309cfad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#add61d5146149ee689a7f9bed1309cfad">ustring</a> () noexcept</td></tr>
<tr class="memdesc:add61d5146149ee689a7f9bed1309cfad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>.  <br /></td></tr>
<tr class="separator:add61d5146149ee689a7f9bed1309cfad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08170f266741991ebf47b057a34ba124"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a08170f266741991ebf47b057a34ba124">ustring</a> (const allocator_type &amp;allocator) noexcept</td></tr>
<tr class="memdesc:a08170f266741991ebf47b057a34ba124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified allocator.  <br /></td></tr>
<tr class="separator:a08170f266741991ebf47b057a34ba124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c6e9bc0de28607372aa298e5886f84"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a09c6e9bc0de28607372aa298e5886f84">ustring</a> (size_t count, value_type character)</td></tr>
<tr class="memdesc:a09c6e9bc0de28607372aa298e5886f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character.  <br /></td></tr>
<tr class="separator:a09c6e9bc0de28607372aa298e5886f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c19dfade464033be0ffb4e86fb1ead"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a94c19dfade464033be0ffb4e86fb1ead">ustring</a> (size_t count, value_type character, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a94c19dfade464033be0ffb4e86fb1ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character and specified allocator.  <br /></td></tr>
<tr class="separator:a94c19dfade464033be0ffb4e86fb1ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60eed64a348bd421e9fea1488611c2a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a60eed64a348bd421e9fea1488611c2a4">ustring</a> (size_t count, <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">char8</a> character)</td></tr>
<tr class="memdesc:a60eed64a348bd421e9fea1488611c2a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character.  <br /></td></tr>
<tr class="separator:a60eed64a348bd421e9fea1488611c2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5db46f55794c8f7ed6ce44a44c5aa87"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ae5db46f55794c8f7ed6ce44a44c5aa87">ustring</a> (size_t count, <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">char8</a> character, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:ae5db46f55794c8f7ed6ce44a44c5aa87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character and specified allocator.  <br /></td></tr>
<tr class="separator:ae5db46f55794c8f7ed6ce44a44c5aa87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8a8bc83d8eca6678303fc24e13b85c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a2e8a8bc83d8eca6678303fc24e13b85c">ustring</a> (size_t count, <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">char16</a> character)</td></tr>
<tr class="memdesc:a2e8a8bc83d8eca6678303fc24e13b85c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character.  <br /></td></tr>
<tr class="separator:a2e8a8bc83d8eca6678303fc24e13b85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5c3469299d8c2db3306edcb65b091e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a6b5c3469299d8c2db3306edcb65b091e">ustring</a> (size_t count, <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">char16</a> character, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a6b5c3469299d8c2db3306edcb65b091e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character and specified allocator.  <br /></td></tr>
<tr class="separator:a6b5c3469299d8c2db3306edcb65b091e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad580a4e34ed9845fcc962357cdb43c91"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ad580a4e34ed9845fcc962357cdb43c91">ustring</a> (size_t count, <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">char32</a> character)</td></tr>
<tr class="memdesc:ad580a4e34ed9845fcc962357cdb43c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character.  <br /></td></tr>
<tr class="separator:ad580a4e34ed9845fcc962357cdb43c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2353536a07382b5d45accaadb5f203"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a0c2353536a07382b5d45accaadb5f203">ustring</a> (size_t count, <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">char32</a> character, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a0c2353536a07382b5d45accaadb5f203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character and specified allocator.  <br /></td></tr>
<tr class="separator:a0c2353536a07382b5d45accaadb5f203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44be94c61a89e56b681e1c765de9591c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a44be94c61a89e56b681e1c765de9591c">ustring</a> (size_t count, <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">wchar</a> character)</td></tr>
<tr class="memdesc:a44be94c61a89e56b681e1c765de9591c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character.  <br /></td></tr>
<tr class="separator:a44be94c61a89e56b681e1c765de9591c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3b1d1f4a121d8cc3ad14d6a8710e96"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#acf3b1d1f4a121d8cc3ad14d6a8710e96">ustring</a> (size_t count, <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">wchar</a> character, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:acf3b1d1f4a121d8cc3ad14d6a8710e96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character and specified allocator.  <br /></td></tr>
<tr class="separator:acf3b1d1f4a121d8cc3ad14d6a8710e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e9d9b1b3d1dd5c2431aff1fb936b34"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a09e9d9b1b3d1dd5c2431aff1fb936b34">ustring</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str, size_t index, size_t count)</td></tr>
<tr class="memdesc:a09e9d9b1b3d1dd5c2431aff1fb936b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified substring at index and count characters.  <br /></td></tr>
<tr class="separator:a09e9d9b1b3d1dd5c2431aff1fb936b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961a9ba4c72a3ef7e30ce00744fab282"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a961a9ba4c72a3ef7e30ce00744fab282">ustring</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str, size_t index, size_t count, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a961a9ba4c72a3ef7e30ce00744fab282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified substring at index, count characters and allocator.  <br /></td></tr>
<tr class="separator:a961a9ba4c72a3ef7e30ce00744fab282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0dd03c9c81d6dcf7686bf80ef7183b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ac0dd03c9c81d6dcf7686bf80ef7183b0">ustring</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str, size_t index)</td></tr>
<tr class="memdesc:ac0dd03c9c81d6dcf7686bf80ef7183b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified substring at index.  <br /></td></tr>
<tr class="separator:ac0dd03c9c81d6dcf7686bf80ef7183b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378a1ead97b2b5db84cc20e6dfd0a71d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a378a1ead97b2b5db84cc20e6dfd0a71d">ustring</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str, size_t index, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a378a1ead97b2b5db84cc20e6dfd0a71d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified substring at index and allocator.  <br /></td></tr>
<tr class="separator:a378a1ead97b2b5db84cc20e6dfd0a71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175105db0d4fd8d70afd6bf68e901c43"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a175105db0d4fd8d70afd6bf68e901c43">ustring</a> (const value_type *str, size_t count)</td></tr>
<tr class="memdesc:a175105db0d4fd8d70afd6bf68e901c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified substring and count characters.  <br /></td></tr>
<tr class="separator:a175105db0d4fd8d70afd6bf68e901c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94daf332e8506577c406ff8be31a68ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a94daf332e8506577c406ff8be31a68ed">ustring</a> (const value_type *str, size_t count, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a94daf332e8506577c406ff8be31a68ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified substring, count characters and allocator.  <br /></td></tr>
<tr class="separator:a94daf332e8506577c406ff8be31a68ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c52720442dea9e80a0ee939e0e8644"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a22c52720442dea9e80a0ee939e0e8644">ustring</a> (const value_type *str)</td></tr>
<tr class="memdesc:a22c52720442dea9e80a0ee939e0e8644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:a22c52720442dea9e80a0ee939e0e8644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d9fbd84544ded58b56bb258c839977"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a82d9fbd84544ded58b56bb258c839977">ustring</a> (const value_type *str, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a82d9fbd84544ded58b56bb258c839977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator.  <br /></td></tr>
<tr class="separator:a82d9fbd84544ded58b56bb258c839977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4407cb0d803eaca779def996836accae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a4407cb0d803eaca779def996836accae">ustring</a> (value_type *str)</td></tr>
<tr class="memdesc:a4407cb0d803eaca779def996836accae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:a4407cb0d803eaca779def996836accae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30cffa0a677d57c60dbc300e2a63f8e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#aa30cffa0a677d57c60dbc300e2a63f8e">ustring</a> (value_type *str, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:aa30cffa0a677d57c60dbc300e2a63f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator.  <br /></td></tr>
<tr class="separator:aa30cffa0a677d57c60dbc300e2a63f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaeedea48ef4f24dafe9ec8fb70092c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#acaeedea48ef4f24dafe9ec8fb70092c5">ustring</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str) noexcept</td></tr>
<tr class="memdesc:acaeedea48ef4f24dafe9ec8fb70092c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:acaeedea48ef4f24dafe9ec8fb70092c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ca1e3a8ea546462fe2490d87161e67"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a97ca1e3a8ea546462fe2490d87161e67">ustring</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str, const allocator_type &amp;allocator) noexcept</td></tr>
<tr class="memdesc:a97ca1e3a8ea546462fe2490d87161e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy and allocator.  <br /></td></tr>
<tr class="separator:a97ca1e3a8ea546462fe2490d87161e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d943de2665ca7471a3c7012f0ac85a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#aa1d943de2665ca7471a3c7012f0ac85a">ustring</a> (const std::string &amp;str) noexcept</td></tr>
<tr class="memdesc:aa1d943de2665ca7471a3c7012f0ac85a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:aa1d943de2665ca7471a3c7012f0ac85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c224c965990e3a8674037250c9c466d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a9c224c965990e3a8674037250c9c466d">ustring</a> (const std::string &amp;str, const allocator_type &amp;allocator) noexcept</td></tr>
<tr class="memdesc:a9c224c965990e3a8674037250c9c466d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy and allocator.  <br /></td></tr>
<tr class="separator:a9c224c965990e3a8674037250c9c466d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fcf93d304874f014d6a802be7666c1c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a1fcf93d304874f014d6a802be7666c1c">ustring</a> (const std::u8string &amp;str) noexcept</td></tr>
<tr class="memdesc:a1fcf93d304874f014d6a802be7666c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:a1fcf93d304874f014d6a802be7666c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e269e43bbcacd9b0071ccb1fe5e158"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a31e269e43bbcacd9b0071ccb1fe5e158">ustring</a> (const std::u8string &amp;str, const allocator_type &amp;allocator) noexcept</td></tr>
<tr class="memdesc:a31e269e43bbcacd9b0071ccb1fe5e158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy and allocator.  <br /></td></tr>
<tr class="separator:a31e269e43bbcacd9b0071ccb1fe5e158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5295f4a35fdf004ab7c4b62bf1ba56b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#af5295f4a35fdf004ab7c4b62bf1ba56b">ustring</a> (const <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">char8</a> *str)</td></tr>
<tr class="memdesc:af5295f4a35fdf004ab7c4b62bf1ba56b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:af5295f4a35fdf004ab7c4b62bf1ba56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1505227afa3c82eb5e0a2e4e1754f541"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a1505227afa3c82eb5e0a2e4e1754f541">ustring</a> (const <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">char8</a> *str, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a1505227afa3c82eb5e0a2e4e1754f541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator.  <br /></td></tr>
<tr class="separator:a1505227afa3c82eb5e0a2e4e1754f541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c35e48175f6d6ea83deb119883fb23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ab6c35e48175f6d6ea83deb119883fb23">ustring</a> (<a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">char8</a> *str)</td></tr>
<tr class="memdesc:ab6c35e48175f6d6ea83deb119883fb23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:ab6c35e48175f6d6ea83deb119883fb23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701190baffb8aa8f2fc412d63310aaa4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a701190baffb8aa8f2fc412d63310aaa4">ustring</a> (<a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">char8</a> *str, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a701190baffb8aa8f2fc412d63310aaa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator.  <br /></td></tr>
<tr class="separator:a701190baffb8aa8f2fc412d63310aaa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6819b6bf89183d64b7ac6d474772b07"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ae6819b6bf89183d64b7ac6d474772b07">ustring</a> (const std::u16string &amp;str) noexcept</td></tr>
<tr class="memdesc:ae6819b6bf89183d64b7ac6d474772b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:ae6819b6bf89183d64b7ac6d474772b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6c2740de5260fc6cc9d3fa7066fbfe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#abf6c2740de5260fc6cc9d3fa7066fbfe">ustring</a> (const std::u16string &amp;str, const allocator_type &amp;allocator) noexcept</td></tr>
<tr class="memdesc:abf6c2740de5260fc6cc9d3fa7066fbfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy and allocator.  <br /></td></tr>
<tr class="separator:abf6c2740de5260fc6cc9d3fa7066fbfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409297779dcf55ae74b83a435569b328"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a409297779dcf55ae74b83a435569b328">ustring</a> (const <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">char16</a> *str)</td></tr>
<tr class="memdesc:a409297779dcf55ae74b83a435569b328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:a409297779dcf55ae74b83a435569b328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0994a9a72dd136d0abb8390be983dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a1c0994a9a72dd136d0abb8390be983dd">ustring</a> (const <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">char16</a> *str, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a1c0994a9a72dd136d0abb8390be983dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator.  <br /></td></tr>
<tr class="separator:a1c0994a9a72dd136d0abb8390be983dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a5d9202fbeea5064291b66206aa0cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a31a5d9202fbeea5064291b66206aa0cd">ustring</a> (<a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">char16</a> *str)</td></tr>
<tr class="memdesc:a31a5d9202fbeea5064291b66206aa0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:a31a5d9202fbeea5064291b66206aa0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad896767620ca29c0136fda92dcd90007"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ad896767620ca29c0136fda92dcd90007">ustring</a> (<a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">char16</a> *str, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:ad896767620ca29c0136fda92dcd90007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator.  <br /></td></tr>
<tr class="separator:ad896767620ca29c0136fda92dcd90007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c728901774cc83ca604138421d6268"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ab8c728901774cc83ca604138421d6268">ustring</a> (const std::u32string &amp;str) noexcept</td></tr>
<tr class="memdesc:ab8c728901774cc83ca604138421d6268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:ab8c728901774cc83ca604138421d6268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4269aa64ca67c250c758763e6819cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ada4269aa64ca67c250c758763e6819cd">ustring</a> (const std::u32string &amp;str, const allocator_type &amp;allocator) noexcept</td></tr>
<tr class="memdesc:ada4269aa64ca67c250c758763e6819cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy and allocator.  <br /></td></tr>
<tr class="separator:ada4269aa64ca67c250c758763e6819cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5521daa7562bf09ec4bf4b9d5bb415a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a5521daa7562bf09ec4bf4b9d5bb415a1">ustring</a> (const <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">char32</a> *str)</td></tr>
<tr class="memdesc:a5521daa7562bf09ec4bf4b9d5bb415a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:a5521daa7562bf09ec4bf4b9d5bb415a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d83e074a4787153dcdd61fd7df2180"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ab9d83e074a4787153dcdd61fd7df2180">ustring</a> (const <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">char32</a> *str, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:ab9d83e074a4787153dcdd61fd7df2180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator.  <br /></td></tr>
<tr class="separator:ab9d83e074a4787153dcdd61fd7df2180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b3316b8b80398b29421521f343c7e7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a13b3316b8b80398b29421521f343c7e7">ustring</a> (<a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">char32</a> *str)</td></tr>
<tr class="memdesc:a13b3316b8b80398b29421521f343c7e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:a13b3316b8b80398b29421521f343c7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be6798dbe450805467abc4fd0348ae4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a5be6798dbe450805467abc4fd0348ae4">ustring</a> (<a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">char32</a> *str, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a5be6798dbe450805467abc4fd0348ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator.  <br /></td></tr>
<tr class="separator:a5be6798dbe450805467abc4fd0348ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6051d53b2892b7585b6278a2a5601b9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ac6051d53b2892b7585b6278a2a5601b9">ustring</a> (const std::wstring &amp;str) noexcept</td></tr>
<tr class="memdesc:ac6051d53b2892b7585b6278a2a5601b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:ac6051d53b2892b7585b6278a2a5601b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c026c8d5a2e188a7737ea902ae9c9f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a2c026c8d5a2e188a7737ea902ae9c9f1">ustring</a> (const std::wstring &amp;str, const allocator_type &amp;allocator) noexcept</td></tr>
<tr class="memdesc:a2c026c8d5a2e188a7737ea902ae9c9f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy and allocator.  <br /></td></tr>
<tr class="separator:a2c026c8d5a2e188a7737ea902ae9c9f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48913b4f219b6d5f73925a872be982fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a48913b4f219b6d5f73925a872be982fc">ustring</a> (const <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">wchar</a> *str)</td></tr>
<tr class="memdesc:a48913b4f219b6d5f73925a872be982fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:a48913b4f219b6d5f73925a872be982fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7517ca15654f917db3c61a018f6c42"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#abe7517ca15654f917db3c61a018f6c42">ustring</a> (const <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">wchar</a> *str, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:abe7517ca15654f917db3c61a018f6c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator.  <br /></td></tr>
<tr class="separator:abe7517ca15654f917db3c61a018f6c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1d3db0b384ec6bed989728bcc25dbb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ada1d3db0b384ec6bed989728bcc25dbb">ustring</a> (<a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">wchar</a> *str)</td></tr>
<tr class="memdesc:ada1d3db0b384ec6bed989728bcc25dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:ada1d3db0b384ec6bed989728bcc25dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3306353977a648613151dbbd634fa0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a9e3306353977a648613151dbbd634fa0">ustring</a> (<a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">wchar</a> *str, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a9e3306353977a648613151dbbd634fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator.  <br /></td></tr>
<tr class="separator:a9e3306353977a648613151dbbd634fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb84879a963d77159459e8aee6d21169"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#acb84879a963d77159459e8aee6d21169">ustring</a> (<a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&amp;str) noexcept</td></tr>
<tr class="memdesc:acb84879a963d77159459e8aee6d21169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to move.  <br /></td></tr>
<tr class="separator:acb84879a963d77159459e8aee6d21169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a96f03a62a5c045296bf62e3c4c31f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a50a96f03a62a5c045296bf62e3c4c31f">ustring</a> (<a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&amp;str, const allocator_type &amp;allocator) noexcept</td></tr>
<tr class="memdesc:a50a96f03a62a5c045296bf62e3c4c31f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to move and allocator.  <br /></td></tr>
<tr class="separator:a50a96f03a62a5c045296bf62e3c4c31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61f98b244908a02d90c8c6f6fcab6eb"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t &gt; </td></tr>
<tr class="memitem:ae61f98b244908a02d90c8c6f6fcab6eb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ae61f98b244908a02d90c8c6f6fcab6eb">ustring</a> (input_iterator_t first, input_iterator_t last)</td></tr>
<tr class="memdesc:ae61f98b244908a02d90c8c6f6fcab6eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified first and last iterators of substring.  <br /></td></tr>
<tr class="separator:ae61f98b244908a02d90c8c6f6fcab6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233f13e910222e1b5ca44df02b51e42f"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a233f13e910222e1b5ca44df02b51e42f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a233f13e910222e1b5ca44df02b51e42f">ustring</a> (input_iterator_t first, input_iterator_t last, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a233f13e910222e1b5ca44df02b51e42f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified first and last iterators of substring and allocator.  <br /></td></tr>
<tr class="separator:a233f13e910222e1b5ca44df02b51e42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4124167b2fe253847a09df705dda7af2"><td class="memTemplParams" colspan="2">template&lt;typename string_view_like_t &gt; </td></tr>
<tr class="memitem:a4124167b2fe253847a09df705dda7af2"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a4124167b2fe253847a09df705dda7af2">ustring</a> (const string_view_like_t &amp;string_view, const allocator_type &amp;allocator=allocator_type())</td></tr>
<tr class="memdesc:a4124167b2fe253847a09df705dda7af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string view of substring and allocator.  <br /></td></tr>
<tr class="separator:a4124167b2fe253847a09df705dda7af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08586c2e61560c82f8a5fef51b217273"><td class="memTemplParams" colspan="2">template&lt;typename string_view_like_t &gt; </td></tr>
<tr class="memitem:a08586c2e61560c82f8a5fef51b217273"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a08586c2e61560c82f8a5fef51b217273">ustring</a> (const string_view_like_t &amp;string_view, size_type index, size_type count, const allocator_type &amp;allocator=allocator_type())</td></tr>
<tr class="memdesc:a08586c2e61560c82f8a5fef51b217273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string view of substring and allocator.  <br /></td></tr>
<tr class="separator:a08586c2e61560c82f8a5fef51b217273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26be076083adc627f2908488f9d5cc01"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a26be076083adc627f2908488f9d5cc01">ustring</a> (std::initializer_list&lt; value_type &gt; il)</td></tr>
<tr class="memdesc:a26be076083adc627f2908488f9d5cc01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list.  <br /></td></tr>
<tr class="separator:a26be076083adc627f2908488f9d5cc01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015261e2eb18d2ac46ca692829cd164d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a015261e2eb18d2ac46ca692829cd164d">ustring</a> (std::initializer_list&lt; value_type &gt; il, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a015261e2eb18d2ac46ca692829cd164d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list and allocator.  <br /></td></tr>
<tr class="separator:a015261e2eb18d2ac46ca692829cd164d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5fac71387a4d3abb9f4b59cc89c735e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#af5fac71387a4d3abb9f4b59cc89c735e">ustring</a> (std::initializer_list&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">char8</a> &gt; il)</td></tr>
<tr class="memdesc:af5fac71387a4d3abb9f4b59cc89c735e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list.  <br /></td></tr>
<tr class="separator:af5fac71387a4d3abb9f4b59cc89c735e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68c91b16568d7b858245097921a3f3a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ad68c91b16568d7b858245097921a3f3a">ustring</a> (std::initializer_list&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">char8</a> &gt; il, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:ad68c91b16568d7b858245097921a3f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list and allocator.  <br /></td></tr>
<tr class="separator:ad68c91b16568d7b858245097921a3f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f312b06fc60075660894c4dea4c74a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a0f312b06fc60075660894c4dea4c74a1">ustring</a> (std::initializer_list&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">char16</a> &gt; il)</td></tr>
<tr class="memdesc:a0f312b06fc60075660894c4dea4c74a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list.  <br /></td></tr>
<tr class="separator:a0f312b06fc60075660894c4dea4c74a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6aad2bc1f2f7e8dd9e00cda60768c71"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#af6aad2bc1f2f7e8dd9e00cda60768c71">ustring</a> (std::initializer_list&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">char16</a> &gt; il, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:af6aad2bc1f2f7e8dd9e00cda60768c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list and allocator.  <br /></td></tr>
<tr class="separator:af6aad2bc1f2f7e8dd9e00cda60768c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32687b04f00204cda172df185578ae8d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a32687b04f00204cda172df185578ae8d">ustring</a> (std::initializer_list&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">char32</a> &gt; il)</td></tr>
<tr class="memdesc:a32687b04f00204cda172df185578ae8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list.  <br /></td></tr>
<tr class="separator:a32687b04f00204cda172df185578ae8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53aab32b6c83dc89748c8e85e4aaac88"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a53aab32b6c83dc89748c8e85e4aaac88">ustring</a> (std::initializer_list&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">char32</a> &gt; il, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a53aab32b6c83dc89748c8e85e4aaac88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list and allocator.  <br /></td></tr>
<tr class="separator:a53aab32b6c83dc89748c8e85e4aaac88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae818479b53ee91eb8ebbcd27712e9643"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ae818479b53ee91eb8ebbcd27712e9643">ustring</a> (std::initializer_list&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">wchar</a> &gt; il)</td></tr>
<tr class="memdesc:ae818479b53ee91eb8ebbcd27712e9643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list.  <br /></td></tr>
<tr class="separator:ae818479b53ee91eb8ebbcd27712e9643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305bcfad255f758ef9b7e19d6941e597"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a305bcfad255f758ef9b7e19d6941e597">ustring</a> (std::initializer_list&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">wchar</a> &gt; il, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a305bcfad255f758ef9b7e19d6941e597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list and allocator.  <br /></td></tr>
<tr class="separator:a305bcfad255f758ef9b7e19d6941e597"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Methods</h2></td></tr>
<tr class="memitem:a1a314847f67dc9eac2dbf5641b27a399"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a1a314847f67dc9eac2dbf5641b27a399">compare_to</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;tzi) const noexcept override</td></tr>
<tr class="memdesc:a1a314847f67dc9eac2dbf5641b27a399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the current instance with another object of the same type.  <br /></td></tr>
<tr class="separator:a1a314847f67dc9eac2dbf5641b27a399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0e43190da2d939a59a911e46302af1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#aea0e43190da2d939a59a911e46302af1">contains</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;value) const noexcept</td></tr>
<tr class="memdesc:aea0e43190da2d939a59a911e46302af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a value indicating whether a specified substring occurs within this string.  <br /></td></tr>
<tr class="separator:aea0e43190da2d939a59a911e46302af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab816731931399d3b68f7a911e775d0f"><td class="memItemLeft" align="right" valign="top"><a id="aab816731931399d3b68f7a911e775d0f" name="aab816731931399d3b68f7a911e775d0f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>equals</b> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;tzi) const noexcept</td></tr>
<tr class="separator:aab816731931399d3b68f7a911e775d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66c2037568657029c2695e7c5d43d84"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ab66c2037568657029c2695e7c5d43d84">ends_with</a> (value_type value) const noexcept</td></tr>
<tr class="memdesc:ab66c2037568657029c2695e7c5d43d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the end of this string matches the specified character.  <br /></td></tr>
<tr class="separator:ab66c2037568657029c2695e7c5d43d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2372f570af43ddd632c3fdfbe43de030"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a2372f570af43ddd632c3fdfbe43de030">ends_with</a> (<a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">char8</a> value) const noexcept</td></tr>
<tr class="memdesc:a2372f570af43ddd632c3fdfbe43de030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the end of this string matches the specified character.  <br /></td></tr>
<tr class="separator:a2372f570af43ddd632c3fdfbe43de030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02f78ca99a3dfb0ee73bc0252b329b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ad02f78ca99a3dfb0ee73bc0252b329b0">ends_with</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;value) const noexcept</td></tr>
<tr class="memdesc:ad02f78ca99a3dfb0ee73bc0252b329b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the end of this string matches the specified string.  <br /></td></tr>
<tr class="separator:ad02f78ca99a3dfb0ee73bc0252b329b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d72ca87fc9bcdae5c8d3db042cdec9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ae9d72ca87fc9bcdae5c8d3db042cdec9">ends_with</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;value, bool ignore_case) const noexcept</td></tr>
<tr class="memdesc:ae9d72ca87fc9bcdae5c8d3db042cdec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the end of this string instance matches the specified string when compared using the specified culture.  <br /></td></tr>
<tr class="separator:ae9d72ca87fc9bcdae5c8d3db042cdec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fcc85777946011f389241af42b27aaf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a8fcc85777946011f389241af42b27aaf">ends_with</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;value, <a class="el" href="group__xtd__core.html#ga04dd6c532656e286dfbf2f9aea3d8ccd">xtd::string_comparison</a> comparison_type) const noexcept</td></tr>
<tr class="memdesc:a8fcc85777946011f389241af42b27aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the end of this string matches the specified string when compared using the specified comparison option.  <br /></td></tr>
<tr class="separator:a8fcc85777946011f389241af42b27aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80f25a3a363194532225ddacc53e663"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ab80f25a3a363194532225ddacc53e663">get_hash_code</a> () const noexcept override</td></tr>
<tr class="memdesc:ab80f25a3a363194532225ddacc53e663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the hash code for this string.  <br /></td></tr>
<tr class="separator:ab80f25a3a363194532225ddacc53e663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e9d6260703cb75dbff5a8e458083e3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a74e9d6260703cb75dbff5a8e458083e3">index_of</a> (value_type value) const noexcept</td></tr>
<tr class="memdesc:a74e9d6260703cb75dbff5a8e458083e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified character in this string.  <br /></td></tr>
<tr class="separator:a74e9d6260703cb75dbff5a8e458083e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde1d8ad0d05e9e769aaeb4510a993cb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#abde1d8ad0d05e9e769aaeb4510a993cb">index_of</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;value) const noexcept</td></tr>
<tr class="memdesc:abde1d8ad0d05e9e769aaeb4510a993cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified string in this string.  <br /></td></tr>
<tr class="separator:abde1d8ad0d05e9e769aaeb4510a993cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65748d612fa86854545f4627f8c63601"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a65748d612fa86854545f4627f8c63601">index_of</a> (value_type value, size_t start_index) const noexcept</td></tr>
<tr class="memdesc:a65748d612fa86854545f4627f8c63601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified character in this string. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:a65748d612fa86854545f4627f8c63601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af368ba7426298e88fd5b5dc5f06e4c6d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#af368ba7426298e88fd5b5dc5f06e4c6d">index_of</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;value, size_t start_index) const noexcept</td></tr>
<tr class="memdesc:af368ba7426298e88fd5b5dc5f06e4c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified character in this string. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:af368ba7426298e88fd5b5dc5f06e4c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00535c21a723c61d49790a98fc56ac58"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a00535c21a723c61d49790a98fc56ac58">index_of</a> (value_type value, size_t start_index, size_t count) const noexcept</td></tr>
<tr class="memdesc:a00535c21a723c61d49790a98fc56ac58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified character in this string. The search starts at a specified character position and examines a specified number of character positions.  <br /></td></tr>
<tr class="separator:a00535c21a723c61d49790a98fc56ac58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7e84685e335551dd4e9868c110b427"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#aec7e84685e335551dd4e9868c110b427">index_of</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;value, size_t start_index, size_t count) const noexcept</td></tr>
<tr class="memdesc:aec7e84685e335551dd4e9868c110b427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified character in this string. The search starts at a specified character position and examines a specified number of character positions.  <br /></td></tr>
<tr class="separator:aec7e84685e335551dd4e9868c110b427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f8ff481971c33c05ccc60ff7c2397e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a52f8ff481971c33c05ccc60ff7c2397e">index_of_any</a> (const std::vector&lt; value_type &gt; &amp;values) const noexcept</td></tr>
<tr class="memdesc:a52f8ff481971c33c05ccc60ff7c2397e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence in this instance of any character in a specified array of characters.  <br /></td></tr>
<tr class="separator:a52f8ff481971c33c05ccc60ff7c2397e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92268eec76bff7c4b3b33a7696cfb12a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a92268eec76bff7c4b3b33a7696cfb12a">index_of_any</a> (const std::vector&lt; value_type &gt; &amp;values, size_t start_index) const noexcept</td></tr>
<tr class="memdesc:a92268eec76bff7c4b3b33a7696cfb12a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:a92268eec76bff7c4b3b33a7696cfb12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ec9a7b572cc3e92aabafe3c6bed320"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ac8ec9a7b572cc3e92aabafe3c6bed320">index_of_any</a> (const std::vector&lt; value_type &gt; &amp;values, size_t start_index, size_t count) const noexcept</td></tr>
<tr class="memdesc:ac8ec9a7b572cc3e92aabafe3c6bed320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:ac8ec9a7b572cc3e92aabafe3c6bed320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb8bd971a50be1f16f8a60f1acc5e8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a4fb8bd971a50be1f16f8a60f1acc5e8e">insert</a> (size_t start_index, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;value) const noexcept</td></tr>
<tr class="memdesc:a4fb8bd971a50be1f16f8a60f1acc5e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a specified instance of string at a specified index position in this instance.  <br /></td></tr>
<tr class="separator:a4fb8bd971a50be1f16f8a60f1acc5e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22354e7aab0bf4e272fcc3d48095e950"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a22354e7aab0bf4e272fcc3d48095e950">is_empty</a> () const noexcept</td></tr>
<tr class="memdesc:a22354e7aab0bf4e272fcc3d48095e950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether this string is an empty string ("").  <br /></td></tr>
<tr class="separator:a22354e7aab0bf4e272fcc3d48095e950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6d810543949e28650f92b5206314a5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a1d6d810543949e28650f92b5206314a5">last_index_of</a> (value_type value) const noexcept</td></tr>
<tr class="memdesc:a1d6d810543949e28650f92b5206314a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified character in this tring.  <br /></td></tr>
<tr class="separator:a1d6d810543949e28650f92b5206314a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8adab244b1165d2d9b849a39cf8ff55d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a8adab244b1165d2d9b849a39cf8ff55d">last_index_of</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;value) const noexcept</td></tr>
<tr class="memdesc:a8adab244b1165d2d9b849a39cf8ff55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified string in this string.  <br /></td></tr>
<tr class="separator:a8adab244b1165d2d9b849a39cf8ff55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0899fdfb944945fe56abf5b74b4716"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a2c0899fdfb944945fe56abf5b74b4716">last_index_of</a> (value_type value, size_t start_index) const noexcept</td></tr>
<tr class="memdesc:a2c0899fdfb944945fe56abf5b74b4716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified character in this string. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:a2c0899fdfb944945fe56abf5b74b4716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120c87d0c32977516fe5f31ed968a541"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a120c87d0c32977516fe5f31ed968a541">last_index_of</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;value, size_t start_index) const noexcept</td></tr>
<tr class="memdesc:a120c87d0c32977516fe5f31ed968a541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified character in this string. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:a120c87d0c32977516fe5f31ed968a541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32dc6a0c560aa072d8ce83151530a75"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ab32dc6a0c560aa072d8ce83151530a75">last_index_of</a> (value_type value, size_t start_index, size_t count) const noexcept</td></tr>
<tr class="memdesc:ab32dc6a0c560aa072d8ce83151530a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified character in this string. The search starts at a specified character position and examines a specified number of character positions.  <br /></td></tr>
<tr class="separator:ab32dc6a0c560aa072d8ce83151530a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125ebf9aadb1dc5948f57b0aca64b72a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a125ebf9aadb1dc5948f57b0aca64b72a">last_index_of</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;value, size_t start_index, size_t count) const noexcept</td></tr>
<tr class="memdesc:a125ebf9aadb1dc5948f57b0aca64b72a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified character in this string. The search starts at a specified character position and examines a specified number of character positions.  <br /></td></tr>
<tr class="separator:a125ebf9aadb1dc5948f57b0aca64b72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088f6faf6f0d3d4df9702c4185b04a30"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a088f6faf6f0d3d4df9702c4185b04a30">last_index_of_any</a> (const std::vector&lt; value_type &gt; &amp;values) const noexcept</td></tr>
<tr class="memdesc:a088f6faf6f0d3d4df9702c4185b04a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence in this instance of any character in a specified array of characters.  <br /></td></tr>
<tr class="separator:a088f6faf6f0d3d4df9702c4185b04a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4834f48993ac33b74f95069aa16357"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#aec4834f48993ac33b74f95069aa16357">last_index_of_any</a> (const std::vector&lt; value_type &gt; &amp;values, size_t start_index) const noexcept</td></tr>
<tr class="memdesc:aec4834f48993ac33b74f95069aa16357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:aec4834f48993ac33b74f95069aa16357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945e24afee50977935bd3aca1cdddb6a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a945e24afee50977935bd3aca1cdddb6a">last_index_of_any</a> (const std::vector&lt; value_type &gt; &amp;values, size_t start_index, size_t count) const noexcept</td></tr>
<tr class="memdesc:a945e24afee50977935bd3aca1cdddb6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:a945e24afee50977935bd3aca1cdddb6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadfe62deb046bd17790cb22207d4f4f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#aadfe62deb046bd17790cb22207d4f4f5">pad_left</a> (size_t total_width) const noexcept</td></tr>
<tr class="memdesc:aadfe62deb046bd17790cb22207d4f4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-aligns the characters in this string, padding with spaces on the left for a specified total length.  <br /></td></tr>
<tr class="separator:aadfe62deb046bd17790cb22207d4f4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1d40bffb5a673ecdb6f13fdf19d954"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a3a1d40bffb5a673ecdb6f13fdf19d954">pad_left</a> (size_t total_width, value_type padding_char) const noexcept</td></tr>
<tr class="memdesc:a3a1d40bffb5a673ecdb6f13fdf19d954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-aligns the characters in this string, padding with spaces on the left for a specified total length.  <br /></td></tr>
<tr class="separator:a3a1d40bffb5a673ecdb6f13fdf19d954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9abb16d8b680c650dd5cad88b8ecdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a7b9abb16d8b680c650dd5cad88b8ecdb">pad_right</a> (size_t total_width) const noexcept</td></tr>
<tr class="memdesc:a7b9abb16d8b680c650dd5cad88b8ecdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-aligns the characters in this string, padding with spaces on the right for a specified total length.  <br /></td></tr>
<tr class="separator:a7b9abb16d8b680c650dd5cad88b8ecdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4acf4abd79ff8bc4eb2b2b314273084b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a4acf4abd79ff8bc4eb2b2b314273084b">pad_right</a> (size_t total_width, value_type padding_char) const noexcept</td></tr>
<tr class="memdesc:a4acf4abd79ff8bc4eb2b2b314273084b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-aligns the characters in this string, padding with spaces on the right for a specified total length.  <br /></td></tr>
<tr class="separator:a4acf4abd79ff8bc4eb2b2b314273084b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30038c25718a196b702d8b85bc6b8aff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a30038c25718a196b702d8b85bc6b8aff">quoted</a> () const</td></tr>
<tr class="memdesc:a30038c25718a196b702d8b85bc6b8aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows insertion and extraction of quoted strings, such as the ones found in <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> or <a href="https://en.wikipedia.org/wiki/XML">XML</a>.  <br /></td></tr>
<tr class="separator:a30038c25718a196b702d8b85bc6b8aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf62a947cf88677831458c42b12d88ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#adf62a947cf88677831458c42b12d88ce">quoted</a> (value_type delimiter, value_type <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae0ebc3c409070d07f1df0f2f4132509e">escape</a>) const</td></tr>
<tr class="memdesc:adf62a947cf88677831458c42b12d88ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows insertion and extraction of quoted strings, such as the ones found in <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> or <a href="https://en.wikipedia.org/wiki/XML">XML</a> ith specified delimiter and escape.  <br /></td></tr>
<tr class="separator:adf62a947cf88677831458c42b12d88ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e0a7ed099484646436a14ef1279ab5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ac9e0a7ed099484646436a14ef1279ab5">remove</a> (size_t start_index) const noexcept</td></tr>
<tr class="memdesc:ac9e0a7ed099484646436a14ef1279ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all the characters from this string beginning at a specified position and continuing through the last position.  <br /></td></tr>
<tr class="separator:ac9e0a7ed099484646436a14ef1279ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a41355798abb8ab801e4709afae16c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a02a41355798abb8ab801e4709afae16c">remove</a> (size_t start_index, size_t count) const noexcept</td></tr>
<tr class="memdesc:a02a41355798abb8ab801e4709afae16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all the characters from this string beginning at a specified position and continuing through the last position.  <br /></td></tr>
<tr class="separator:a02a41355798abb8ab801e4709afae16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f47776cd7a5e8b7137138c83e12c53d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a8f47776cd7a5e8b7137138c83e12c53d">replace</a> (value_type old_char, value_type new_char) const noexcept</td></tr>
<tr class="memdesc:a8f47776cd7a5e8b7137138c83e12c53d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all occurrences of a specified char_t in this string with another specified char_t.  <br /></td></tr>
<tr class="separator:a8f47776cd7a5e8b7137138c83e12c53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35618679cb579be47165cda420847c0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a35618679cb579be47165cda420847c0b">replace</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;old_string, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;new_string) const noexcept</td></tr>
<tr class="memdesc:a35618679cb579be47165cda420847c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all occurrences of a specified string in this string with another specified string.  <br /></td></tr>
<tr class="separator:a35618679cb579be47165cda420847c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cce1408f2ea06898b33f7427ad712b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classxtd_1_1ustring.html">ustring</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a65cce1408f2ea06898b33f7427ad712b">split</a> (const std::vector&lt; value_type &gt; &amp;separators, size_t count, <a class="el" href="group__xtd__core.html#ga1856f4f531626dc585fd1c8ccc6d596c">string_split_options</a> options) const noexcept</td></tr>
<tr class="memdesc:a65cce1408f2ea06898b33f7427ad712b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits this string into a maximum number of substrings based on the characters in an array.  <br /></td></tr>
<tr class="separator:a65cce1408f2ea06898b33f7427ad712b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b33020b0d948fe3946a3535e8f8458"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classxtd_1_1ustring.html">ustring</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a66b33020b0d948fe3946a3535e8f8458">split</a> () const noexcept</td></tr>
<tr class="memdesc:a66b33020b0d948fe3946a3535e8f8458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits this string into substrings that are based on the default white-space characters. White-space characters are defined by the c++ standard and return true if they are passed to the xtd::char_object::isspace() or std::iswspace() method.  <br /></td></tr>
<tr class="separator:a66b33020b0d948fe3946a3535e8f8458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accdcbabd839bcc9dcea46df7ad5a8a18"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classxtd_1_1ustring.html">ustring</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#accdcbabd839bcc9dcea46df7ad5a8a18">split</a> (const std::vector&lt; value_type &gt; &amp;separators) const noexcept</td></tr>
<tr class="memdesc:accdcbabd839bcc9dcea46df7ad5a8a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits this string into substrings that are based on the characters in an array.  <br /></td></tr>
<tr class="separator:accdcbabd839bcc9dcea46df7ad5a8a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d254b792df2455b4c27886cf65cdfa2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classxtd_1_1ustring.html">ustring</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a7d254b792df2455b4c27886cf65cdfa2">split</a> (const std::vector&lt; value_type &gt; &amp;separators, <a class="el" href="group__xtd__core.html#ga1856f4f531626dc585fd1c8ccc6d596c">string_split_options</a> options) const noexcept</td></tr>
<tr class="memdesc:a7d254b792df2455b4c27886cf65cdfa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits this string into substrings based on the characters in an array. You can specify whether the substrings include empty array elements.  <br /></td></tr>
<tr class="separator:a7d254b792df2455b4c27886cf65cdfa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd5fd437bfcbac1c20e589e62200780"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classxtd_1_1ustring.html">ustring</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a8cd5fd437bfcbac1c20e589e62200780">split</a> (const std::vector&lt; value_type &gt; &amp;separators, size_t count) const noexcept</td></tr>
<tr class="memdesc:a8cd5fd437bfcbac1c20e589e62200780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits this string into a maximum number of substrings based on the characters in an array. You also specify the maximum number of substrings to return.  <br /></td></tr>
<tr class="separator:a8cd5fd437bfcbac1c20e589e62200780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5334d81e1d6756cb0db9aeefeb5cea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ade5334d81e1d6756cb0db9aeefeb5cea">starts_with</a> (value_type value) const noexcept</td></tr>
<tr class="memdesc:ade5334d81e1d6756cb0db9aeefeb5cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the beginning of this instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> matches a specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>.  <br /></td></tr>
<tr class="separator:ade5334d81e1d6756cb0db9aeefeb5cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8892581c00c768b278d9657ed6aecf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a7c8892581c00c768b278d9657ed6aecf">starts_with</a> (value_type value, bool ignore_case) const noexcept</td></tr>
<tr class="memdesc:a7c8892581c00c768b278d9657ed6aecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the beginning of this instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> matches a specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>, ignoring or honoring their case.  <br /></td></tr>
<tr class="separator:a7c8892581c00c768b278d9657ed6aecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab847e62a85bbb1eb9044b9e8ebaead55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ab847e62a85bbb1eb9044b9e8ebaead55">starts_with</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;value) const noexcept</td></tr>
<tr class="memdesc:ab847e62a85bbb1eb9044b9e8ebaead55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the beginning of this instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> matches a specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>.  <br /></td></tr>
<tr class="separator:ab847e62a85bbb1eb9044b9e8ebaead55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98b6ee462e44358380fd35f8afb8994"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#af98b6ee462e44358380fd35f8afb8994">starts_with</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;value, bool ignore_case) const noexcept</td></tr>
<tr class="memdesc:af98b6ee462e44358380fd35f8afb8994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the beginning of this instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> matches a specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>, ignoring or honoring their case.  <br /></td></tr>
<tr class="separator:af98b6ee462e44358380fd35f8afb8994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27e596eab3904c5084c2d2cb7ae05a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ad27e596eab3904c5084c2d2cb7ae05a1">substring</a> (size_t start_index) const noexcept</td></tr>
<tr class="memdesc:ad27e596eab3904c5084c2d2cb7ae05a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a substring from this instance. The substring starts at a specified character position and has a specified length.  <br /></td></tr>
<tr class="separator:ad27e596eab3904c5084c2d2cb7ae05a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3036669570cf96cc74bc68aad2098e53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a3036669570cf96cc74bc68aad2098e53">substring</a> (size_t start_index, size_t length) const noexcept</td></tr>
<tr class="memdesc:a3036669570cf96cc74bc68aad2098e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a substring from this instance. The substring starts at a specified character position and has a specified length.  <br /></td></tr>
<tr class="separator:a3036669570cf96cc74bc68aad2098e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53db7e47ebfb9f700184263cdffe90fc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a53db7e47ebfb9f700184263cdffe90fc">to_array</a> () const noexcept</td></tr>
<tr class="memdesc:a53db7e47ebfb9f700184263cdffe90fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the characters in this instance to a Unicode character array.  <br /></td></tr>
<tr class="separator:a53db7e47ebfb9f700184263cdffe90fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf5c498288cf53e891ec8a3227cd013"><td class="memItemLeft" align="right" valign="top">std::vector&lt; value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#afbf5c498288cf53e891ec8a3227cd013">to_array</a> (size_t start_index) const noexcept</td></tr>
<tr class="memdesc:afbf5c498288cf53e891ec8a3227cd013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the characters in this instance to a Unicode character array starting at specified index.  <br /></td></tr>
<tr class="separator:afbf5c498288cf53e891ec8a3227cd013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e16fac35c5b5145b14c0d8fa5059313"><td class="memItemLeft" align="right" valign="top">std::vector&lt; value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a0e16fac35c5b5145b14c0d8fa5059313">to_array</a> (size_t start_index, size_t length) const noexcept</td></tr>
<tr class="memdesc:a0e16fac35c5b5145b14c0d8fa5059313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the characters in this instance to a Unicode character array starting at specified index with specified length.  <br /></td></tr>
<tr class="separator:a0e16fac35c5b5145b14c0d8fa5059313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af336a018fa7b2750e7cafe9dd708de4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#af336a018fa7b2750e7cafe9dd708de4b">to_lower</a> () const noexcept</td></tr>
<tr class="memdesc:af336a018fa7b2750e7cafe9dd708de4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the current string converted to lowercase.  <br /></td></tr>
<tr class="separator:af336a018fa7b2750e7cafe9dd708de4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e5a8801e4f4c333649a0920b13b4d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ae1e5a8801e4f4c333649a0920b13b4d7">to_string</a> () const noexcept override</td></tr>
<tr class="memdesc:ae1e5a8801e4f4c333649a0920b13b4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sxd::ustring that represents the current object.  <br /></td></tr>
<tr class="separator:ae1e5a8801e4f4c333649a0920b13b4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83cfd867b93120e50dc74d94081d0526"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a83cfd867b93120e50dc74d94081d0526">to_title_case</a> () const noexcept</td></tr>
<tr class="memdesc:a83cfd867b93120e50dc74d94081d0526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the current string to title case (except for words that are entirely in uppercase, which are considered to be acronyms).  <br /></td></tr>
<tr class="separator:a83cfd867b93120e50dc74d94081d0526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459c7cf5ab46bbce3088c6f8b0c87081"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a459c7cf5ab46bbce3088c6f8b0c87081">to_upper</a> () const noexcept</td></tr>
<tr class="memdesc:a459c7cf5ab46bbce3088c6f8b0c87081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the current string converted to uppercase.  <br /></td></tr>
<tr class="separator:a459c7cf5ab46bbce3088c6f8b0c87081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6521e1bcb7f90cc6e5678454c2488e0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a6521e1bcb7f90cc6e5678454c2488e0a">trim</a> () const noexcept</td></tr>
<tr class="memdesc:a6521e1bcb7f90cc6e5678454c2488e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all leading and trailing occurrences of white-space characters from the specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>.  <br /></td></tr>
<tr class="separator:a6521e1bcb7f90cc6e5678454c2488e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ee5015736be282dd15a37aed0dcb47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a47ee5015736be282dd15a37aed0dcb47">trim</a> (value_type trim_char) const noexcept</td></tr>
<tr class="memdesc:a47ee5015736be282dd15a37aed0dcb47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all leading and trailing occurrences of a character specified from the specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> .  <br /></td></tr>
<tr class="separator:a47ee5015736be282dd15a37aed0dcb47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201e55d40c55a79e7a10e884c2f472c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a201e55d40c55a79e7a10e884c2f472c1">trim</a> (const std::vector&lt; value_type &gt; &amp;trim_chars) const noexcept</td></tr>
<tr class="memdesc:a201e55d40c55a79e7a10e884c2f472c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all leading and trailing occurrences of a set of characters specified in an array from the specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>.  <br /></td></tr>
<tr class="separator:a201e55d40c55a79e7a10e884c2f472c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d193fc8b669cf1d49b92fd0fab9ed0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a6d193fc8b669cf1d49b92fd0fab9ed0f">trim_end</a> () const noexcept</td></tr>
<tr class="memdesc:a6d193fc8b669cf1d49b92fd0fab9ed0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all trailing occurrences of white-space characters from the specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>.  <br /></td></tr>
<tr class="separator:a6d193fc8b669cf1d49b92fd0fab9ed0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa517a64d866a66f04511e9bad2d2af35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#aa517a64d866a66f04511e9bad2d2af35">trim_end</a> (value_type trim_char) const noexcept</td></tr>
<tr class="memdesc:aa517a64d866a66f04511e9bad2d2af35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all trailing occurrences of a character specified from the specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> .  <br /></td></tr>
<tr class="separator:aa517a64d866a66f04511e9bad2d2af35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf27752e3802e2d62fd358004b5c419e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#abf27752e3802e2d62fd358004b5c419e">trim_end</a> (const std::vector&lt; value_type &gt; &amp;trim_chars) const noexcept</td></tr>
<tr class="memdesc:abf27752e3802e2d62fd358004b5c419e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all trailing occurrences of a set of characters specified in an array from the specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>.  <br /></td></tr>
<tr class="separator:abf27752e3802e2d62fd358004b5c419e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8778eb32e44c58c7f9576cd2bf5bfceb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a8778eb32e44c58c7f9576cd2bf5bfceb">trim_start</a> () const noexcept</td></tr>
<tr class="memdesc:a8778eb32e44c58c7f9576cd2bf5bfceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all leading occurrences of white-space characters from the specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>.  <br /></td></tr>
<tr class="separator:a8778eb32e44c58c7f9576cd2bf5bfceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5bc64baa95dea6d1d28d79438899a31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#af5bc64baa95dea6d1d28d79438899a31">trim_start</a> (value_type trim_char) const noexcept</td></tr>
<tr class="memdesc:af5bc64baa95dea6d1d28d79438899a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all leading occurrences of a character specified from the specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> .  <br /></td></tr>
<tr class="separator:af5bc64baa95dea6d1d28d79438899a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb88ae933c826a42b98beab955d0199"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#aceb88ae933c826a42b98beab955d0199">trim_start</a> (const std::vector&lt; value_type &gt; &amp;trim_chars) const noexcept</td></tr>
<tr class="memdesc:aceb88ae933c826a42b98beab955d0199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all leading occurrences of a set of characters specified in an array from the specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>.  <br /></td></tr>
<tr class="separator:aceb88ae933c826a42b98beab955d0199"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Static Methods</h2></td></tr>
<tr class="memitem:aafaae6b32a8bbfc8cd20defa2b14dc88"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:aafaae6b32a8bbfc8cd20defa2b14dc88"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#aafaae6b32a8bbfc8cd20defa2b14dc88">class_name</a> ()</td></tr>
<tr class="memdesc:aafaae6b32a8bbfc8cd20defa2b14dc88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the class name of the object_t.  <br /></td></tr>
<tr class="separator:aafaae6b32a8bbfc8cd20defa2b14dc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf26167d0f67d103c069fb005063234"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:a5bf26167d0f67d103c069fb005063234"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a5bf26167d0f67d103c069fb005063234">class_name</a> (const object_t &amp;<a class="el" href="classxtd_1_1object.html">object</a>)</td></tr>
<tr class="memdesc:a5bf26167d0f67d103c069fb005063234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the class name of the specified object.  <br /></td></tr>
<tr class="separator:a5bf26167d0f67d103c069fb005063234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4bcd6d2d8749fb41e52c3c7152fe13"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a7e4bcd6d2d8749fb41e52c3c7152fe13">class_name</a> (const std::type_info &amp;info)</td></tr>
<tr class="memdesc:a7e4bcd6d2d8749fb41e52c3c7152fe13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the class name of the specified object.  <br /></td></tr>
<tr class="separator:a7e4bcd6d2d8749fb41e52c3c7152fe13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435ca143c948bc8c0c009dabe7de1b6b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a435ca143c948bc8c0c009dabe7de1b6b">compare</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_a, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_b) noexcept</td></tr>
<tr class="memdesc:a435ca143c948bc8c0c009dabe7de1b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two specified string objects and returns an integer that indicates their relative position in the sort order.  <br /></td></tr>
<tr class="separator:a435ca143c948bc8c0c009dabe7de1b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb0a2f5d602d354209cd0caadc877be"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#addb0a2f5d602d354209cd0caadc877be">compare</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_a, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_b, bool ignore_case) noexcept</td></tr>
<tr class="memdesc:addb0a2f5d602d354209cd0caadc877be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two specified string objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.  <br /></td></tr>
<tr class="separator:addb0a2f5d602d354209cd0caadc877be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382561d2de4a607ed95d4dde301a7819"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a382561d2de4a607ed95d4dde301a7819">compare</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_a, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_b, <a class="el" href="group__xtd__core.html#ga04dd6c532656e286dfbf2f9aea3d8ccd">xtd::string_comparison</a> comparison_type) noexcept</td></tr>
<tr class="memdesc:a382561d2de4a607ed95d4dde301a7819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two specified string objects using the specified rules, and returns an integer that indicates their relative position in the sort order.  <br /></td></tr>
<tr class="separator:a382561d2de4a607ed95d4dde301a7819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6bb2d780afdc3e716093efab129e854"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ab6bb2d780afdc3e716093efab129e854">compare</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_a, size_t index_a, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_b, size_t index_b, size_t length) noexcept</td></tr>
<tr class="memdesc:ab6bb2d780afdc3e716093efab129e854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares substrings of two specified string objects and returns an integer that indicates their relative position in the sort order.  <br /></td></tr>
<tr class="separator:ab6bb2d780afdc3e716093efab129e854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4786c9c92df32605ec81fa750e8a48"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#afb4786c9c92df32605ec81fa750e8a48">compare</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_a, size_t index_a, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_b, size_t index_b, size_t length, bool ignore_case) noexcept</td></tr>
<tr class="memdesc:afb4786c9c92df32605ec81fa750e8a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares substrings of two specified string objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.  <br /></td></tr>
<tr class="separator:afb4786c9c92df32605ec81fa750e8a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5dc8585f020077b629282c61a8d391"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#afb5dc8585f020077b629282c61a8d391">compare</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_a, size_t index_a, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_b, size_t index_b, size_t length, <a class="el" href="group__xtd__core.html#ga04dd6c532656e286dfbf2f9aea3d8ccd">xtd::string_comparison</a> comparison_type) noexcept</td></tr>
<tr class="memdesc:afb5dc8585f020077b629282c61a8d391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares substrings of two specified string objects using the specified rules, and returns an integer that indicates their relative position in the sort order.  <br /></td></tr>
<tr class="separator:afb5dc8585f020077b629282c61a8d391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d492d6b9ce2f2e38661a5062009a32f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a9d492d6b9ce2f2e38661a5062009a32f">concat</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_a, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_b, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_c, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_d) noexcept</td></tr>
<tr class="memdesc:a9d492d6b9ce2f2e38661a5062009a32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates four specified instances of string.  <br /></td></tr>
<tr class="separator:a9d492d6b9ce2f2e38661a5062009a32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745ec7372c85f6c9126b26d010f4ea97"><td class="memTemplParams" colspan="2">template&lt;typename object_a_t , typename object_b_t , typename object_c_t , typename object_d_t &gt; </td></tr>
<tr class="memitem:a745ec7372c85f6c9126b26d010f4ea97"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a745ec7372c85f6c9126b26d010f4ea97">concat</a> (object_a_t obj_a, object_b_t obj_b, object_c_t obj_c, object_d_t obj_d) noexcept</td></tr>
<tr class="memdesc:a745ec7372c85f6c9126b26d010f4ea97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates four specified instances of object.  <br /></td></tr>
<tr class="separator:a745ec7372c85f6c9126b26d010f4ea97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceda089f7586a63df656566d0c815d22"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#aceda089f7586a63df656566d0c815d22">concat</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_a, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_b, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_c) noexcept</td></tr>
<tr class="memdesc:aceda089f7586a63df656566d0c815d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates three specified instances of string.  <br /></td></tr>
<tr class="separator:aceda089f7586a63df656566d0c815d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06bc47f8af41673e7f3d89c57c9cd525"><td class="memTemplParams" colspan="2">template&lt;typename object_a_t , typename object_b_t , typename object_c_t &gt; </td></tr>
<tr class="memitem:a06bc47f8af41673e7f3d89c57c9cd525"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a06bc47f8af41673e7f3d89c57c9cd525">concat</a> (object_a_t obj_a, object_b_t obj_b, object_c_t obj_c) noexcept</td></tr>
<tr class="memdesc:a06bc47f8af41673e7f3d89c57c9cd525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates three specified instances of object.  <br /></td></tr>
<tr class="separator:a06bc47f8af41673e7f3d89c57c9cd525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84e9e74970e64e21a97afee579ed6f3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ae84e9e74970e64e21a97afee579ed6f3">concat</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_a, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_b) noexcept</td></tr>
<tr class="memdesc:ae84e9e74970e64e21a97afee579ed6f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two specified instances of string.  <br /></td></tr>
<tr class="separator:ae84e9e74970e64e21a97afee579ed6f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7018e6a7dce9dcf133a1e393b2152ec"><td class="memTemplParams" colspan="2">template&lt;typename object_a_t , typename object_b_t &gt; </td></tr>
<tr class="memitem:aa7018e6a7dce9dcf133a1e393b2152ec"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#aa7018e6a7dce9dcf133a1e393b2152ec">concat</a> (object_a_t obj_a, object_b_t obj_b) noexcept</td></tr>
<tr class="memdesc:aa7018e6a7dce9dcf133a1e393b2152ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two specified instances of object.  <br /></td></tr>
<tr class="separator:aa7018e6a7dce9dcf133a1e393b2152ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb605ccce66373c790611a13db14f14c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#acb605ccce66373c790611a13db14f14c">concat</a> (const std::vector&lt; <a class="el" href="classxtd_1_1ustring.html">ustring</a> &gt; &amp;values) noexcept</td></tr>
<tr class="memdesc:acb605ccce66373c790611a13db14f14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates the elements of a specified string array.  <br /></td></tr>
<tr class="separator:acb605ccce66373c790611a13db14f14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f9f5b6643bb4527a966f6ce1f4f6fd"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:a80f9f5b6643bb4527a966f6ce1f4f6fd"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a80f9f5b6643bb4527a966f6ce1f4f6fd">concat</a> (const std::vector&lt; object_t &gt; &amp;args) noexcept</td></tr>
<tr class="memdesc:a80f9f5b6643bb4527a966f6ce1f4f6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates the string representations of the elements in a specified object array.  <br /></td></tr>
<tr class="separator:a80f9f5b6643bb4527a966f6ce1f4f6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3378d826fc5381609746ce3618084157"><td class="memTemplParams" colspan="2">template&lt;typename value_t &gt; </td></tr>
<tr class="memitem:a3378d826fc5381609746ce3618084157"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a3378d826fc5381609746ce3618084157">concat</a> (value_t value) noexcept</td></tr>
<tr class="memdesc:a3378d826fc5381609746ce3618084157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the string representation of a specified object.  <br /></td></tr>
<tr class="separator:a3378d826fc5381609746ce3618084157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238165aaab69fb9f6c909da1fcdb072f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a238165aaab69fb9f6c909da1fcdb072f">demangle</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;name)</td></tr>
<tr class="memdesc:a238165aaab69fb9f6c909da1fcdb072f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets demangled string of name,.  <br /></td></tr>
<tr class="separator:a238165aaab69fb9f6c909da1fcdb072f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3afd6d163bc6391a48a1f84f28a68ffd"><td class="memTemplParams" colspan="2">template&lt;typename ... args_t&gt; </td></tr>
<tr class="memitem:ga3afd6d163bc6391a48a1f84f28a68ffd"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__format__parse.html#ga3afd6d163bc6391a48a1f84f28a68ffd">format</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;fmt, args_t &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga3afd6d163bc6391a48a1f84f28a68ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the text representation of the specified arguments list, to string using the specified format information.  <br /></td></tr>
<tr class="separator:ga3afd6d163bc6391a48a1f84f28a68ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a65b727872715c7b99958e84a75f61"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:aa6a65b727872715c7b99958e84a75f61"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#aa6a65b727872715c7b99958e84a75f61">full_class_name</a> ()</td></tr>
<tr class="memdesc:aa6a65b727872715c7b99958e84a75f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the fully qualified class name of the objec_t, including the namespace of the objec_t.  <br /></td></tr>
<tr class="separator:aa6a65b727872715c7b99958e84a75f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a0eee00e7f757562565f8e19c7747d"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:a81a0eee00e7f757562565f8e19c7747d"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a81a0eee00e7f757562565f8e19c7747d">full_class_name</a> (const object_t &amp;<a class="el" href="classxtd_1_1object.html">object</a>)</td></tr>
<tr class="memdesc:a81a0eee00e7f757562565f8e19c7747d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the fully qualified class name of the specified object, including the namespace of the specified object.  <br /></td></tr>
<tr class="separator:a81a0eee00e7f757562565f8e19c7747d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c639795fa939f9ccf93342b5a76e45"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#af9c639795fa939f9ccf93342b5a76e45">full_class_name</a> (const std::type_info &amp;info)</td></tr>
<tr class="memdesc:af9c639795fa939f9ccf93342b5a76e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the fully qualified class name of the specified object, including the namespace of the specified object.  <br /></td></tr>
<tr class="separator:af9c639795fa939f9ccf93342b5a76e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479cbb69619f996515fea1599a5e54df"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a479cbb69619f996515fea1599a5e54df">is_empty</a> (const <a class="el" href="classxtd_1_1ustring.html">xtd::ustring</a> &amp;string) noexcept</td></tr>
<tr class="memdesc:a479cbb69619f996515fea1599a5e54df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the specifeid string is an empty string ("").  <br /></td></tr>
<tr class="separator:a479cbb69619f996515fea1599a5e54df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95694998a854ba65dde682b879eec355"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:a95694998a854ba65dde682b879eec355"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a95694998a854ba65dde682b879eec355">join</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2aa0f0bc95016c862498bbad29d1f4d9d4">separator</a>, const collection_t &amp;values) noexcept</td></tr>
<tr class="memdesc:a95694998a854ba65dde682b879eec355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates a specified separator string between each element of a specified object array, yielding a single concatenated string.  <br /></td></tr>
<tr class="separator:a95694998a854ba65dde682b879eec355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37001c9de58f2a351850d0fb3fce995"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:ae37001c9de58f2a351850d0fb3fce995"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ae37001c9de58f2a351850d0fb3fce995">join</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2aa0f0bc95016c862498bbad29d1f4d9d4">separator</a>, const collection_t &amp;values, size_t index) noexcept</td></tr>
<tr class="memdesc:ae37001c9de58f2a351850d0fb3fce995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates a specified separator string between each element of a specified object array, yielding a single concatenated string.  <br /></td></tr>
<tr class="separator:ae37001c9de58f2a351850d0fb3fce995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506719218360ffaff29724ee5f15a5ff"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:a506719218360ffaff29724ee5f15a5ff"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a506719218360ffaff29724ee5f15a5ff">join</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2aa0f0bc95016c862498bbad29d1f4d9d4">separator</a>, const collection_t &amp;values, size_t index, size_t count) noexcept</td></tr>
<tr class="memdesc:a506719218360ffaff29724ee5f15a5ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates a specified separator string between each element of a specified Object array, yielding a single concatenated string.  <br /></td></tr>
<tr class="separator:a506719218360ffaff29724ee5f15a5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90aeac5b1761195838734b45d1268dd3"><td class="memTemplParams" colspan="2">template&lt;typename value_t &gt; </td></tr>
<tr class="memitem:a90aeac5b1761195838734b45d1268dd3"><td class="memTemplItemLeft" align="right" valign="top">static value_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a90aeac5b1761195838734b45d1268dd3">parse</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str)</td></tr>
<tr class="memdesc:a90aeac5b1761195838734b45d1268dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string into a value_t type.  <br /></td></tr>
<tr class="separator:a90aeac5b1761195838734b45d1268dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c65606fb81f84e4d9ea43002114d8de"><td class="memTemplParams" colspan="2">template&lt;typename ... args_t&gt; </td></tr>
<tr class="memitem:ga0c65606fb81f84e4d9ea43002114d8de"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__format__parse.html#ga0c65606fb81f84e4d9ea43002114d8de">sprintf</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;fmt, args_t &amp;&amp;... args) noexcept</td></tr>
<tr class="memdesc:ga0c65606fb81f84e4d9ea43002114d8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the text representation of the specified arguments list, to string using the specified format information.  <br /></td></tr>
<tr class="separator:ga0c65606fb81f84e4d9ea43002114d8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f18368ae92eefe4fe5eb5125d0f02bb"><td class="memTemplParams" colspan="2">template&lt;typename value_t &gt; </td></tr>
<tr class="memitem:a6f18368ae92eefe4fe5eb5125d0f02bb"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a6f18368ae92eefe4fe5eb5125d0f02bb">try_parse</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str, value_t &amp;value) noexcept</td></tr>
<tr class="memdesc:a6f18368ae92eefe4fe5eb5125d0f02bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to convert a string into a value_t type.  <br /></td></tr>
<tr class="separator:a6f18368ae92eefe4fe5eb5125d0f02bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1object.html">xtd::object</a></td></tr>
<tr class="memitem:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ad2cab851376bb6ca085b567bf5da0f5f">object</a> ()=default</td></tr>
<tr class="memdesc:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of the ultimate base class object.  <br /></td></tr>
<tr class="separator:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8027c211754118c30ccf7e52557fd7a inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#aa8027c211754118c30ccf7e52557fd7a">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;obj) const noexcept</td></tr>
<tr class="memdesc:aa8027c211754118c30ccf7e52557fd7a inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object is equal to the current object.  <br /></td></tr>
<tr class="separator:aa8027c211754118c30ccf7e52557fd7a inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1type__object.html">type_object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a322144840e8ad539c039538997b0fe40">get_type</a> () const noexcept</td></tr>
<tr class="memdesc:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the current instance.  <br /></td></tr>
<tr class="separator:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af734e36ea583a842339d7c4444fb6d86 inherit pub_methods_classxtd_1_1object"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:af734e36ea583a842339d7c4444fb6d86 inherit pub_methods_classxtd_1_1object"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; object_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#af734e36ea583a842339d7c4444fb6d86">memberwise_clone</a> () const noexcept</td></tr>
<tr class="memdesc:af734e36ea583a842339d7c4444fb6d86 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shallow copy of the current object.  <br /></td></tr>
<tr class="separator:af734e36ea583a842339d7c4444fb6d86 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1icomparable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1icomparable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1icomparable.html">xtd::icomparable&lt; ustring &gt;</a></td></tr>
<tr class="inherit_header pub_static_methods_classxtd_1_1object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classxtd_1_1object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classxtd_1_1object.html">xtd::object</a></td></tr>
<tr class="memitem:a75cb9ed56172fb088ca6697d5d836b13 inherit pub_static_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a75cb9ed56172fb088ca6697d5d836b13">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_a, const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a75cb9ed56172fb088ca6697d5d836b13 inherit pub_static_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are considered equal.  <br /></td></tr>
<tr class="separator:a75cb9ed56172fb088ca6697d5d836b13 inherit pub_static_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee13700465eead7934f450749b952d7 inherit pub_static_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a1ee13700465eead7934f450749b952d7">reference_equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_a, const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a1ee13700465eead7934f450749b952d7 inherit pub_static_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are the same instance.  <br /></td></tr>
<tr class="separator:a1ee13700465eead7934f450749b952d7 inherit pub_static_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="add61d5146149ee689a7f9bed1309cfad" name="add61d5146149ee689a7f9bed1309cfad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add61d5146149ee689a7f9bed1309cfad">&#9670;&#160;</a></span>ustring() <span class="overload">[1/66]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>. </p>

</div>
</div>
<a id="a08170f266741991ebf47b057a34ba124" name="a08170f266741991ebf47b057a34ba124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08170f266741991ebf47b057a34ba124">&#9670;&#160;</a></span>ustring() <span class="overload">[2/66]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09c6e9bc0de28607372aa298e5886f84" name="a09c6e9bc0de28607372aa298e5886f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c6e9bc0de28607372aa298e5886f84">&#9670;&#160;</a></span>ustring() <span class="overload">[3/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>character</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94c19dfade464033be0ffb4e86fb1ead" name="a94c19dfade464033be0ffb4e86fb1ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c19dfade464033be0ffb4e86fb1ead">&#9670;&#160;</a></span>ustring() <span class="overload">[4/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character and specified allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60eed64a348bd421e9fea1488611c2a4" name="a60eed64a348bd421e9fea1488611c2a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60eed64a348bd421e9fea1488611c2a4">&#9670;&#160;</a></span>ustring() <span class="overload">[5/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">char8</a>&#160;</td>
          <td class="paramname"><em>character</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5db46f55794c8f7ed6ce44a44c5aa87" name="ae5db46f55794c8f7ed6ce44a44c5aa87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5db46f55794c8f7ed6ce44a44c5aa87">&#9670;&#160;</a></span>ustring() <span class="overload">[6/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">char8</a>&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character and specified allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e8a8bc83d8eca6678303fc24e13b85c" name="a2e8a8bc83d8eca6678303fc24e13b85c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e8a8bc83d8eca6678303fc24e13b85c">&#9670;&#160;</a></span>ustring() <span class="overload">[7/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">char16</a>&#160;</td>
          <td class="paramname"><em>character</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b5c3469299d8c2db3306edcb65b091e" name="a6b5c3469299d8c2db3306edcb65b091e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b5c3469299d8c2db3306edcb65b091e">&#9670;&#160;</a></span>ustring() <span class="overload">[8/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">char16</a>&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character and specified allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad580a4e34ed9845fcc962357cdb43c91" name="ad580a4e34ed9845fcc962357cdb43c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad580a4e34ed9845fcc962357cdb43c91">&#9670;&#160;</a></span>ustring() <span class="overload">[9/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">char32</a>&#160;</td>
          <td class="paramname"><em>character</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c2353536a07382b5d45accaadb5f203" name="a0c2353536a07382b5d45accaadb5f203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2353536a07382b5d45accaadb5f203">&#9670;&#160;</a></span>ustring() <span class="overload">[10/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">char32</a>&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character and specified allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44be94c61a89e56b681e1c765de9591c" name="a44be94c61a89e56b681e1c765de9591c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44be94c61a89e56b681e1c765de9591c">&#9670;&#160;</a></span>ustring() <span class="overload">[11/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">wchar</a>&#160;</td>
          <td class="paramname"><em>character</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf3b1d1f4a121d8cc3ad14d6a8710e96" name="acf3b1d1f4a121d8cc3ad14d6a8710e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf3b1d1f4a121d8cc3ad14d6a8710e96">&#9670;&#160;</a></span>ustring() <span class="overload">[12/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">wchar</a>&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character and specified allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09e9d9b1b3d1dd5c2431aff1fb936b34" name="a09e9d9b1b3d1dd5c2431aff1fb936b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e9d9b1b3d1dd5c2431aff1fb936b34">&#9670;&#160;</a></span>ustring() <span class="overload">[13/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified substring at index and count characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a961a9ba4c72a3ef7e30ce00744fab282" name="a961a9ba4c72a3ef7e30ce00744fab282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961a9ba4c72a3ef7e30ce00744fab282">&#9670;&#160;</a></span>ustring() <span class="overload">[14/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified substring at index, count characters and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0dd03c9c81d6dcf7686bf80ef7183b0" name="ac0dd03c9c81d6dcf7686bf80ef7183b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0dd03c9c81d6dcf7686bf80ef7183b0">&#9670;&#160;</a></span>ustring() <span class="overload">[15/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified substring at index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a378a1ead97b2b5db84cc20e6dfd0a71d" name="a378a1ead97b2b5db84cc20e6dfd0a71d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a378a1ead97b2b5db84cc20e6dfd0a71d">&#9670;&#160;</a></span>ustring() <span class="overload">[16/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified substring at index and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a175105db0d4fd8d70afd6bf68e901c43" name="a175105db0d4fd8d70afd6bf68e901c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a175105db0d4fd8d70afd6bf68e901c43">&#9670;&#160;</a></span>ustring() <span class="overload">[17/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const value_type *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified substring and count characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94daf332e8506577c406ff8be31a68ed" name="a94daf332e8506577c406ff8be31a68ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94daf332e8506577c406ff8be31a68ed">&#9670;&#160;</a></span>ustring() <span class="overload">[18/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const value_type *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified substring, count characters and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22c52720442dea9e80a0ee939e0e8644" name="a22c52720442dea9e80a0ee939e0e8644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22c52720442dea9e80a0ee939e0e8644">&#9670;&#160;</a></span>ustring() <span class="overload">[19/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const value_type *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy. </p>

</div>
</div>
<a id="a82d9fbd84544ded58b56bb258c839977" name="a82d9fbd84544ded58b56bb258c839977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82d9fbd84544ded58b56bb258c839977">&#9670;&#160;</a></span>ustring() <span class="overload">[20/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const value_type *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4407cb0d803eaca779def996836accae" name="a4407cb0d803eaca779def996836accae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4407cb0d803eaca779def996836accae">&#9670;&#160;</a></span>ustring() <span class="overload">[21/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">value_type *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy. </p>

</div>
</div>
<a id="aa30cffa0a677d57c60dbc300e2a63f8e" name="aa30cffa0a677d57c60dbc300e2a63f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30cffa0a677d57c60dbc300e2a63f8e">&#9670;&#160;</a></span>ustring() <span class="overload">[22/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">value_type *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acaeedea48ef4f24dafe9ec8fb70092c5" name="acaeedea48ef4f24dafe9ec8fb70092c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaeedea48ef4f24dafe9ec8fb70092c5">&#9670;&#160;</a></span>ustring() <span class="overload">[23/66]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97ca1e3a8ea546462fe2490d87161e67" name="a97ca1e3a8ea546462fe2490d87161e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ca1e3a8ea546462fe2490d87161e67">&#9670;&#160;</a></span>ustring() <span class="overload">[24/66]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1d943de2665ca7471a3c7012f0ac85a" name="aa1d943de2665ca7471a3c7012f0ac85a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d943de2665ca7471a3c7012f0ac85a">&#9670;&#160;</a></span>ustring() <span class="overload">[25/66]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c224c965990e3a8674037250c9c466d" name="a9c224c965990e3a8674037250c9c466d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c224c965990e3a8674037250c9c466d">&#9670;&#160;</a></span>ustring() <span class="overload">[26/66]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1fcf93d304874f014d6a802be7666c1c" name="a1fcf93d304874f014d6a802be7666c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fcf93d304874f014d6a802be7666c1c">&#9670;&#160;</a></span>ustring() <span class="overload">[27/66]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const std::u8string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31e269e43bbcacd9b0071ccb1fe5e158" name="a31e269e43bbcacd9b0071ccb1fe5e158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e269e43bbcacd9b0071ccb1fe5e158">&#9670;&#160;</a></span>ustring() <span class="overload">[28/66]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const std::u8string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5295f4a35fdf004ab7c4b62bf1ba56b" name="af5295f4a35fdf004ab7c4b62bf1ba56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5295f4a35fdf004ab7c4b62bf1ba56b">&#9670;&#160;</a></span>ustring() <span class="overload">[29/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">char8</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy. </p>

</div>
</div>
<a id="a1505227afa3c82eb5e0a2e4e1754f541" name="a1505227afa3c82eb5e0a2e4e1754f541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1505227afa3c82eb5e0a2e4e1754f541">&#9670;&#160;</a></span>ustring() <span class="overload">[30/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">char8</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6c35e48175f6d6ea83deb119883fb23" name="ab6c35e48175f6d6ea83deb119883fb23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c35e48175f6d6ea83deb119883fb23">&#9670;&#160;</a></span>ustring() <span class="overload">[31/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">char8</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy. </p>

</div>
</div>
<a id="a701190baffb8aa8f2fc412d63310aaa4" name="a701190baffb8aa8f2fc412d63310aaa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701190baffb8aa8f2fc412d63310aaa4">&#9670;&#160;</a></span>ustring() <span class="overload">[32/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">char8</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6819b6bf89183d64b7ac6d474772b07" name="ae6819b6bf89183d64b7ac6d474772b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6819b6bf89183d64b7ac6d474772b07">&#9670;&#160;</a></span>ustring() <span class="overload">[33/66]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const std::u16string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf6c2740de5260fc6cc9d3fa7066fbfe" name="abf6c2740de5260fc6cc9d3fa7066fbfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf6c2740de5260fc6cc9d3fa7066fbfe">&#9670;&#160;</a></span>ustring() <span class="overload">[34/66]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const std::u16string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a409297779dcf55ae74b83a435569b328" name="a409297779dcf55ae74b83a435569b328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409297779dcf55ae74b83a435569b328">&#9670;&#160;</a></span>ustring() <span class="overload">[35/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">char16</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy. </p>

</div>
</div>
<a id="a1c0994a9a72dd136d0abb8390be983dd" name="a1c0994a9a72dd136d0abb8390be983dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0994a9a72dd136d0abb8390be983dd">&#9670;&#160;</a></span>ustring() <span class="overload">[36/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">char16</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31a5d9202fbeea5064291b66206aa0cd" name="a31a5d9202fbeea5064291b66206aa0cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a5d9202fbeea5064291b66206aa0cd">&#9670;&#160;</a></span>ustring() <span class="overload">[37/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">char16</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy. </p>

</div>
</div>
<a id="ad896767620ca29c0136fda92dcd90007" name="ad896767620ca29c0136fda92dcd90007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad896767620ca29c0136fda92dcd90007">&#9670;&#160;</a></span>ustring() <span class="overload">[38/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">char16</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8c728901774cc83ca604138421d6268" name="ab8c728901774cc83ca604138421d6268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c728901774cc83ca604138421d6268">&#9670;&#160;</a></span>ustring() <span class="overload">[39/66]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const std::u32string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada4269aa64ca67c250c758763e6819cd" name="ada4269aa64ca67c250c758763e6819cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada4269aa64ca67c250c758763e6819cd">&#9670;&#160;</a></span>ustring() <span class="overload">[40/66]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const std::u32string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5521daa7562bf09ec4bf4b9d5bb415a1" name="a5521daa7562bf09ec4bf4b9d5bb415a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5521daa7562bf09ec4bf4b9d5bb415a1">&#9670;&#160;</a></span>ustring() <span class="overload">[41/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">char32</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy. </p>

</div>
</div>
<a id="ab9d83e074a4787153dcdd61fd7df2180" name="ab9d83e074a4787153dcdd61fd7df2180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d83e074a4787153dcdd61fd7df2180">&#9670;&#160;</a></span>ustring() <span class="overload">[42/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">char32</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13b3316b8b80398b29421521f343c7e7" name="a13b3316b8b80398b29421521f343c7e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b3316b8b80398b29421521f343c7e7">&#9670;&#160;</a></span>ustring() <span class="overload">[43/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">char32</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy. </p>

</div>
</div>
<a id="a5be6798dbe450805467abc4fd0348ae4" name="a5be6798dbe450805467abc4fd0348ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be6798dbe450805467abc4fd0348ae4">&#9670;&#160;</a></span>ustring() <span class="overload">[44/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">char32</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6051d53b2892b7585b6278a2a5601b9" name="ac6051d53b2892b7585b6278a2a5601b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6051d53b2892b7585b6278a2a5601b9">&#9670;&#160;</a></span>ustring() <span class="overload">[45/66]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c026c8d5a2e188a7737ea902ae9c9f1" name="a2c026c8d5a2e188a7737ea902ae9c9f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c026c8d5a2e188a7737ea902ae9c9f1">&#9670;&#160;</a></span>ustring() <span class="overload">[46/66]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48913b4f219b6d5f73925a872be982fc" name="a48913b4f219b6d5f73925a872be982fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48913b4f219b6d5f73925a872be982fc">&#9670;&#160;</a></span>ustring() <span class="overload">[47/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">wchar</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy. </p>

</div>
</div>
<a id="abe7517ca15654f917db3c61a018f6c42" name="abe7517ca15654f917db3c61a018f6c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe7517ca15654f917db3c61a018f6c42">&#9670;&#160;</a></span>ustring() <span class="overload">[48/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">wchar</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada1d3db0b384ec6bed989728bcc25dbb" name="ada1d3db0b384ec6bed989728bcc25dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1d3db0b384ec6bed989728bcc25dbb">&#9670;&#160;</a></span>ustring() <span class="overload">[49/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">wchar</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy. </p>

</div>
</div>
<a id="a9e3306353977a648613151dbbd634fa0" name="a9e3306353977a648613151dbbd634fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e3306353977a648613151dbbd634fa0">&#9670;&#160;</a></span>ustring() <span class="overload">[50/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">wchar</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb84879a963d77159459e8aee6d21169" name="acb84879a963d77159459e8aee6d21169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb84879a963d77159459e8aee6d21169">&#9670;&#160;</a></span>ustring() <span class="overload">[51/66]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to move. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50a96f03a62a5c045296bf62e3c4c31f" name="a50a96f03a62a5c045296bf62e3c4c31f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a96f03a62a5c045296bf62e3c4c31f">&#9670;&#160;</a></span>ustring() <span class="overload">[52/66]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to move and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to move. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae61f98b244908a02d90c8c6f6fcab6eb" name="ae61f98b244908a02d90c8c6f6fcab6eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61f98b244908a02d90c8c6f6fcab6eb">&#9670;&#160;</a></span>ustring() <span class="overload">[53/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified first and last iterators of substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator of substring. </td></tr>
    <tr><td class="paramname">last</td><td>The first iterator of substring. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a233f13e910222e1b5ca44df02b51e42f" name="a233f13e910222e1b5ca44df02b51e42f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a233f13e910222e1b5ca44df02b51e42f">&#9670;&#160;</a></span>ustring() <span class="overload">[54/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified first and last iterators of substring and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator of substring. </td></tr>
    <tr><td class="paramname">last</td><td>The first iterator of substring. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4124167b2fe253847a09df705dda7af2" name="a4124167b2fe253847a09df705dda7af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4124167b2fe253847a09df705dda7af2">&#9670;&#160;</a></span>ustring() <span class="overload">[55/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename string_view_like_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const string_view_like_t &amp;&#160;</td>
          <td class="paramname"><em>string_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string view of substring and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string_view</td><td>The string view. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08586c2e61560c82f8a5fef51b217273" name="a08586c2e61560c82f8a5fef51b217273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08586c2e61560c82f8a5fef51b217273">&#9670;&#160;</a></span>ustring() <span class="overload">[56/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename string_view_like_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const string_view_like_t &amp;&#160;</td>
          <td class="paramname"><em>string_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string view of substring and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string_view</td><td>The string view. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26be076083adc627f2908488f9d5cc01" name="a26be076083adc627f2908488f9d5cc01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26be076083adc627f2908488f9d5cc01">&#9670;&#160;</a></span>ustring() <span class="overload">[57/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to fill. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a015261e2eb18d2ac46ca692829cd164d" name="a015261e2eb18d2ac46ca692829cd164d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015261e2eb18d2ac46ca692829cd164d">&#9670;&#160;</a></span>ustring() <span class="overload">[58/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to fill. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5fac71387a4d3abb9f4b59cc89c735e" name="af5fac71387a4d3abb9f4b59cc89c735e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5fac71387a4d3abb9f4b59cc89c735e">&#9670;&#160;</a></span>ustring() <span class="overload">[59/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">char8</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to fill. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad68c91b16568d7b858245097921a3f3a" name="ad68c91b16568d7b858245097921a3f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad68c91b16568d7b858245097921a3f3a">&#9670;&#160;</a></span>ustring() <span class="overload">[60/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">char8</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to fill. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f312b06fc60075660894c4dea4c74a1" name="a0f312b06fc60075660894c4dea4c74a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f312b06fc60075660894c4dea4c74a1">&#9670;&#160;</a></span>ustring() <span class="overload">[61/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">char16</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to fill. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6aad2bc1f2f7e8dd9e00cda60768c71" name="af6aad2bc1f2f7e8dd9e00cda60768c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6aad2bc1f2f7e8dd9e00cda60768c71">&#9670;&#160;</a></span>ustring() <span class="overload">[62/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">char16</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to fill. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32687b04f00204cda172df185578ae8d" name="a32687b04f00204cda172df185578ae8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32687b04f00204cda172df185578ae8d">&#9670;&#160;</a></span>ustring() <span class="overload">[63/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">char32</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to fill. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53aab32b6c83dc89748c8e85e4aaac88" name="a53aab32b6c83dc89748c8e85e4aaac88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53aab32b6c83dc89748c8e85e4aaac88">&#9670;&#160;</a></span>ustring() <span class="overload">[64/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">char32</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to fill. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae818479b53ee91eb8ebbcd27712e9643" name="ae818479b53ee91eb8ebbcd27712e9643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae818479b53ee91eb8ebbcd27712e9643">&#9670;&#160;</a></span>ustring() <span class="overload">[65/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">wchar</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to fill. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a305bcfad255f758ef9b7e19d6941e597" name="a305bcfad255f758ef9b7e19d6941e597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a305bcfad255f758ef9b7e19d6941e597">&#9670;&#160;</a></span>ustring() <span class="overload">[66/66]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">wchar</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to fill. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aafaae6b32a8bbfc8cd20defa2b14dc88" name="aafaae6b32a8bbfc8cd20defa2b14dc88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafaae6b32a8bbfc8cd20defa2b14dc88">&#9670;&#160;</a></span>class_name() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename object_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::class_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the class name of the object_t. </p>
<dl class="section return"><dt>Returns</dt><dd>The class name of the object_t. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example, the name of the ustring type is ustring. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group__keywords.html#gafa2ffd9b4a6568b57ab2731bec095d99" title="Used to obtain the type object of a specified type or object.">typeof_&lt;object_t&gt;()</a>.name() - Will be removed in version 0.4.0 </dd></dl>

</div>
</div>
<a id="a5bf26167d0f67d103c069fb005063234" name="a5bf26167d0f67d103c069fb005063234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf26167d0f67d103c069fb005063234">&#9670;&#160;</a></span>class_name() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename object_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::class_name </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the class name of the specified object. </p>
<dl class="section return"><dt>Returns</dt><dd>The class name of the specified object. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example, the name of the ustring type is ustring. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000019">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group__keywords.html#gafa2ffd9b4a6568b57ab2731bec095d99" title="Used to obtain the type object of a specified type or object.">typeof_(object)</a>.name() - Will be removed in version 0.4.0 </dd></dl>

</div>
</div>
<a id="a7e4bcd6d2d8749fb41e52c3c7152fe13" name="a7e4bcd6d2d8749fb41e52c3c7152fe13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e4bcd6d2d8749fb41e52c3c7152fe13">&#9670;&#160;</a></span>class_name() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::class_name </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the class name of the specified object. </p>
<dl class="section return"><dt>Returns</dt><dd>The class name of the specified object. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example, the name of the ustring type is ustring. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000020">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group__keywords.html#gafa2ffd9b4a6568b57ab2731bec095d99" title="Used to obtain the type object of a specified type or object.">typeof_(info)</a>.name() - Will be removed in version 0.4.0 </dd></dl>

</div>
</div>
<a id="a435ca143c948bc8c0c009dabe7de1b6b" name="a435ca143c948bc8c0c009dabe7de1b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a435ca143c948bc8c0c009dabe7de1b6b">&#9670;&#160;</a></span>compare() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a> xtd::ustring::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two specified string objects and returns an integer that indicates their relative position in the sort order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first string to compare. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second string to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates the lexical relationship between the two compares. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">str_a precedes str_b in the sort order.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">str_a occurs in the same position as str_b in the sort order.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">str_a follows str_b in the sort order.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="addb0a2f5d602d354209cd0caadc877be" name="addb0a2f5d602d354209cd0caadc877be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb0a2f5d602d354209cd0caadc877be">&#9670;&#160;</a></span>compare() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a> xtd::ustring::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_case</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two specified string objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first string to compare. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second string to compare. </td></tr>
    <tr><td class="paramname">ignore_case</td><td>true to ignore case during the comparison; otherwise, false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates the lexical relationship between the two compares. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">str_a precedes str_b in the sort order.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">str_a occurs in the same position as str_b in the sort order.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">str_a follows str_b in the sort order.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a382561d2de4a607ed95d4dde301a7819" name="a382561d2de4a607ed95d4dde301a7819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382561d2de4a607ed95d4dde301a7819">&#9670;&#160;</a></span>compare() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a> xtd::ustring::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__xtd__core.html#ga04dd6c532656e286dfbf2f9aea3d8ccd">xtd::string_comparison</a>&#160;</td>
          <td class="paramname"><em>comparison_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two specified string objects using the specified rules, and returns an integer that indicates their relative position in the sort order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first string to compare. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second string to compare. </td></tr>
    <tr><td class="paramname">comparison_type</td><td>One of the enumeration values that specifies the rules to use in the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates the lexical relationship between the two compares. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">str_a precedes str_b in the sort order.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">str_a occurs in the same position as str_b in the sort order.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">str_a follows str_b in the sort order.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="ab6bb2d780afdc3e716093efab129e854" name="ab6bb2d780afdc3e716093efab129e854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6bb2d780afdc3e716093efab129e854">&#9670;&#160;</a></span>compare() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a> xtd::ustring::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares substrings of two specified string objects and returns an integer that indicates their relative position in the sort order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first string to use in the comparison. </td></tr>
    <tr><td class="paramname">index_a</td><td>The position of the substring within str_a. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second string to use in the comparison. </td></tr>
    <tr><td class="paramname">index_b</td><td>The position of the substring within str_b. </td></tr>
    <tr><td class="paramname">length</td><td>The maximum number of characters in the substrings to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates the lexical relationship between the two compares. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">str_a precedes str_b in the sort order.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">str_a occurs in the same position as str_b in the sort order.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">str_a follows str_b in the sort order.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="afb4786c9c92df32605ec81fa750e8a48" name="afb4786c9c92df32605ec81fa750e8a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4786c9c92df32605ec81fa750e8a48">&#9670;&#160;</a></span>compare() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a> xtd::ustring::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_case</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares substrings of two specified string objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first string to use in the comparison. </td></tr>
    <tr><td class="paramname">index_a</td><td>The position of the substring within str_a. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second string to use in the comparison. </td></tr>
    <tr><td class="paramname">index_b</td><td>The position of the substring within str_b. </td></tr>
    <tr><td class="paramname">length</td><td>The maximum number of characters in the substrings to compare </td></tr>
    <tr><td class="paramname">ignore_case</td><td>true to ignore case during the comparison; otherwise, false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates the lexical relationship between the two compares. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">str_a precedes str_b in the sort order.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">str_a occurs in the same position as str_b in the sort order.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">str_a follows str_b in the sort order.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="afb5dc8585f020077b629282c61a8d391" name="afb5dc8585f020077b629282c61a8d391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb5dc8585f020077b629282c61a8d391">&#9670;&#160;</a></span>compare() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a> xtd::ustring::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__xtd__core.html#ga04dd6c532656e286dfbf2f9aea3d8ccd">xtd::string_comparison</a>&#160;</td>
          <td class="paramname"><em>comparison_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares substrings of two specified string objects using the specified rules, and returns an integer that indicates their relative position in the sort order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first string to use in the comparison. </td></tr>
    <tr><td class="paramname">index_a</td><td>The position of the substring within str_a. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second string to use in the comparison. </td></tr>
    <tr><td class="paramname">index_b</td><td>The position of the substring within str_b. </td></tr>
    <tr><td class="paramname">length</td><td>The maximum number of characters in the substrings to compare </td></tr>
    <tr><td class="paramname">comparison_type</td><td>One of the enumeration values that specifies the rules to use in the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates the lexical relationship between the two compares. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">str_a precedes str_b in the sort order.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">str_a occurs in the same position as str_b in the sort order.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">str_a follows str_b in the sort order.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a1a314847f67dc9eac2dbf5641b27a399" name="a1a314847f67dc9eac2dbf5641b27a399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a314847f67dc9eac2dbf5641b27a399">&#9670;&#160;</a></span>compare_to()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a> xtd::ustring::compare_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the current instance with another object of the same type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>An object to compare with this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has these meanings: <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">This instance is less than obj.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">This instance is equal to obj.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">This instance is greater than obj.   </td></tr>
</table>
</dd></dl>

<p>Implements <a class="el" href="classxtd_1_1icomparable.html#a8e5ad6ed9d798584e8b9be5749d6faa5">xtd::icomparable&lt; ustring &gt;</a>.</p>

</div>
</div>
<a id="a80f9f5b6643bb4527a966f6ce1f4f6fd" name="a80f9f5b6643bb4527a966f6ce1f4f6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f9f5b6643bb4527a966f6ce1f4f6fd">&#9670;&#160;</a></span>concat() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename object_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::concat </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; object_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates the string representations of the elements in a specified object array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>An object array that contains the elements to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The concatenated string representations of the values of the elements in args. </dd></dl>

</div>
</div>
<a id="acb605ccce66373c790611a13db14f14c" name="acb605ccce66373c790611a13db14f14c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb605ccce66373c790611a13db14f14c">&#9670;&#160;</a></span>concat() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::concat </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classxtd_1_1ustring.html">ustring</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates the elements of a specified string array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An array of string instances. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The concatenated elements of values. </dd></dl>

</div>
</div>
<a id="ae84e9e74970e64e21a97afee579ed6f3" name="ae84e9e74970e64e21a97afee579ed6f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84e9e74970e64e21a97afee579ed6f3">&#9670;&#160;</a></span>concat() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates two specified instances of string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first string to concatenate. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second string to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string The concatenation of str_a and str_b. </dd></dl>

</div>
</div>
<a id="aceda089f7586a63df656566d0c815d22" name="aceda089f7586a63df656566d0c815d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceda089f7586a63df656566d0c815d22">&#9670;&#160;</a></span>concat() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates three specified instances of string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first string to concatenate. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second string to concatenate. </td></tr>
    <tr><td class="paramname">str_c</td><td>The third string to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string The concatenation of str_a, str_b and str_c. </dd></dl>

</div>
</div>
<a id="a9d492d6b9ce2f2e38661a5062009a32f" name="a9d492d6b9ce2f2e38661a5062009a32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d492d6b9ce2f2e38661a5062009a32f">&#9670;&#160;</a></span>concat() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates four specified instances of string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first string to concatenate. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second string to concatenate. </td></tr>
    <tr><td class="paramname">str_c</td><td>The third string to concatenate. </td></tr>
    <tr><td class="paramname">str_d</td><td>The fourth string to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The concatenation of str_a, str_b, str_c and str_d. </dd></dl>

</div>
</div>
<a id="aa7018e6a7dce9dcf133a1e393b2152ec" name="aa7018e6a7dce9dcf133a1e393b2152ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7018e6a7dce9dcf133a1e393b2152ec">&#9670;&#160;</a></span>concat() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename object_a_t , typename object_b_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::concat </td>
          <td>(</td>
          <td class="paramtype">object_a_t&#160;</td>
          <td class="paramname"><em>obj_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object_b_t&#160;</td>
          <td class="paramname"><em>obj_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates two specified instances of object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj_a</td><td>The first object to concatenate. </td></tr>
    <tr><td class="paramname">obj_b</td><td>The second object to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The concatenation of obj_a and obj_b. </dd></dl>

</div>
</div>
<a id="a06bc47f8af41673e7f3d89c57c9cd525" name="a06bc47f8af41673e7f3d89c57c9cd525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06bc47f8af41673e7f3d89c57c9cd525">&#9670;&#160;</a></span>concat() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename object_a_t , typename object_b_t , typename object_c_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::concat </td>
          <td>(</td>
          <td class="paramtype">object_a_t&#160;</td>
          <td class="paramname"><em>obj_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object_b_t&#160;</td>
          <td class="paramname"><em>obj_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object_c_t&#160;</td>
          <td class="paramname"><em>obj_c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates three specified instances of object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj_a</td><td>The first object to concatenate. </td></tr>
    <tr><td class="paramname">obj_b</td><td>The second object to concatenate. </td></tr>
    <tr><td class="paramname">obj_c</td><td>The third object to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The concatenation of obj_a, obj_b and obj_c. </dd></dl>

</div>
</div>
<a id="a745ec7372c85f6c9126b26d010f4ea97" name="a745ec7372c85f6c9126b26d010f4ea97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a745ec7372c85f6c9126b26d010f4ea97">&#9670;&#160;</a></span>concat() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename object_a_t , typename object_b_t , typename object_c_t , typename object_d_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::concat </td>
          <td>(</td>
          <td class="paramtype">object_a_t&#160;</td>
          <td class="paramname"><em>obj_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object_b_t&#160;</td>
          <td class="paramname"><em>obj_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object_c_t&#160;</td>
          <td class="paramname"><em>obj_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object_d_t&#160;</td>
          <td class="paramname"><em>obj_d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates four specified instances of object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj_a</td><td>The first object to concatenate. </td></tr>
    <tr><td class="paramname">obj_b</td><td>The second object to concatenate. </td></tr>
    <tr><td class="paramname">obj_c</td><td>The third object to concatenate. </td></tr>
    <tr><td class="paramname">obj_d</td><td>The fourth object to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The concatenation of obj_a, obj_b, obj_c and obj_d. </dd></dl>

</div>
</div>
<a id="a3378d826fc5381609746ce3618084157" name="a3378d826fc5381609746ce3618084157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3378d826fc5381609746ce3618084157">&#9670;&#160;</a></span>concat() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::concat </td>
          <td>(</td>
          <td class="paramtype">value_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the string representation of a specified object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The object to represent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string representation of the value of arg. </dd></dl>

</div>
</div>
<a id="aea0e43190da2d939a59a911e46302af1" name="aea0e43190da2d939a59a911e46302af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea0e43190da2d939a59a911e46302af1">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::ustring::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a value indicating whether a specified substring occurs within this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string to seek. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value parameter occurs within this string, or if value is the empty string (""); otherwise, false. </dd></dl>

</div>
</div>
<a id="a238165aaab69fb9f6c909da1fcdb072f" name="a238165aaab69fb9f6c909da1fcdb072f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a238165aaab69fb9f6c909da1fcdb072f">&#9670;&#160;</a></span>demangle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::demangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets demangled string of name,. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name to demangle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The demangled string of name. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following example shows how to use <a class="el" href="classxtd_1_1ustring.html#a238165aaab69fb9f6c909da1fcdb072f" title="Gets demangled string of name,.">xtd::ustring::demangle</a>. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main()-&gt;int {</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;name = {}&quot;</span>, <span class="keyword">typeid</span>(<a class="code hl_class" href="classxtd_1_1date__time.html">xtd::date_time</a>).name());</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;demangled name = {}&quot;</span>, <a class="code hl_function" href="classxtd_1_1ustring.html#a238165aaab69fb9f6c909da1fcdb072f">ustring::demangle</a>(<span class="keyword">typeid</span>(<a class="code hl_class" href="classxtd_1_1date__time.html">xtd::date_time</a>).name()));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output on macOS :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// name = N3xtd9date_timeE</span></div>
<div class="line"><span class="comment">// demangled name = xtd::date_time</span></div>
<div class="ttc" id="aclassxtd_1_1console_html_ae0ccd7fef284ccda33a88576c8a35a37"><div class="ttname"><a href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">xtd::console::write_line</a></div><div class="ttdeci">static void write_line()</div><div class="ttdoc">Writes the current line terminator to the standard output stream using the specified format informati...</div></div>
<div class="ttc" id="aclassxtd_1_1date__time_html"><div class="ttname"><a href="classxtd_1_1date__time.html">xtd::date_time</a></div><div class="ttdoc">Represents an instant in time, typically expressed as a date and time of day.</div><div class="ttdef"><b>Definition</b> date_time.h:79</div></div>
<div class="ttc" id="aclassxtd_1_1ustring_html_a238165aaab69fb9f6c909da1fcdb072f"><div class="ttname"><a href="classxtd_1_1ustring.html#a238165aaab69fb9f6c909da1fcdb072f">xtd::ustring::demangle</a></div><div class="ttdeci">static ustring demangle(const ustring &amp;name)</div><div class="ttdoc">Gets demangled string of name,.</div></div>
<div class="ttc" id="anamespacextd_html"><div class="ttname"><a href="namespacextd.html">xtd</a></div><div class="ttdoc">The xtd namespace contains all fundamental classes to access Hardware, Os, System,...</div><div class="ttdef"><b>Definition</b> xtd_about_box.h:10</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2372f570af43ddd632c3fdfbe43de030" name="a2372f570af43ddd632c3fdfbe43de030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2372f570af43ddd632c3fdfbe43de030">&#9670;&#160;</a></span>ends_with() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::ustring::ends_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">char8</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the end of this string matches the specified character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The char_t to compare to the substring at the end of this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if value matches the end of this instance; otherwise, false. </dd></dl>

</div>
</div>
<a id="ad02f78ca99a3dfb0ee73bc0252b329b0" name="ad02f78ca99a3dfb0ee73bc0252b329b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02f78ca99a3dfb0ee73bc0252b329b0">&#9670;&#160;</a></span>ends_with() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::ustring::ends_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the end of this string matches the specified string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string to compare to the substring at the end of this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if value matches the end of this instance; otherwise, false. </dd></dl>

</div>
</div>
<a id="ae9d72ca87fc9bcdae5c8d3db042cdec9" name="ae9d72ca87fc9bcdae5c8d3db042cdec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d72ca87fc9bcdae5c8d3db042cdec9">&#9670;&#160;</a></span>ends_with() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::ustring::ends_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_case</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the end of this string instance matches the specified string when compared using the specified culture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ignore_case</td><td>true to ignore case during the comparison; otherwise, false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if value matches the end of the specified string; otherwise, false. </dd></dl>

</div>
</div>
<a id="a8fcc85777946011f389241af42b27aaf" name="a8fcc85777946011f389241af42b27aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fcc85777946011f389241af42b27aaf">&#9670;&#160;</a></span>ends_with() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::ustring::ends_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__xtd__core.html#ga04dd6c532656e286dfbf2f9aea3d8ccd">xtd::string_comparison</a>&#160;</td>
          <td class="paramname"><em>comparison_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the end of this string matches the specified string when compared using the specified comparison option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comparison_type</td><td>One of the enumeration values that determines how this string and value are compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if value matches the end of the specified string; otherwise, false. </dd></dl>

</div>
</div>
<a id="ab66c2037568657029c2695e7c5d43d84" name="ab66c2037568657029c2695e7c5d43d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab66c2037568657029c2695e7c5d43d84">&#9670;&#160;</a></span>ends_with() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::ustring::ends_with </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the end of this string matches the specified character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The char_t to compare to the substring at the end of this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if value matches the end of this instance; otherwise, false. </dd></dl>

</div>
</div>
<a id="aa6a65b727872715c7b99958e84a75f61" name="aa6a65b727872715c7b99958e84a75f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a65b727872715c7b99958e84a75f61">&#9670;&#160;</a></span>full_class_name() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename object_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::full_class_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the fully qualified class name of the objec_t, including the namespace of the objec_t. </p>
<dl class="section return"><dt>Returns</dt><dd>The fully qualified class name of the objec_t, including the namespace of the objec_t. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example, the fully qualified name of the ustring type is <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000021">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group__keywords.html#gafa2ffd9b4a6568b57ab2731bec095d99" title="Used to obtain the type object of a specified type or object.">typeof_&lt;object_t&gt;()</a>.full_name() - Will be removed in version 0.4.0 </dd></dl>

</div>
</div>
<a id="a81a0eee00e7f757562565f8e19c7747d" name="a81a0eee00e7f757562565f8e19c7747d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a0eee00e7f757562565f8e19c7747d">&#9670;&#160;</a></span>full_class_name() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename object_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::full_class_name </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the fully qualified class name of the specified object, including the namespace of the specified object. </p>
<dl class="section return"><dt>Returns</dt><dd>The fully qualified class name of the objec_t, including the namespace of the specified object. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example, the fully qualified name of the ustring type is <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000022">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group__keywords.html#gafa2ffd9b4a6568b57ab2731bec095d99" title="Used to obtain the type object of a specified type or object.">typeof_(object)</a>.full_name() - Will be removed in version 0.4.0 </dd></dl>

</div>
</div>
<a id="af9c639795fa939f9ccf93342b5a76e45" name="af9c639795fa939f9ccf93342b5a76e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c639795fa939f9ccf93342b5a76e45">&#9670;&#160;</a></span>full_class_name() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::full_class_name </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the fully qualified class name of the specified object, including the namespace of the specified object. </p>
<dl class="section return"><dt>Returns</dt><dd>The fully qualified class name of the objec_t, including the namespace of the specified object. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example, the fully qualified name of the ustring type is <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000023">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group__keywords.html#gafa2ffd9b4a6568b57ab2731bec095d99" title="Used to obtain the type object of a specified type or object.">typeof_(info)</a>.full_name() - Will be removed in version 0.4.0 </dd></dl>

</div>
</div>
<a id="ab80f25a3a363194532225ddacc53e663" name="ab80f25a3a363194532225ddacc53e663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80f25a3a363194532225ddacc53e663">&#9670;&#160;</a></span>get_hash_code()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::get_hash_code </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the hash code for this string. </p>
<dl class="section return"><dt>Returns</dt><dd>A hash code. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1object.html#a1fea096f8a49ac5eef1f2431806109ca">xtd::object</a>.</p>

</div>
</div>
<a id="abde1d8ad0d05e9e769aaeb4510a993cb" name="abde1d8ad0d05e9e769aaeb4510a993cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde1d8ad0d05e9e769aaeb4510a993cb">&#9670;&#160;</a></span>index_of() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified string in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="af368ba7426298e88fd5b5dc5f06e4c6d" name="af368ba7426298e88fd5b5dc5f06e4c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af368ba7426298e88fd5b5dc5f06e4c6d">&#9670;&#160;</a></span>index_of() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified character in this string. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="aec7e84685e335551dd4e9868c110b427" name="aec7e84685e335551dd4e9868c110b427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7e84685e335551dd4e9868c110b427">&#9670;&#160;</a></span>index_of() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified character in this string. The search starts at a specified character position and examines a specified number of character positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="a74e9d6260703cb75dbff5a8e458083e3" name="a74e9d6260703cb75dbff5a8e458083e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e9d6260703cb75dbff5a8e458083e3">&#9670;&#160;</a></span>index_of() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::index_of </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified character in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="time_span_from_hours_8cpp-example.html#a3">time_span_from_hours.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a65748d612fa86854545f4627f8c63601" name="a65748d612fa86854545f4627f8c63601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65748d612fa86854545f4627f8c63601">&#9670;&#160;</a></span>index_of() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::index_of </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified character in this string. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="a00535c21a723c61d49790a98fc56ac58" name="a00535c21a723c61d49790a98fc56ac58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00535c21a723c61d49790a98fc56ac58">&#9670;&#160;</a></span>index_of() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::index_of </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified character in this string. The search starts at a specified character position and examines a specified number of character positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="a52f8ff481971c33c05ccc60ff7c2397e" name="a52f8ff481971c33c05ccc60ff7c2397e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f8ff481971c33c05ccc60ff7c2397e">&#9670;&#160;</a></span>index_of_any() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::index_of_any </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence in this instance of any character in a specified array of characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>

</div>
</div>
<a id="a92268eec76bff7c4b3b33a7696cfb12a" name="a92268eec76bff7c4b3b33a7696cfb12a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92268eec76bff7c4b3b33a7696cfb12a">&#9670;&#160;</a></span>index_of_any() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::index_of_any </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>

</div>
</div>
<a id="ac8ec9a7b572cc3e92aabafe3c6bed320" name="ac8ec9a7b572cc3e92aabafe3c6bed320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ec9a7b572cc3e92aabafe3c6bed320">&#9670;&#160;</a></span>index_of_any() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::index_of_any </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>

</div>
</div>
<a id="a4fb8bd971a50be1f16f8a60f1acc5e8e" name="a4fb8bd971a50be1f16f8a60f1acc5e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb8bd971a50be1f16f8a60f1acc5e8e">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::insert </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a specified instance of string at a specified index position in this instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The index position of the insertion. </td></tr>
    <tr><td class="paramname">value</td><td>The string to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new string equivalent to this instance but with value inserted at position start_index. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If start_index is equal to the length of this instance, value is appended to the end of this instance. </dd>
<dd>
For example, the return value of "abc".Insert(2, "XYZ") is "abXYZc". </dd></dl>

</div>
</div>
<a id="a22354e7aab0bf4e272fcc3d48095e950" name="a22354e7aab0bf4e272fcc3d48095e950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22354e7aab0bf4e272fcc3d48095e950">&#9670;&#160;</a></span>is_empty() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::ustring::is_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this string is an empty string (""). </p>
<dl class="section return"><dt>Returns</dt><dd>true if the value parameter is null or an empty string (""); otherwise, false. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="classxtd_1_1ustring.html#a479cbb69619f996515fea1599a5e54df" title="Indicates whether the specifeid string is an empty string (&quot;&quot;).">xtd::ustring::is_empty(const xtd::ustring&amp;)</a> - Will be removed in version 0.4.0 </dd></dl>

</div>
</div>
<a id="a479cbb69619f996515fea1599a5e54df" name="a479cbb69619f996515fea1599a5e54df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479cbb69619f996515fea1599a5e54df">&#9670;&#160;</a></span>is_empty() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::ustring::is_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">xtd::ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the specifeid string is an empty string (""). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>The <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> to check if empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value parameter is null or an empty string (""); otherwise, false. </dd></dl>

</div>
</div>
<a id="ae37001c9de58f2a351850d0fb3fce995" name="ae37001c9de58f2a351850d0fb3fce995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae37001c9de58f2a351850d0fb3fce995">&#9670;&#160;</a></span>join() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates a specified separator string between each element of a specified object array, yielding a single concatenated string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>A string separator. </td></tr>
    <tr><td class="paramname">values</td><td>An array of Object. </td></tr>
    <tr><td class="paramname">start_index</td><td>The first array element in value to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string consisting of the elements of value interspersed with the separator string. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example if separator is ", " and the elements of value are "red", "blue", "green", and "yellow", Join(separator, value) returns "red, blue, green, yellow". </dd>
<dd>
stream &lt;&lt; operator is called on each object to generate the content. </dd></dl>

</div>
</div>
<a id="a506719218360ffaff29724ee5f15a5ff" name="a506719218360ffaff29724ee5f15a5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a506719218360ffaff29724ee5f15a5ff">&#9670;&#160;</a></span>join() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates a specified separator string between each element of a specified Object array, yielding a single concatenated string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>A string separator. </td></tr>
    <tr><td class="paramname">values</td><td>An array of Object. </td></tr>
    <tr><td class="paramname">start_index</td><td>The first array element in value to use. </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements of value to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string consisting of the elements of value interspersed with the separator string. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example if separator is ", " and the elements of value are "red", "blue", "green", and "yellow", Join(separator, value) returns "red, blue, green, yellow". </dd>
<dd>
stream &lt;&lt; operator is called on each object to generate the content. </dd></dl>

</div>
</div>
<a id="a95694998a854ba65dde682b879eec355" name="a95694998a854ba65dde682b879eec355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95694998a854ba65dde682b879eec355">&#9670;&#160;</a></span>join() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates a specified separator string between each element of a specified object array, yielding a single concatenated string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>A string separator. </td></tr>
    <tr><td class="paramname">values</td><td>An array of Object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string consisting of the elements of value interspersed with the separator string. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example if separator is ", " and the elements of value are "red", "blue", "green", and "yellow", Join(separator, value) returns "red, blue, green, yellow". </dd>
<dd>
stream &lt;&lt; operator is called on each object to generate the content. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="test_forms_8cpp-example.html#a33">test_forms.cpp</a>, and <a class="el" href="uri_8cpp-example.html#a2">uri.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a8adab244b1165d2d9b849a39cf8ff55d" name="a8adab244b1165d2d9b849a39cf8ff55d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8adab244b1165d2d9b849a39cf8ff55d">&#9670;&#160;</a></span>last_index_of() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::last_index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified string in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="a120c87d0c32977516fe5f31ed968a541" name="a120c87d0c32977516fe5f31ed968a541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120c87d0c32977516fe5f31ed968a541">&#9670;&#160;</a></span>last_index_of() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::last_index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified character in this string. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="a125ebf9aadb1dc5948f57b0aca64b72a" name="a125ebf9aadb1dc5948f57b0aca64b72a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125ebf9aadb1dc5948f57b0aca64b72a">&#9670;&#160;</a></span>last_index_of() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::last_index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified character in this string. The search starts at a specified character position and examines a specified number of character positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="a1d6d810543949e28650f92b5206314a5" name="a1d6d810543949e28650f92b5206314a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6d810543949e28650f92b5206314a5">&#9670;&#160;</a></span>last_index_of() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::last_index_of </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified character in this tring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="test_forms_8cpp-example.html#a28">test_forms.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a2c0899fdfb944945fe56abf5b74b4716" name="a2c0899fdfb944945fe56abf5b74b4716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0899fdfb944945fe56abf5b74b4716">&#9670;&#160;</a></span>last_index_of() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::last_index_of </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified character in this string. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="ab32dc6a0c560aa072d8ce83151530a75" name="ab32dc6a0c560aa072d8ce83151530a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab32dc6a0c560aa072d8ce83151530a75">&#9670;&#160;</a></span>last_index_of() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::last_index_of </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified character in this string. The search starts at a specified character position and examines a specified number of character positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>A string to find last index of. </td></tr>
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="a088f6faf6f0d3d4df9702c4185b04a30" name="a088f6faf6f0d3d4df9702c4185b04a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a088f6faf6f0d3d4df9702c4185b04a30">&#9670;&#160;</a></span>last_index_of_any() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::last_index_of_any </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence in this instance of any character in a specified array of characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>

</div>
</div>
<a id="aec4834f48993ac33b74f95069aa16357" name="aec4834f48993ac33b74f95069aa16357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec4834f48993ac33b74f95069aa16357">&#9670;&#160;</a></span>last_index_of_any() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::last_index_of_any </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>

</div>
</div>
<a id="a945e24afee50977935bd3aca1cdddb6a" name="a945e24afee50977935bd3aca1cdddb6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a945e24afee50977935bd3aca1cdddb6a">&#9670;&#160;</a></span>last_index_of_any() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::last_index_of_any </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>

</div>
</div>
<a id="aadfe62deb046bd17790cb22207d4f4f5" name="aadfe62deb046bd17790cb22207d4f4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadfe62deb046bd17790cb22207d4f4f5">&#9670;&#160;</a></span>pad_left() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::pad_left </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>total_width</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Right-aligns the characters in this string, padding with spaces on the left for a specified total length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">total_width</td><td>The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new string that is equivalent to the specified string, but right-aligned and padded on the left with as many spaces as needed to create a length of total_width. Or, if total_width is less than the length of the specified string, a new string object that is identical to the specified string. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>An unicode space is defined as hexadecimal 0x20. </dd>
<dd>
The pad_left(const std::basic_string&lt;char_t&gt;&amp;, int) method pads the beginning of the returned string. This means that, when used with right-to-left languages, it pads the right portion of the string.. </dd></dl>

</div>
</div>
<a id="a3a1d40bffb5a673ecdb6f13fdf19d954" name="a3a1d40bffb5a673ecdb6f13fdf19d954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1d40bffb5a673ecdb6f13fdf19d954">&#9670;&#160;</a></span>pad_left() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::pad_left </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>total_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>padding_char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Right-aligns the characters in this string, padding with spaces on the left for a specified total length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">total_width</td><td>The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters. </td></tr>
    <tr><td class="paramname">paddingChar</td><td>An unicode padding character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new string that is equivalent to the specified string, but right-aligned and padded on the left with as many spaces as needed to create a length of total_width. Or, if total_width is less than the length of the specified string, a new string object that is identical the specified string. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>An unicode space is defined as hexadecimal 0x20. </dd>
<dd>
The pad_left(const std::basic_string&lt;char_t&gt;&amp;, int) method pads the beginning of the returned string. This means that, when used with right-to-left languages, it pads the right portion of the string.. </dd></dl>

</div>
</div>
<a id="a7b9abb16d8b680c650dd5cad88b8ecdb" name="a7b9abb16d8b680c650dd5cad88b8ecdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b9abb16d8b680c650dd5cad88b8ecdb">&#9670;&#160;</a></span>pad_right() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::pad_right </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>total_width</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Left-aligns the characters in this string, padding with spaces on the right for a specified total length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">totalWidth</td><td>The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new string that is equivalent to the specified string, but left-aligned and padded on the right with as many spaces as needed to create a length of totalWidth. Or, if totalWidth is less than the length of the specified string, a new string object that is identical to the specified string. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>An unicode space is defined as hexadecimal 0x20. </dd>
<dd>
The PadRight(const std::basic_string&lt;char_t&gt;&amp;, int) method pads the end of the returned string. This means that, when used with right-to-left languages, it pads the left portion of the string.. </dd></dl>

</div>
</div>
<a id="a4acf4abd79ff8bc4eb2b2b314273084b" name="a4acf4abd79ff8bc4eb2b2b314273084b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4acf4abd79ff8bc4eb2b2b314273084b">&#9670;&#160;</a></span>pad_right() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::pad_right </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>total_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>padding_char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Left-aligns the characters in this string, padding with spaces on the right for a specified total length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">totalWidth</td><td>The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters. </td></tr>
    <tr><td class="paramname">paddingChar</td><td>An unicode padding character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new string that is equivalent to the specified string, but left-aligned and padded on the tight with as many spaces as needed to create a length of totalWidth. Or, if totalWidth is less than the length of the specified string, a new string object that is identical to the specified string. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>An unicode space is defined as hexadecimal 0x20. </dd>
<dd>
The <a class="el" href="classxtd_1_1ustring.html#a7b9abb16d8b680c650dd5cad88b8ecdb" title="Left-aligns the characters in this string, padding with spaces on the right for a specified total len...">xtd::ustring::pad_right</a> method pads the end of the returned string. This means that, when used with right-to-left languages, it pads the left portion of the string.. </dd></dl>

</div>
</div>
<a id="a90aeac5b1761195838734b45d1268dd3" name="a90aeac5b1761195838734b45d1268dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90aeac5b1761195838734b45d1268dd3">&#9670;&#160;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static value_t xtd::ustring::parse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a string into a value_t type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Ax <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> to convert to value_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value_t object parsed. </dd></dl>

</div>
</div>
<a id="a30038c25718a196b702d8b85bc6b8aff" name="a30038c25718a196b702d8b85bc6b8aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30038c25718a196b702d8b85bc6b8aff">&#9670;&#160;</a></span>quoted() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::quoted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows insertion and extraction of quoted strings, such as the ones found in <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> or <a href="https://en.wikipedia.org/wiki/XML">XML</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A new quoted string. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>the delimiter is set to <pre class="fragment">" </pre> by default and the escape is set to <code>\</code> by default. </dd>
<dd>
for more information see <a href="https://en.cppreference.com/w/cpp/io/manip/quoted">std::quoted</a>. </dd></dl>

</div>
</div>
<a id="adf62a947cf88677831458c42b12d88ce" name="adf62a947cf88677831458c42b12d88ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf62a947cf88677831458c42b12d88ce">&#9670;&#160;</a></span>quoted() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::quoted </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>escape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows insertion and extraction of quoted strings, such as the ones found in <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> or <a href="https://en.wikipedia.org/wiki/XML">XML</a> ith specified delimiter and escape. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimiter</td><td>The character to use as the delimiter, defaults to <code>"&lt;/tt&gt;.
@param escape The character to use as the escape character, defaults to &lt;tt&gt;\\&lt;/tt&gt;.
@return A new quoted string.
@remarks for more information see &lt;a href="<a href="https://en.cppreference.com/w/cpp/io/manip/quoted">https://en.cppreference.com/w/cpp/io/manip/quoted</a>" &gt;std::quoted. </code></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9e0a7ed099484646436a14ef1279ab5" name="ac9e0a7ed099484646436a14ef1279ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e0a7ed099484646436a14ef1279ab5">&#9670;&#160;</a></span>remove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::remove </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes all the characters from this string beginning at a specified position and continuing through the last position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The position to begin deleting characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new string object that is equivalent to this string less the removed characters. </dd></dl>

</div>
</div>
<a id="a02a41355798abb8ab801e4709afae16c" name="a02a41355798abb8ab801e4709afae16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a41355798abb8ab801e4709afae16c">&#9670;&#160;</a></span>remove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::remove </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes all the characters from this string beginning at a specified position and continuing through the last position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The position to begin deleting characters. </td></tr>
    <tr><td class="paramname">count</td><td>The number of characters to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new string object that is equivalent to this string less the removed characters. </dd></dl>

</div>
</div>
<a id="a35618679cb579be47165cda420847c0b" name="a35618679cb579be47165cda420847c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35618679cb579be47165cda420847c0b">&#9670;&#160;</a></span>replace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>old_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>new_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces all occurrences of a specified string in this string with another specified string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_string</td><td>A string to be replaced. </td></tr>
    <tr><td class="paramname">new_string</td><td>A string to replace all occurrences of old_string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new string equivalent to the specified string but with all instances of old_string replaced with new_string. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If new_string is empty, all occurrences of old_string are removed </dd></dl>

</div>
</div>
<a id="a8f47776cd7a5e8b7137138c83e12c53d" name="a8f47776cd7a5e8b7137138c83e12c53d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f47776cd7a5e8b7137138c83e12c53d">&#9670;&#160;</a></span>replace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::replace </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>old_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>new_char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces all occurrences of a specified char_t in this string with another specified char_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_char</td><td>A char_t to be replaced. </td></tr>
    <tr><td class="paramname">new_char</td><td>A char_t to replace all occurrences of old_char. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new string equivalent to the specified string but with all instances of old_char replaced with new_char. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="file_info_replace_8cpp-example.html#a3">file_info_replace.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a66b33020b0d948fe3946a3535e8f8458" name="a66b33020b0d948fe3946a3535e8f8458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b33020b0d948fe3946a3535e8f8458">&#9670;&#160;</a></span>split() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classxtd_1_1ustring.html">ustring</a> &gt; xtd::ustring::split </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits this string into substrings that are based on the default white-space characters. White-space characters are defined by the c++ standard and return true if they are passed to the xtd::char_object::isspace() or std::iswspace() method. </p>
<dl class="section return"><dt>Returns</dt><dd>An array whose elements contain the substrings in this string that are delimited by one or more characters in white-space separators. For more information, see the Remarks section. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Delimiter characters are not included in the elements of the returned array. </dd>
<dd>
If the specified string does not contain any of the characters in separator, or the count parameter is 1, the returned array consists of a single element that contains the specified string. </dd></dl>

</div>
</div>
<a id="accdcbabd839bcc9dcea46df7ad5a8a18" name="accdcbabd839bcc9dcea46df7ad5a8a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accdcbabd839bcc9dcea46df7ad5a8a18">&#9670;&#160;</a></span>split() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classxtd_1_1ustring.html">ustring</a> &gt; xtd::ustring::split </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>separators</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits this string into substrings that are based on the characters in an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separators</td><td>A character array that delimits the substrings in this string, an empty array that contains no delimiters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array whose elements contain the substrings in this string that are delimited by one or more characters in separators. For more information, see the Remarks section. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Delimiter characters are not included in the elements of the returned array. </dd>
<dd>
If the specified string does not contain any of the characters in separator, or the count parameter is 1, the returned array consists of a single element that contains the specified string. </dd></dl>

</div>
</div>
<a id="a8cd5fd437bfcbac1c20e589e62200780" name="a8cd5fd437bfcbac1c20e589e62200780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cd5fd437bfcbac1c20e589e62200780">&#9670;&#160;</a></span>split() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classxtd_1_1ustring.html">ustring</a> &gt; xtd::ustring::split </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>separators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits this string into a maximum number of substrings based on the characters in an array. You also specify the maximum number of substrings to return. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separators</td><td>A character array that delimits the substrings in this string, an empty array that contains no delimiters. </td></tr>
    <tr><td class="paramname">count</td><td>The maximum number of substrings to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Delimiter characters are not included in the elements of the returned array. </dd>
<dd>
If the specified string does not contain any of the characters in separator, or the count parameter is 1, the returned array consists of a single element that contains the specified string. </dd>
<dd>
If the separator parameter contains no characters, white-space characters are assumed to be the delimiters. White-space characters are defined by the Unicode standard and return true if they are passed to the char_t.IsWhiteSpace method. </dd>
<dd>
Each element of separator defines a separate delimiter character. If two delimiters are adjacent, or a delimiter is found at the beginning or end of the specified string, the corresponding array element contains empty string. </dd>
<dd>
If there are more than count substrings in the specified string, the first count minus 1 substrings are returned in the first count minus 1 elements of the return value, and the remaining characters in the specified string are returned in the last element of the return value. </dd></dl>

</div>
</div>
<a id="a65cce1408f2ea06898b33f7427ad712b" name="a65cce1408f2ea06898b33f7427ad712b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65cce1408f2ea06898b33f7427ad712b">&#9670;&#160;</a></span>split() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classxtd_1_1ustring.html">ustring</a> &gt; xtd::ustring::split </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>separators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__xtd__core.html#ga1856f4f531626dc585fd1c8ccc6d596c">string_split_options</a>&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits this string into a maximum number of substrings based on the characters in an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separators</td><td>A character array that delimits the substrings in this string, an empty array that contains no delimiters. </td></tr>
    <tr><td class="paramname">count</td><td>The maximum number of substrings to return. </td></tr>
    <tr><td class="paramname">options</td><td><a class="el" href="group__xtd__core.html#gga1856f4f531626dc585fd1c8ccc6d596ca554bc886886f880e29b898519e657f9a" title="The return value does not include array elements that contain an empty string.">xtd::string_split_options::remove_empty_entries</a> to omit empty array elements from the array returned; or None to include empty array elements in the array returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array whose elements contain the substrings in this string that are delimited by one or more characters in separators. For more information, see the Remarks section. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Delimiter characters are not included in the elements of the returned array. </dd>
<dd>
If the specified string does not contain any of the characters in separator, or the count parameter is 1, the returned array consists of a single element that contains the specified string. </dd>
<dd>
If the count parameter is zero, or the options parameter is remove_empty_entries and the length of the specified string is zero, an empty array is returned. </dd>
<dd>
Each element of separator defines a separate delimiter character. If the options parameter is None, and two delimiters are adjacent or a delimiter is found at the beginning or end of the specified string, the corresponding array element contains an empty string. </dd>
<dd>
If there are more than count substrings in the specified string, the first count minus 1 substrings are returned in the first count minus 1 elements of the return value, and the remaining characters in the specified string are returned in the last element of the return value. </dd>
<dd>
If count is greater than the number of substrings, the available substrings are returned. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="split_8cpp-example.html#a1">split.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a7d254b792df2455b4c27886cf65cdfa2" name="a7d254b792df2455b4c27886cf65cdfa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d254b792df2455b4c27886cf65cdfa2">&#9670;&#160;</a></span>split() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classxtd_1_1ustring.html">ustring</a> &gt; xtd::ustring::split </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>separators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__xtd__core.html#ga1856f4f531626dc585fd1c8ccc6d596c">string_split_options</a>&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits this string into substrings based on the characters in an array. You can specify whether the substrings include empty array elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separators</td><td>A character array that delimits the substrings in this string, an empty array that contains no delimiters. </td></tr>
    <tr><td class="paramname">options</td><td><a class="el" href="group__xtd__core.html#gga1856f4f531626dc585fd1c8ccc6d596ca554bc886886f880e29b898519e657f9a" title="The return value does not include array elements that contain an empty string.">xtd::string_split_options::remove_empty_entries</a> to omit empty array elements from the array returned; or None to include empty array elements in the array returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array whose elements contain the substrings in this string that are delimited by one or more characters in separators. For more information, see the Remarks section. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Delimiter characters are not included in the elements of the returned array. </dd>
<dd>
If the specified string does not contain any of the characters in separator, or the count parameter is 1, the returned array consists of a single element that contains the specified string. </dd>
<dd>
If the specified string does not contain any of the characters in separator, the returned array consists of a single element that contains the specified string. </dd>
<dd>
If the options parameter is remove_empty_entries and the length of the specified string is zero, the method returns an empty array. </dd>
<dd>
Each element of separator defines a separate delimiter that consists of a single character. If the options argument is none, and two delimiters are adjacent or a delimiter is found at the beginning or end of the specified string, the corresponding array element contains empty string. For example, if separator includes two elements, "-" and "_", the value of the string instance is "-_aa-_", and the value of the options argument is None, the method returns a string array with the following five elements:<ol type="1">
<li>empty string, which represents the empty string that precedes the "-" character at index 0.</li>
<li>empty string, which represents the empty string between the "-" character at index 0 and the "_" character at index 1.</li>
<li>"aa",</li>
<li>empty string, which represents the empty string that follows the "_" character at index 4.</li>
<li>empty string, which represents the empty string that follows the "-" character at index 5. </li>
</ol>
</dd>
<dd>
If the separator parameter contains no characters, white-space characters are assumed to be the delimiters. White-space characters are defined by the c++ standard and return true if they are passed to the xtd::char_object::isspace() or std::iswspace() method. </dd>
<dd>
If count is greater than the number of substrings, the available substrings are returned. </dd></dl>

</div>
</div>
<a id="ab847e62a85bbb1eb9044b9e8ebaead55" name="ab847e62a85bbb1eb9044b9e8ebaead55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab847e62a85bbb1eb9044b9e8ebaead55">&#9670;&#160;</a></span>starts_with() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::ustring::starts_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the beginning of this instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> matches a specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if value matches the beginning of the specified string; otherwise, false. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method compares value to the substring at the beginning of the specified string that is the same length as value, and returns an indication whether they are equal. To be equal, value must be a reference to this same instance, or match the beginning of the specified string. </dd></dl>

</div>
</div>
<a id="af98b6ee462e44358380fd35f8afb8994" name="af98b6ee462e44358380fd35f8afb8994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af98b6ee462e44358380fd35f8afb8994">&#9670;&#160;</a></span>starts_with() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::ustring::starts_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_case</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the beginning of this instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> matches a specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>, ignoring or honoring their case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> to compare to. </td></tr>
    <tr><td class="paramname">ignore_case</td><td>true to ignore case when comparing the specified string and value; otherwise, false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if value matches the beginning of the specified string; otherwise, false. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method compares value to the substring at the beginning of the specified string that is the same length as value, and returns an indication whether they are equal. To be equal, value must be a reference to this same instance, or match the beginning of the specified string. </dd></dl>

</div>
</div>
<a id="ade5334d81e1d6756cb0db9aeefeb5cea" name="ade5334d81e1d6756cb0db9aeefeb5cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5334d81e1d6756cb0db9aeefeb5cea">&#9670;&#160;</a></span>starts_with() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::ustring::starts_with </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the beginning of this instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> matches a specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if value matches the beginning of the specified string; otherwise, false. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method compares value to the substring at the beginning of the specified string that is the same length as value, and returns an indication whether they are equal. To be equal, value must be a reference to this same instance, or match the beginning of the specified string. </dd></dl>

</div>
</div>
<a id="a7c8892581c00c768b278d9657ed6aecf" name="a7c8892581c00c768b278d9657ed6aecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8892581c00c768b278d9657ed6aecf">&#9670;&#160;</a></span>starts_with() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::ustring::starts_with </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_case</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the beginning of this instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> matches a specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>, ignoring or honoring their case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> to compare to. </td></tr>
    <tr><td class="paramname">ignore_case</td><td>true to ignore case when comparing the specified string and value; otherwise, false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if value matches the beginning of the specified string; otherwise, false. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method compares value to the substring at the beginning of the specified string that is the same length as value, and returns an indication whether they are equal. To be equal, value must be a reference to this same instance, or match the beginning of the specified string. </dd></dl>

</div>
</div>
<a id="ad27e596eab3904c5084c2d2cb7ae05a1" name="ad27e596eab3904c5084c2d2cb7ae05a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27e596eab3904c5084c2d2cb7ae05a1">&#9670;&#160;</a></span>substring() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::substring </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a substring from this instance. The substring starts at a specified character position and has a specified length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to substring. </td></tr>
    <tr><td class="paramname">start_index</td><td>The zero-based starting character position of a substring in this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string equivalent to the substring of length length that begins at start_index in this instance, or Empty if start_index is equal to the length of this instance and length is zero. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="test_forms_8cpp-example.html#a29">test_forms.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a3036669570cf96cc74bc68aad2098e53" name="a3036669570cf96cc74bc68aad2098e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3036669570cf96cc74bc68aad2098e53">&#9670;&#160;</a></span>substring() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::substring </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a substring from this instance. The substring starts at a specified character position and has a specified length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The zero-based starting character position of a substring in this instance. </td></tr>
    <tr><td class="paramname">length</td><td>The number of characters in the substring. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string equivalent to the substring of length length that begins at start_index in this instance, or Empty if start_index is equal to the length of this instance and length is zero. </dd></dl>

</div>
</div>
<a id="a53db7e47ebfb9f700184263cdffe90fc" name="a53db7e47ebfb9f700184263cdffe90fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53db7e47ebfb9f700184263cdffe90fc">&#9670;&#160;</a></span>to_array() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; value_type &gt; xtd::ustring::to_array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the characters in this instance to a Unicode character array. </p>
<dl class="section return"><dt>Returns</dt><dd>A character array whose elements are the individual characters of this instance. If this instance is an empty <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>, the returned array is empty and has a zero length. </dd></dl>

</div>
</div>
<a id="afbf5c498288cf53e891ec8a3227cd013" name="afbf5c498288cf53e891ec8a3227cd013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf5c498288cf53e891ec8a3227cd013">&#9670;&#160;</a></span>to_array() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; value_type &gt; xtd::ustring::to_array </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the characters in this instance to a Unicode character array starting at specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The starting position of string to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A character array whose elements are the individual characters of this instance. If this instance is an empty <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>, the returned array is empty and has a zero length. </dd></dl>

</div>
</div>
<a id="a0e16fac35c5b5145b14c0d8fa5059313" name="a0e16fac35c5b5145b14c0d8fa5059313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e16fac35c5b5145b14c0d8fa5059313">&#9670;&#160;</a></span>to_array() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; value_type &gt; xtd::ustring::to_array </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the characters in this instance to a Unicode character array starting at specified index with specified length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The starting position of string to convert. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the string to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A character array whose elements are the individual characters of this instance. If this instance is an empty <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>, the returned array is empty and has a zero length. </dd></dl>

</div>
</div>
<a id="af336a018fa7b2750e7cafe9dd708de4b" name="af336a018fa7b2750e7cafe9dd708de4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af336a018fa7b2750e7cafe9dd708de4b">&#9670;&#160;</a></span>to_lower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::to_lower </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the current string converted to lowercase. </p>
<dl class="section return"><dt>Returns</dt><dd>A new string in lowercase. </dd></dl>

</div>
</div>
<a id="ae1e5a8801e4f4c333649a0920b13b4d7" name="ae1e5a8801e4f4c333649a0920b13b4d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e5a8801e4f4c333649a0920b13b4d7">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a sxd::ustring that represents the current object. </p>
<dl class="section return"><dt>Returns</dt><dd>A string that represents the current object. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates what to_string returns. <div class="fragment"></div><!-- fragment --> </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1object.html#a5682215ee76ab97c48580ab162c49507">xtd::object</a>.</p>

</div>
</div>
<a id="a83cfd867b93120e50dc74d94081d0526" name="a83cfd867b93120e50dc74d94081d0526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83cfd867b93120e50dc74d94081d0526">&#9670;&#160;</a></span>to_title_case()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::to_title_case </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the current string to title case (except for words that are entirely in uppercase, which are considered to be acronyms). </p>
<dl class="section return"><dt>Returns</dt><dd>A new string in title case. </dd></dl>

</div>
</div>
<a id="a459c7cf5ab46bbce3088c6f8b0c87081" name="a459c7cf5ab46bbce3088c6f8b0c87081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a459c7cf5ab46bbce3088c6f8b0c87081">&#9670;&#160;</a></span>to_upper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::to_upper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the current string converted to uppercase. </p>
<dl class="section return"><dt>Returns</dt><dd>A new string in uppercase. </dd></dl>

</div>
</div>
<a id="a6521e1bcb7f90cc6e5678454c2488e0a" name="a6521e1bcb7f90cc6e5678454c2488e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6521e1bcb7f90cc6e5678454c2488e0a">&#9670;&#160;</a></span>trim() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::trim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all leading and trailing occurrences of white-space characters from the specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> to trim end. </td></tr>
    <tr><td class="paramname">trim_char</td><td>A character to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> that remains after all occurrences of the character in the trim_char parameter are removed from the start and te and of the specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>. </dd></dl>

</div>
</div>
<a id="a201e55d40c55a79e7a10e884c2f472c1" name="a201e55d40c55a79e7a10e884c2f472c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a201e55d40c55a79e7a10e884c2f472c1">&#9670;&#160;</a></span>trim() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::trim </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>trim_chars</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all leading and trailing occurrences of a set of characters specified in an array from the specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> to trim end. </td></tr>
    <tr><td class="paramname">trim_chars</td><td>An array of characters to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> that remains after all occurrences of the characters in the trim_chars parameter are removed from the start and the edn of the specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>. </dd></dl>

</div>
</div>
<a id="a47ee5015736be282dd15a37aed0dcb47" name="a47ee5015736be282dd15a37aed0dcb47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ee5015736be282dd15a37aed0dcb47">&#9670;&#160;</a></span>trim() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::trim </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>trim_char</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all leading and trailing occurrences of a character specified from the specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> to trim start. </td></tr>
    <tr><td class="paramname">trim_char</td><td>A character to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> that remains after all occurrences of the character in the trim_char parameter are removed from the start and the end of the specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>. </dd></dl>

</div>
</div>
<a id="a6d193fc8b669cf1d49b92fd0fab9ed0f" name="a6d193fc8b669cf1d49b92fd0fab9ed0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d193fc8b669cf1d49b92fd0fab9ed0f">&#9670;&#160;</a></span>trim_end() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::trim_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all trailing occurrences of white-space characters from the specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> to trim end. </td></tr>
    <tr><td class="paramname">trim_char</td><td>A character to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> that remains after all occurrences of the character in the trim_char parameter are removed from the end of the specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>. </dd></dl>

</div>
</div>
<a id="abf27752e3802e2d62fd358004b5c419e" name="abf27752e3802e2d62fd358004b5c419e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf27752e3802e2d62fd358004b5c419e">&#9670;&#160;</a></span>trim_end() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::trim_end </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>trim_chars</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all trailing occurrences of a set of characters specified in an array from the specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> to trim end. </td></tr>
    <tr><td class="paramname">trim_chars</td><td>An array of characters to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> that remains after all occurrences of the characters in the trim_chars parameter are removed from the end of the specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>. </dd></dl>

</div>
</div>
<a id="aa517a64d866a66f04511e9bad2d2af35" name="aa517a64d866a66f04511e9bad2d2af35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa517a64d866a66f04511e9bad2d2af35">&#9670;&#160;</a></span>trim_end() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::trim_end </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>trim_char</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all trailing occurrences of a character specified from the specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> to trim start. </td></tr>
    <tr><td class="paramname">trim_char</td><td>A character to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> that remains after all occurrences of the character in the trim_char parameter are removed from the end of the specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>. </dd></dl>

</div>
</div>
<a id="a8778eb32e44c58c7f9576cd2bf5bfceb" name="a8778eb32e44c58c7f9576cd2bf5bfceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8778eb32e44c58c7f9576cd2bf5bfceb">&#9670;&#160;</a></span>trim_start() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::trim_start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all leading occurrences of white-space characters from the specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> to trim start. </td></tr>
    <tr><td class="paramname">trim_char</td><td>A character to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> that remains after all occurrences of the character in the trim_char parameter are removed from the start of the specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>. </dd></dl>

</div>
</div>
<a id="aceb88ae933c826a42b98beab955d0199" name="aceb88ae933c826a42b98beab955d0199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceb88ae933c826a42b98beab955d0199">&#9670;&#160;</a></span>trim_start() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::trim_start </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>trim_chars</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all leading occurrences of a set of characters specified in an array from the specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>An <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> to trim start. </td></tr>
    <tr><td class="paramname">trim_chars</td><td>An array of characters to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> that remains after all occurrences of the characters in the trim_chars parameter are removed from the start of the specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>. </dd></dl>

</div>
</div>
<a id="af5bc64baa95dea6d1d28d79438899a31" name="af5bc64baa95dea6d1d28d79438899a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5bc64baa95dea6d1d28d79438899a31">&#9670;&#160;</a></span>trim_start() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::trim_start </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>trim_char</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all leading occurrences of a character specified from the specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> to trim start. </td></tr>
    <tr><td class="paramname">trim_char</td><td>A character to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> that remains after all occurrences of the character in the trim_char parameter are removed from the start of the specified <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>. </dd></dl>

</div>
</div>
<a id="a6f18368ae92eefe4fe5eb5125d0f02bb" name="a6f18368ae92eefe4fe5eb5125d0f02bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f18368ae92eefe4fe5eb5125d0f02bb">&#9670;&#160;</a></span>try_parse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::ustring::try_parse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to convert a string into a value_t type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>An <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> to convert to value_t </td></tr>
    <tr><td class="paramname">value</td><td>The value that will contain the parsed <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>:=:try_parse succed; otherwise, false. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ad2a9ab2b0dea8ef1ad59d47a49647d5b" name="ad2a9ab2b0dea8ef1ad59d47a49647d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2a9ab2b0dea8ef1ad59d47a49647d5b">&#9670;&#160;</a></span>empty_string</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::empty_string</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the empty string. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The value of this method is the zero-length string, "". </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/<a class="el" href="ustring_8h_source.html">ustring.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat May 11 2024 21:12:17 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
