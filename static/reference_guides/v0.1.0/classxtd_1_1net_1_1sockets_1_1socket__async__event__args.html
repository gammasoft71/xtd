<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<meta name="generator" content="Doxygen 1.9.6"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		<title>xtd - Reference Guide: xtd::net::sockets::socket_async_event_args Class Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
	</head>
	<body>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
			<table cellspacing="0" cellpadding="0">
				<tbody>
					<tr style="height: 56px;">
						<td id="projectlogo"><img alt="Logo" src="xtd_doxygen.png"/></td>
						<td id="projectalign" style="padding-left: 0.5em;">
							<div id="projectname">xtd - Reference Guide
								&#160;<span id="projectnumber">0.1.0</span>
							</div>
							<div id="projectbrief">Modern c++17/20 framework to create console, GUI and unit test applications on Windows, macOS, Linux, iOS and android.</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part --><!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="namespacextd_1_1net.html">net</a></li><li class="navelem"><a class="el" href="namespacextd_1_1net_1_1sockets.html">sockets</a></li><li class="navelem"><a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html">socket_async_event_args</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::net::sockets::socket_async_event_args Class Reference<div class="ingroups"><a class="el" href="group__libraries.html">libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="socket__async__event__args_8h_source.html">socket_async_event_args.h</a>&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><p>Represents an asynchronous socket operation. </p>
<dl class="section user"><dt>Namespace</dt><dd><a class="el" href="namespacextd_1_1net_1_1sockets.html" title="The xtd::net::sockets namespace provides a managed implementation of the Berkeley Sockets interface f...">xtd::net::sockets</a> </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html" title="Represents an asynchronous socket operation.">xtd::net::sockets::socket_async_event_args</a> class is part of a set of enhancements to the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket.html" title="Implements the Berkeley sockets interface.">xtd::net::sockets::socket</a> class that provide an alternative asynchronous pattern that can be used by specialized high-performance socket applications. This class was specifically designed for network server applications that require high performance. An application can use the enhanced asynchronous pattern exclusively or only in targeted hot areas (for example, when receiving large amounts of data). </dd>
<dd>
The main feature of these enhancements is the avoidance of the repeated allocation and synchronization of objects during high-volume asynchronous socket I/O. The Begin/End design pattern currently implemented by the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket.html" title="Implements the Berkeley sockets interface.">xtd::net::sockets::socket</a> class requires a <a class="el" href="classxtd_1_1iasync__result.html" title="Represents the status of an asynchronous operation.">xtd::iasync_result</a> object be allocated for each asynchronous socket operation. </dd>
<dd>
In the new <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket.html" title="Implements the Berkeley sockets interface.">xtd::net::sockets::socket</a> class enhancements, asynchronous socket operations are described by reusable <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html" title="Represents an asynchronous socket operation.">xtd::net::sockets::socket_async_event_args</a> objects allocated and maintained by the application. High-performance socket applications know best the amount of overlapped socket operations that must be sustained. The application can create as many of the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html" title="Represents an asynchronous socket operation.">xtd::net::sockets::socket_async_event_args</a> objects that it needs. For example, if a server application needs to have 15 socket accept operations outstanding at all times to support incoming client connection rates, it can allocate 15 reusable <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html" title="Represents an asynchronous socket operation.">xtd::net::sockets::socket_async_event_args</a> objects for that purpose. </dd>
<dd>
The pattern for performing an asynchronous socket operation with this class consists of the following steps:<ol type="1">
<li>Allocate a new <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html" title="Represents an asynchronous socket operation.">xtd::net::sockets::socket_async_event_args</a> context object, or get a free one from an application pool.</li>
<li>Set properties on the context object to the operation about to be performed (the completion callback method, the data buffer, the offset into the buffer, and the maximum amount of data to transfer, for example).</li>
<li>Call the appropriate socket method (xxx_async) to initiate the asynchronous operation.</li>
<li>If the asynchronous socket method (xxx_async) returns true, in the callback, query the context properties for completion status.</li>
<li>If the asynchronous socket method (xxx_async) returns false, the operation completed synchronously. The context properties may be queried for the operation result.</li>
<li>Reuse the context for another operation, put it back in the pool, or discard it. </li>
</ol>
</dd>
<dd>
The lifetime of the new asynchronous socket operation context object is determined by references by the application code and asynchronous I/O references. It is not necessary for the application to retain a reference to an asynchronous socket operation context object after it is submitted as a parameter to one of the asynchronous socket operation methods. It will remain referenced until the completion callback returns. However it is advantageous for the application to retain the reference to the context so that it can be reused for a future asynchronous socket operation. </dd></dl>
</div>
<p>Inherits <a class="el" href="classxtd_1_1event__args.html">xtd::event_args</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a65c79e79a22401e10029936fee2c239d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1event.html">xtd::event</a>&lt; <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html">socket_async_event_args</a>, xtd::delegate&lt; void(const <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html">socket_async_event_args</a> &amp;)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html#a65c79e79a22401e10029936fee2c239d">completed</a></td></tr>
<tr class="memdesc:a65c79e79a22401e10029936fee2c239d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The event used to complete an asynchronous operation.  <br /></td></tr>
<tr class="separator:a65c79e79a22401e10029936fee2c239d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afcf275879500d3f4f44e9acbbef5a4ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html#afcf275879500d3f4f44e9acbbef5a4ad">socket_async_event_args</a> ()=default</td></tr>
<tr class="memdesc:afcf275879500d3f4f44e9acbbef5a4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html" title="Represents an asynchronous socket operation.">xtd::net::sockets::socket_async_event_args</a> instance.  <br /></td></tr>
<tr class="separator:afcf275879500d3f4f44e9acbbef5a4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc5080dc2c0825e3bb5d3b3d033fd7e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html#a1cc5080dc2c0825e3bb5d3b3d033fd7e">socket_async_event_args</a> (bool suppress_execution_context_flow)</td></tr>
<tr class="memdesc:a1cc5080dc2c0825e3bb5d3b3d033fd7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the SocketAsyncEventArgs.  <br /></td></tr>
<tr class="separator:a1cc5080dc2c0825e3bb5d3b3d033fd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4a76dd4371da9f79a0527d2d654251"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1net_1_1sockets_1_1socket.html">xtd::net::sockets::socket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html#a6e4a76dd4371da9f79a0527d2d654251">accept_socket</a> () const noexcept</td></tr>
<tr class="memdesc:a6e4a76dd4371da9f79a0527d2d654251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the socket to use or the socket created for accepting a connection with an asynchronous socket method.  <br /></td></tr>
<tr class="separator:a6e4a76dd4371da9f79a0527d2d654251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087f0f8595a2005dfb80fe589c568b37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html">socket_async_event_args</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html#a087f0f8595a2005dfb80fe589c568b37">accept_socket</a> (const <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket.html">xtd::net::sockets::socket</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a087f0f8595a2005dfb80fe589c568b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the socket to use or the socket created for accepting a connection with an asynchronous socket method.  <br /></td></tr>
<tr class="separator:a087f0f8595a2005dfb80fe589c568b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52c8894b25f86c096349fa62781917b"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; byte_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html#aa52c8894b25f86c096349fa62781917b">buffer</a> () const noexcept</td></tr>
<tr class="memdesc:aa52c8894b25f86c096349fa62781917b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the data buffer to use with an asynchronous socket method.  <br /></td></tr>
<tr class="separator:aa52c8894b25f86c096349fa62781917b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3929d0b71041b6a8222d565c9f839fe3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; byte_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html#a3929d0b71041b6a8222d565c9f839fe3">buffer</a> () noexcept</td></tr>
<tr class="memdesc:a3929d0b71041b6a8222d565c9f839fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the data buffer to use with an asynchronous socket method.  <br /></td></tr>
<tr class="separator:a3929d0b71041b6a8222d565c9f839fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4bdda9889c1d7f69b1f969af9cbda8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html#aff4bdda9889c1d7f69b1f969af9cbda8">set_buffer</a> (const std::vector&lt; byte_t &gt; &amp;<a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html#aa52c8894b25f86c096349fa62781917b">buffer</a>, size_t count, size_t offset)</td></tr>
<tr class="memdesc:aff4bdda9889c1d7f69b1f969af9cbda8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the data buffer to use with an asynchronous socket method.  <br /></td></tr>
<tr class="separator:aff4bdda9889c1d7f69b1f969af9cbda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497d7d9bc5b23027e97a298bc12b9f47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html#a497d7d9bc5b23027e97a298bc12b9f47">set_buffer</a> (const std::vector&lt; byte_t &gt; &amp;memory_buffer)</td></tr>
<tr class="memdesc:a497d7d9bc5b23027e97a298bc12b9f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the region of memory to use as a buffer with an asynchronous socket method.  <br /></td></tr>
<tr class="separator:a497d7d9bc5b23027e97a298bc12b9f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc17f9f31faa33850866560a068ee38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html#abdc17f9f31faa33850866560a068ee38">set_buffer</a> (size_t offset, size_t count)</td></tr>
<tr class="memdesc:abdc17f9f31faa33850866560a068ee38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the data buffer to use with an asynchronous socket method.  <br /></td></tr>
<tr class="separator:abdc17f9f31faa33850866560a068ee38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1event__args"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1event__args')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1event__args.html">xtd::event_args</a></td></tr>
<tr class="memitem:a853a24151468fffbafa1024a199a1091 inherit pub_methods_classxtd_1_1event__args"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1event__args.html#a853a24151468fffbafa1024a199a1091">event_args</a> ()=default</td></tr>
<tr class="memdesc:a853a24151468fffbafa1024a199a1091 inherit pub_methods_classxtd_1_1event__args"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1event__args.html" title="Represents the base class for classes that contain event data, and provides a value to use for events...">event_args</a> class.  <br /></td></tr>
<tr class="separator:a853a24151468fffbafa1024a199a1091 inherit pub_methods_classxtd_1_1event__args"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1object.html">xtd::object</a></td></tr>
<tr class="memitem:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ad2cab851376bb6ca085b567bf5da0f5f">object</a> ()=default</td></tr>
<tr class="memdesc:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of the ultimate base class object.  <br /></td></tr>
<tr class="separator:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2743b6f75405882c28eebe2456f3837b inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a2743b6f75405882c28eebe2456f3837b">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;obj) const noexcept</td></tr>
<tr class="memdesc:a2743b6f75405882c28eebe2456f3837b inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object is equal to the current object.  <br /></td></tr>
<tr class="separator:a2743b6f75405882c28eebe2456f3837b inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a1fea096f8a49ac5eef1f2431806109ca">get_hash_code</a> () const noexcept</td></tr>
<tr class="memdesc:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serves as a hash function for a particular type.  <br /></td></tr>
<tr class="separator:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1d6739fb74be554719eced219de59a inherit pub_methods_classxtd_1_1object"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:a7d1d6739fb74be554719eced219de59a inherit pub_methods_classxtd_1_1object"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; object_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a7d1d6739fb74be554719eced219de59a">memberwise_clone</a> () const</td></tr>
<tr class="memdesc:a7d1d6739fb74be554719eced219de59a inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the current instance.  <br /></td></tr>
<tr class="separator:a7d1d6739fb74be554719eced219de59a inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5682215ee76ab97c48580ab162c49507 inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1ustring.html">xtd::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a5682215ee76ab97c48580ab162c49507">to_string</a> () const noexcept</td></tr>
<tr class="memdesc:a5682215ee76ab97c48580ab162c49507 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a std::string that represents the current object.  <br /></td></tr>
<tr class="separator:a5682215ee76ab97c48580ab162c49507 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a0fa91c0d31760f45d51aa75df4172332"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html#a0fa91c0d31760f45d51aa75df4172332">on_complete</a> (const <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html">socket_async_event_args</a> &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae1671797c52e15f763380b45e841ec32">e</a>)</td></tr>
<tr class="memdesc:a0fa91c0d31760f45d51aa75df4172332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a method that is called when an asynchronous operation completes.  <br /></td></tr>
<tr class="separator:a0fa91c0d31760f45d51aa75df4172332"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_attribs_classxtd_1_1event__args"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classxtd_1_1event__args')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classxtd_1_1event__args.html">xtd::event_args</a></td></tr>
<tr class="memitem:a57d59e60c60a648d26aa9e8cee2986ff inherit pub_static_attribs_classxtd_1_1event__args"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1event__args.html">event_args</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1event__args.html#a57d59e60c60a648d26aa9e8cee2986ff">empty</a></td></tr>
<tr class="memdesc:a57d59e60c60a648d26aa9e8cee2986ff inherit pub_static_attribs_classxtd_1_1event__args"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a value to use with events that do not have event data.  <br /></td></tr>
<tr class="separator:a57d59e60c60a648d26aa9e8cee2986ff inherit pub_static_attribs_classxtd_1_1event__args"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classxtd_1_1object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classxtd_1_1object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classxtd_1_1object.html">xtd::object</a></td></tr>
<tr class="memitem:a75cb9ed56172fb088ca6697d5d836b13 inherit pub_static_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a75cb9ed56172fb088ca6697d5d836b13">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_a, const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a75cb9ed56172fb088ca6697d5d836b13 inherit pub_static_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are considered equal.  <br /></td></tr>
<tr class="separator:a75cb9ed56172fb088ca6697d5d836b13 inherit pub_static_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee13700465eead7934f450749b952d7 inherit pub_static_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a1ee13700465eead7934f450749b952d7">reference_equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_a, const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a1ee13700465eead7934f450749b952d7 inherit pub_static_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are the same instance.  <br /></td></tr>
<tr class="separator:a1ee13700465eead7934f450749b952d7 inherit pub_static_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afcf275879500d3f4f44e9acbbef5a4ad" name="afcf275879500d3f4f44e9acbbef5a4ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcf275879500d3f4f44e9acbbef5a4ad">&#9670;&#160;</a></span>socket_async_event_args() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::net::sockets::socket_async_event_args::socket_async_event_args </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an empty <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html" title="Represents an asynchronous socket operation.">xtd::net::sockets::socket_async_event_args</a> instance. </p>
<dl class="section remark"><dt>Remarks</dt><dd>After calling this constructor all properties will have their default values:<ul>
<li>Object references will be null.</li>
<li>Properties that return an integer will return zero.</li>
<li>The xtd::net::sockets::socket_async_event_args::last_operation property will be equal to xtd::net::sockets::async_operation::none.</li>
<li>The xtd::net::sockets::socket_async_event_args::send_packets_flags property will be equal to <a class="el" href="group__xtd__core.html#gga926d52df9c101c748dd0e8b68dd91880a627224438c682e7853f4814e1ebafc49" title="Use the default thread to process long file transfer requests.">xtd::net::sockets::transmit_file_options::use_default_worker_thread</a>, which specifies no flags will be used.</li>
<li>The xtd::net::sockets::socket_async_event_args::socket_flags property will be equal to xtd::net::sockets::async_operation::none. </li>
</ul>
</dd>
<dd>
The caller must set the appropriate properties prior to passing the object to the appropriate asynchronous socket (xxx_async) method. </dd></dl>

</div>
</div>
<a id="a1cc5080dc2c0825e3bb5d3b3d033fd7e" name="a1cc5080dc2c0825e3bb5d3b3d033fd7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc5080dc2c0825e3bb5d3b3d033fd7e">&#9670;&#160;</a></span>socket_async_event_args() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::net::sockets::socket_async_event_args::socket_async_event_args </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>suppress_execution_context_flow</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the SocketAsyncEventArgs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">suppress_execution_context_flow</td><td>Whether to disable the capturing and flow of execution context. Execution context flow should only be disabled if it's handled by higher layers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6e4a76dd4371da9f79a0527d2d654251" name="a6e4a76dd4371da9f79a0527d2d654251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4a76dd4371da9f79a0527d2d654251">&#9670;&#160;</a></span>accept_socket() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1net_1_1sockets_1_1socket.html">xtd::net::sockets::socket</a> xtd::net::sockets::socket_async_event_args::accept_socket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the socket to use or the socket created for accepting a connection with an asynchronous socket method. </p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket.html" title="Implements the Berkeley sockets interface.">xtd::net::sockets::socket</a> to use or the socket created for accepting a connection with an asynchronous socket method. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This property can be used to provide an already created Socket that will be used for an asynchronous socket accept operation. Upon completion of the accept operation, it is the socket representing the accepted connection. If not supplied (set to empty) before calling the xtd::net::sockets::socket::acceptA_async method, a new socket will be created automatically and be accessible in the completion callback with this property. </dd></dl>

</div>
</div>
<a id="a087f0f8595a2005dfb80fe589c568b37" name="a087f0f8595a2005dfb80fe589c568b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087f0f8595a2005dfb80fe589c568b37">&#9670;&#160;</a></span>accept_socket() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html">socket_async_event_args</a> &amp; xtd::net::sockets::socket_async_event_args::accept_socket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket.html">xtd::net::sockets::socket</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the socket to use or the socket created for accepting a connection with an asynchronous socket method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket.html" title="Implements the Berkeley sockets interface.">xtd::net::sockets::socket</a> to use or the socket created for accepting a connection with an asynchronous socket method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This property can be used to provide an already created Socket that will be used for an asynchronous socket accept operation. Upon completion of the accept operation, it is the socket representing the accepted connection. If not supplied (set to empty) before calling the xtd::net::sockets::socket::acceptA_async method, a new socket will be created automatically and be accessible in the completion callback with this property. </dd></dl>

</div>
</div>
<a id="aa52c8894b25f86c096349fa62781917b" name="aa52c8894b25f86c096349fa62781917b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa52c8894b25f86c096349fa62781917b">&#9670;&#160;</a></span>buffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; byte_t &gt; &amp; xtd::net::sockets::socket_async_event_args::buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the data buffer to use with an asynchronous socket method. </p>
<dl class="section return"><dt>Returns</dt><dd>A Byte array that represents the data buffer to use with an asynchronous socket method. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This property gets the data buffer currently associated with the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html" title="Represents an asynchronous socket operation.">xtd::net::sockets::socket_async_event_args</a> instance. To set the buffer, the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html#a497d7d9bc5b23027e97a298bc12b9f47" title="Sets the region of memory to use as a buffer with an asynchronous socket method.">xtd::net::sockets::socket_async_event_args::set_buffer</a> method must be used. </dd>
<dd>
This property is used with the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket.html#a23b63649d41275359b475ef60c279cf5" title="Begins an asynchronous operation to accept an incoming connection attempt.">xtd::net::sockets::socket::accept_async</a>, xtd::net::sockets::socket::connect_async, xtd::net::sockets::socket::receive_async, xtd::net::sockets::socket::receive_from_async, xtd::net::sockets::socket::receive_message_from_async, xtd::net::sockets::socket::send_async, and xtd::net::sockets::socket::send_to_async methods. </dd></dl>

</div>
</div>
<a id="a3929d0b71041b6a8222d565c9f839fe3" name="a3929d0b71041b6a8222d565c9f839fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3929d0b71041b6a8222d565c9f839fe3">&#9670;&#160;</a></span>buffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; byte_t &gt; &amp; xtd::net::sockets::socket_async_event_args::buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the data buffer to use with an asynchronous socket method. </p>
<dl class="section return"><dt>Returns</dt><dd>A Byte array that represents the data buffer to use with an asynchronous socket method. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This property gets the data buffer currently associated with the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html" title="Represents an asynchronous socket operation.">xtd::net::sockets::socket_async_event_args</a> instance. To set the buffer, the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html#a497d7d9bc5b23027e97a298bc12b9f47" title="Sets the region of memory to use as a buffer with an asynchronous socket method.">xtd::net::sockets::socket_async_event_args::set_buffer</a> method must be used. </dd>
<dd>
This property is used with the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket.html#a23b63649d41275359b475ef60c279cf5" title="Begins an asynchronous operation to accept an incoming connection attempt.">xtd::net::sockets::socket::accept_async</a>, xtd::net::sockets::socket::connect_async, xtd::net::sockets::socket::receive_async, xtd::net::sockets::socket::receive_from_async, xtd::net::sockets::socket::receive_message_from_async, xtd::net::sockets::socket::send_async, and xtd::net::sockets::socket::send_to_async methods. </dd></dl>

</div>
</div>
<a id="a0fa91c0d31760f45d51aa75df4172332" name="a0fa91c0d31760f45d51aa75df4172332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa91c0d31760f45d51aa75df4172332">&#9670;&#160;</a></span>on_complete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void xtd::net::sockets::socket_async_event_args::on_complete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html">socket_async_event_args</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents a method that is called when an asynchronous operation completes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The event that is signaled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method is not callable by user code. This method gets called by the internals of the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html" title="Represents an asynchronous socket operation.">xtd::net::sockets::socket_async_event_args</a> object when the current operation is complete. This method is used with all asynchronous socket (xxx_async) methods. </dd>
<dd>
An application that creates a class inheriting from <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html" title="Represents an asynchronous socket operation.">xtd::net::sockets::socket_async_event_args</a> can override this method to hook into this completion notification and clean up any resources that it allocated for the operation. The default implementation just raises the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html#a65c79e79a22401e10029936fee2c239d" title="The event used to complete an asynchronous operation.">xtd::net::sockets::socket_async_event_args::completed</a> event. </dd>
<dd>
This method is used to hook up an event handler to be used as the completion callback for a subsequent asynchronous socket operation. The caller must implement at least one callback delegate inherited from this method prior to starting an asynchronous socket operation using one of the asynchronous (xxx_async) methods on the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket.html" title="Implements the Berkeley sockets interface.">xtd::net::sockets::socket</a> class. </dd>
<dd>
The caller's xtd::net::sockets::socket_async_event_args::on_completed method provides a way for client applications to complete an asynchronous socket operation. A callback delegate must be implemented when an asynchronous socket operation is initiated. The completion callback delegate(s) inherited from the xtd::net::sockets::socket_async_event_args::on_completed method must contain program logic to finish processing the asynchronous socket operation for the client. </dd>
<dd>
When an asynchronous operation is signaled, the application uses the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html" title="Represents an asynchronous socket operation.">xtd::net::sockets::socket_async_event_args</a> object parameter to obtain status of the completed asynchronous socket operation. </dd></dl>

</div>
</div>
<a id="aff4bdda9889c1d7f69b1f969af9cbda8" name="aff4bdda9889c1d7f69b1f969af9cbda8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff4bdda9889c1d7f69b1f969af9cbda8">&#9670;&#160;</a></span>set_buffer() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::net::sockets::socket_async_event_args::set_buffer </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the data buffer to use with an asynchronous socket method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The data buffer to use with an asynchronous socket method. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset, in bytes, in the data buffer where the operation starts. </td></tr>
    <tr><td class="paramname">count</td><td>The maximum amount of data, in bytes, to send or receive in the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>An argument was out of range. This exception occurs if the offset parameter is greater than the length of the array in the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html#aa52c8894b25f86c096349fa62781917b" title="Gets the data buffer to use with an asynchronous socket method.">xtd::net::sockets::socket_async_event_args::buffer</a> property. This exception also occurs if the count parameter is greater than the length of the array in the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html#aa52c8894b25f86c096349fa62781917b" title="Gets the data buffer to use with an asynchronous socket method.">xtd::net::sockets::socket_async_event_args::buffer</a> property minus the offset parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The offset and count parameters can't be negative numbers. The combination of the offset and count parameters must be in bounds of the data array in the buffer parameter. </dd>
<dd>
This method sets the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html#aa52c8894b25f86c096349fa62781917b" title="Gets the data buffer to use with an asynchronous socket method.">xtd::net::sockets::socket_async_event_args::buffer</a> property to the buffer parameter, the xtd::net::sockets::socket_async_event_args::count property to the count parameter, and the xtd::net::sockets::socket_async_event_args::offset property to the offset parameter. </dd></dl>

</div>
</div>
<a id="a497d7d9bc5b23027e97a298bc12b9f47" name="a497d7d9bc5b23027e97a298bc12b9f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a497d7d9bc5b23027e97a298bc12b9f47">&#9670;&#160;</a></span>set_buffer() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::net::sockets::socket_async_event_args::set_buffer </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>memory_buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the region of memory to use as a buffer with an asynchronous socket method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memory_buffer</td><td>The region of memory to use as a buffer with an asynchronous socket method. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abdc17f9f31faa33850866560a068ee38" name="abdc17f9f31faa33850866560a068ee38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc17f9f31faa33850866560a068ee38">&#9670;&#160;</a></span>set_buffer() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::net::sockets::socket_async_event_args::set_buffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the data buffer to use with an asynchronous socket method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The offset, in bytes, in the data buffer where the operation starts. </td></tr>
    <tr><td class="paramname">count</td><td>The maximum amount of data, in bytes, to send or receive in the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>An argument was out of range. This exception occurs if the offset parameter is greater than the length of the array in the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html#aa52c8894b25f86c096349fa62781917b" title="Gets the data buffer to use with an asynchronous socket method.">xtd::net::sockets::socket_async_event_args::buffer</a> property. This exception also occurs if the count parameter is greater than the length of the array in the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html#aa52c8894b25f86c096349fa62781917b" title="Gets the data buffer to use with an asynchronous socket method.">xtd::net::sockets::socket_async_event_args::buffer</a> property minus the offset parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The offset and count parameters can't be negative numbers. The combination of the offset and count parameters must be in bounds of the buffer array in the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html#aa52c8894b25f86c096349fa62781917b" title="Gets the data buffer to use with an asynchronous socket method.">xtd::net::sockets::socket_async_event_args::buffer</a> property. </dd>
<dd>
This method sets the xtd::net::sockets::socket_async_event_args::count property to the count parameter and the xtd::net::sockets::socket_async_event_args::offset property to the offset parameter. If the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html#aa52c8894b25f86c096349fa62781917b" title="Gets the data buffer to use with an asynchronous socket method.">xtd::net::sockets::socket_async_event_args::buffer</a> property is empty, this method ignores the offset and count parameters and sets the xtd::net::sockets::socket_async_event_args::offset and xtd::net::sockets::socket_async_event_args::count properties to 0. </dd>
<dd>
This method does not change the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html#aa52c8894b25f86c096349fa62781917b" title="Gets the data buffer to use with an asynchronous socket method.">xtd::net::sockets::socket_async_event_args::buffer</a> property. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a65c79e79a22401e10029936fee2c239d" name="a65c79e79a22401e10029936fee2c239d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c79e79a22401e10029936fee2c239d">&#9670;&#160;</a></span>completed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1event.html">xtd::event</a>&lt;<a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html">socket_async_event_args</a>, xtd::delegate&lt;void(const <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html">socket_async_event_args</a>&amp;)&gt; &gt; xtd::net::sockets::socket_async_event_args::completed</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The event used to complete an asynchronous operation. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html#a65c79e79a22401e10029936fee2c239d" title="The event used to complete an asynchronous operation.">xtd::net::sockets::socket_async_event_args::completed</a> event provides a way for client applications to complete an asynchronous socket operation. An event handler should be attached to the event within a <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html" title="Represents an asynchronous socket operation.">xtd::net::sockets::socket_async_event_args</a> instance when an asynchronous socket operation is initiated, otherwise the application will not be able to determine when the operation completes. </dd>
<dd>
The completion callback delegates referenced by the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html#a65c79e79a22401e10029936fee2c239d" title="The event used to complete an asynchronous operation.">xtd::net::sockets::socket_async_event_args::completed</a> event contains program logic to finish processing the asynchronous socket operation for the client. </dd>
<dd>
When the event is signaled, the application uses the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html" title="Represents an asynchronous socket operation.">xtd::net::sockets::socket_async_event_args</a> object parameter to obtain the status of the completed asynchronous socket operation. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/net/sockets/<a class="el" href="socket__async__event__args_8h_source.html">socket_async_event_args.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jan 28 2023 18:12:28 for xtd - Reference Guide by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
