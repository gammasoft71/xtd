<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<meta name="generator" content="Doxygen 1.9.7"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		<title>xtd - Reference Guide: xtd::ustring Class Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
	</head>
	<body>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
			<table cellspacing="0" cellpadding="0">
				<tbody>
					<tr style="height: 56px;">
						<td id="projectlogo"><img alt="Logo" src="xtd_doxygen.png"/></td>
						<td id="projectalign" style="padding-left: 0.5em;">
							<div id="projectname">xtd - Reference Guide
								&#160;<span id="projectnumber">0.1.2</span>
							</div>
							<div id="projectbrief">Modern c++17/20 framework to create console, GUI and unit test applications on Windows, macOS, Linux, iOS and android.</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part --><!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="classxtd_1_1ustring.html">ustring</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classxtd_1_1ustring-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::ustring Class Reference<div class="ingroups"><a class="el" href="group__libraries.html">libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="ustring_8h_source.html">ustring.h</a>&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><p>Represents text as a sequence of UTF-8 code units. </p>
<dl class="section user"><dt>Namespace</dt><dd>xtd </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>A string is a sequential collection of characters that's used to represent text. A <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> object is a sequential collection of <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a" title="Represents a 16-bit unicode character.">xtd::char8</a> objects that represent a string; a <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a" title="Represents a 16-bit unicode character.">xtd::char8</a> object corresponds to a UTF-8 code unit. The value of the <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> object is the content of the sequential collection of <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a" title="Represents a 16-bit unicode character.">xtd::char8</a> objects, and unlike std::basic_string that value is immutable (that is, it is read-only). </dd>
<dd>
if you want the same mutable string class, you can use xtd::text::ustring_builder class. </dd>
<dd>
<a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> is inherited from std::basic_string&lt;char&gt; and therefore offers the full (immutable) API of std::string. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="folder_browser_dialog_8cpp-example.html#_a6">folder_browser_dialog.cpp</a>, <a class="el" href="input_box_8cpp-example.html#_a1">input_box.cpp</a>, and <a class="el" href="open_file_dialog_8cpp-example.html#_a8">open_file_dialog.cpp</a>.</dd>
</dl>
</div>
<p>Inherits <a class="el" href="classxtd_1_1object.html">xtd::object</a>, and std::basic_string&lt; char &gt;.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:add61d5146149ee689a7f9bed1309cfad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#add61d5146149ee689a7f9bed1309cfad">ustring</a> () noexcept</td></tr>
<tr class="memdesc:add61d5146149ee689a7f9bed1309cfad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>.  <br /></td></tr>
<tr class="separator:add61d5146149ee689a7f9bed1309cfad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ceb01ac4e91b4e8d249438bb82bca5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a14ceb01ac4e91b4e8d249438bb82bca5">ustring</a> (char16_t *str)</td></tr>
<tr class="memdesc:a14ceb01ac4e91b4e8d249438bb82bca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:a14ceb01ac4e91b4e8d249438bb82bca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0bdd3aaccceb76e4c954980515aafee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ad0bdd3aaccceb76e4c954980515aafee">ustring</a> (char16_t *str, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:ad0bdd3aaccceb76e4c954980515aafee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator.  <br /></td></tr>
<tr class="separator:ad0bdd3aaccceb76e4c954980515aafee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac114e8fcb219ab9a4e5c24eb4d2859c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ac114e8fcb219ab9a4e5c24eb4d2859c5">ustring</a> (char32_t *str)</td></tr>
<tr class="memdesc:ac114e8fcb219ab9a4e5c24eb4d2859c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:ac114e8fcb219ab9a4e5c24eb4d2859c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5aaaef3ba5b68b59fb5c35d588edd6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a2b5aaaef3ba5b68b59fb5c35d588edd6">ustring</a> (char32_t *str, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a2b5aaaef3ba5b68b59fb5c35d588edd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator.  <br /></td></tr>
<tr class="separator:a2b5aaaef3ba5b68b59fb5c35d588edd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240c2a49a7a79d0b7507aafeaa589c97"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a240c2a49a7a79d0b7507aafeaa589c97">ustring</a> (char8_t *str)</td></tr>
<tr class="memdesc:a240c2a49a7a79d0b7507aafeaa589c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:a240c2a49a7a79d0b7507aafeaa589c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad2a2ae2c3230d2224e2f6f83f044b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#adad2a2ae2c3230d2224e2f6f83f044b3">ustring</a> (char8_t *str, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:adad2a2ae2c3230d2224e2f6f83f044b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator.  <br /></td></tr>
<tr class="separator:adad2a2ae2c3230d2224e2f6f83f044b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08170f266741991ebf47b057a34ba124"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a08170f266741991ebf47b057a34ba124">ustring</a> (const allocator_type &amp;allocator) noexcept</td></tr>
<tr class="memdesc:a08170f266741991ebf47b057a34ba124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified allocator.  <br /></td></tr>
<tr class="separator:a08170f266741991ebf47b057a34ba124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9369a25f55d85baee88d5582e48d60a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a9369a25f55d85baee88d5582e48d60a8">ustring</a> (const char16_t *str)</td></tr>
<tr class="memdesc:a9369a25f55d85baee88d5582e48d60a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:a9369a25f55d85baee88d5582e48d60a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b32bfe4c25616b5cf7235017a7ee69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ae5b32bfe4c25616b5cf7235017a7ee69">ustring</a> (const char16_t *str, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:ae5b32bfe4c25616b5cf7235017a7ee69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator.  <br /></td></tr>
<tr class="separator:ae5b32bfe4c25616b5cf7235017a7ee69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5568aa4bf07ade1928ee8bdf1572d960"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a5568aa4bf07ade1928ee8bdf1572d960">ustring</a> (const char32_t *str)</td></tr>
<tr class="memdesc:a5568aa4bf07ade1928ee8bdf1572d960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:a5568aa4bf07ade1928ee8bdf1572d960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034d5156c913a076caa79b2ffbdba894"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a034d5156c913a076caa79b2ffbdba894">ustring</a> (const char32_t *str, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a034d5156c913a076caa79b2ffbdba894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator.  <br /></td></tr>
<tr class="separator:a034d5156c913a076caa79b2ffbdba894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1d8d4fc56116870e6e9098e801abff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#aba1d8d4fc56116870e6e9098e801abff">ustring</a> (const char8_t *str)</td></tr>
<tr class="memdesc:aba1d8d4fc56116870e6e9098e801abff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:aba1d8d4fc56116870e6e9098e801abff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237d083b73a7a66e19352951564776cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a237d083b73a7a66e19352951564776cd">ustring</a> (const char8_t *str, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a237d083b73a7a66e19352951564776cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator.  <br /></td></tr>
<tr class="separator:a237d083b73a7a66e19352951564776cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d943de2665ca7471a3c7012f0ac85a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#aa1d943de2665ca7471a3c7012f0ac85a">ustring</a> (const std::string &amp;str) noexcept</td></tr>
<tr class="memdesc:aa1d943de2665ca7471a3c7012f0ac85a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:aa1d943de2665ca7471a3c7012f0ac85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c224c965990e3a8674037250c9c466d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a9c224c965990e3a8674037250c9c466d">ustring</a> (const std::string &amp;str, const allocator_type &amp;allocator) noexcept</td></tr>
<tr class="memdesc:a9c224c965990e3a8674037250c9c466d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy and allocator.  <br /></td></tr>
<tr class="separator:a9c224c965990e3a8674037250c9c466d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6819b6bf89183d64b7ac6d474772b07"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ae6819b6bf89183d64b7ac6d474772b07">ustring</a> (const std::u16string &amp;str) noexcept</td></tr>
<tr class="memdesc:ae6819b6bf89183d64b7ac6d474772b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:ae6819b6bf89183d64b7ac6d474772b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6c2740de5260fc6cc9d3fa7066fbfe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#abf6c2740de5260fc6cc9d3fa7066fbfe">ustring</a> (const std::u16string &amp;str, const allocator_type &amp;allocator) noexcept</td></tr>
<tr class="memdesc:abf6c2740de5260fc6cc9d3fa7066fbfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy and allocator.  <br /></td></tr>
<tr class="separator:abf6c2740de5260fc6cc9d3fa7066fbfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c728901774cc83ca604138421d6268"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ab8c728901774cc83ca604138421d6268">ustring</a> (const std::u32string &amp;str) noexcept</td></tr>
<tr class="memdesc:ab8c728901774cc83ca604138421d6268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:ab8c728901774cc83ca604138421d6268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4269aa64ca67c250c758763e6819cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ada4269aa64ca67c250c758763e6819cd">ustring</a> (const std::u32string &amp;str, const allocator_type &amp;allocator) noexcept</td></tr>
<tr class="memdesc:ada4269aa64ca67c250c758763e6819cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy and allocator.  <br /></td></tr>
<tr class="separator:ada4269aa64ca67c250c758763e6819cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fcf93d304874f014d6a802be7666c1c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a1fcf93d304874f014d6a802be7666c1c">ustring</a> (const std::u8string &amp;str) noexcept</td></tr>
<tr class="memdesc:a1fcf93d304874f014d6a802be7666c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:a1fcf93d304874f014d6a802be7666c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e269e43bbcacd9b0071ccb1fe5e158"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a31e269e43bbcacd9b0071ccb1fe5e158">ustring</a> (const std::u8string &amp;str, const allocator_type &amp;allocator) noexcept</td></tr>
<tr class="memdesc:a31e269e43bbcacd9b0071ccb1fe5e158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy and allocator.  <br /></td></tr>
<tr class="separator:a31e269e43bbcacd9b0071ccb1fe5e158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6051d53b2892b7585b6278a2a5601b9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ac6051d53b2892b7585b6278a2a5601b9">ustring</a> (const std::wstring &amp;str) noexcept</td></tr>
<tr class="memdesc:ac6051d53b2892b7585b6278a2a5601b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:ac6051d53b2892b7585b6278a2a5601b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c026c8d5a2e188a7737ea902ae9c9f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a2c026c8d5a2e188a7737ea902ae9c9f1">ustring</a> (const std::wstring &amp;str, const allocator_type &amp;allocator) noexcept</td></tr>
<tr class="memdesc:a2c026c8d5a2e188a7737ea902ae9c9f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy and allocator.  <br /></td></tr>
<tr class="separator:a2c026c8d5a2e188a7737ea902ae9c9f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaeedea48ef4f24dafe9ec8fb70092c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#acaeedea48ef4f24dafe9ec8fb70092c5">ustring</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str) noexcept</td></tr>
<tr class="memdesc:acaeedea48ef4f24dafe9ec8fb70092c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:acaeedea48ef4f24dafe9ec8fb70092c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ca1e3a8ea546462fe2490d87161e67"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a97ca1e3a8ea546462fe2490d87161e67">ustring</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str, const allocator_type &amp;allocator) noexcept</td></tr>
<tr class="memdesc:a97ca1e3a8ea546462fe2490d87161e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy and allocator.  <br /></td></tr>
<tr class="separator:a97ca1e3a8ea546462fe2490d87161e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0dd03c9c81d6dcf7686bf80ef7183b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ac0dd03c9c81d6dcf7686bf80ef7183b0">ustring</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str, size_t index)</td></tr>
<tr class="memdesc:ac0dd03c9c81d6dcf7686bf80ef7183b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified substring at index.  <br /></td></tr>
<tr class="separator:ac0dd03c9c81d6dcf7686bf80ef7183b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378a1ead97b2b5db84cc20e6dfd0a71d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a378a1ead97b2b5db84cc20e6dfd0a71d">ustring</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str, size_t index, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a378a1ead97b2b5db84cc20e6dfd0a71d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified substring at index and allocator.  <br /></td></tr>
<tr class="separator:a378a1ead97b2b5db84cc20e6dfd0a71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e9d9b1b3d1dd5c2431aff1fb936b34"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a09e9d9b1b3d1dd5c2431aff1fb936b34">ustring</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str, size_t index, size_t count)</td></tr>
<tr class="memdesc:a09e9d9b1b3d1dd5c2431aff1fb936b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified substring at index and count characters.  <br /></td></tr>
<tr class="separator:a09e9d9b1b3d1dd5c2431aff1fb936b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961a9ba4c72a3ef7e30ce00744fab282"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a961a9ba4c72a3ef7e30ce00744fab282">ustring</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str, size_t index, size_t count, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a961a9ba4c72a3ef7e30ce00744fab282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified substring at index, count characters and allocator.  <br /></td></tr>
<tr class="separator:a961a9ba4c72a3ef7e30ce00744fab282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c52720442dea9e80a0ee939e0e8644"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a22c52720442dea9e80a0ee939e0e8644">ustring</a> (const value_type *str)</td></tr>
<tr class="memdesc:a22c52720442dea9e80a0ee939e0e8644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:a22c52720442dea9e80a0ee939e0e8644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d9fbd84544ded58b56bb258c839977"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a82d9fbd84544ded58b56bb258c839977">ustring</a> (const value_type *str, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a82d9fbd84544ded58b56bb258c839977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator.  <br /></td></tr>
<tr class="separator:a82d9fbd84544ded58b56bb258c839977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175105db0d4fd8d70afd6bf68e901c43"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a175105db0d4fd8d70afd6bf68e901c43">ustring</a> (const value_type *str, size_t count)</td></tr>
<tr class="memdesc:a175105db0d4fd8d70afd6bf68e901c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified substring and count characters.  <br /></td></tr>
<tr class="separator:a175105db0d4fd8d70afd6bf68e901c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94daf332e8506577c406ff8be31a68ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a94daf332e8506577c406ff8be31a68ed">ustring</a> (const value_type *str, size_t count, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a94daf332e8506577c406ff8be31a68ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified substring, count characters and allocator.  <br /></td></tr>
<tr class="separator:a94daf332e8506577c406ff8be31a68ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175944050c9f206c169e9cf989f074e6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a175944050c9f206c169e9cf989f074e6">ustring</a> (const wchar_t *str)</td></tr>
<tr class="memdesc:a175944050c9f206c169e9cf989f074e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:a175944050c9f206c169e9cf989f074e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d993078380eb54472f7dd5ac45fa7c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a88d993078380eb54472f7dd5ac45fa7c">ustring</a> (const wchar_t *str, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a88d993078380eb54472f7dd5ac45fa7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator.  <br /></td></tr>
<tr class="separator:a88d993078380eb54472f7dd5ac45fa7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61f98b244908a02d90c8c6f6fcab6eb"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t &gt; </td></tr>
<tr class="memitem:ae61f98b244908a02d90c8c6f6fcab6eb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ae61f98b244908a02d90c8c6f6fcab6eb">ustring</a> (input_iterator_t first, input_iterator_t last)</td></tr>
<tr class="memdesc:ae61f98b244908a02d90c8c6f6fcab6eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified first and last iterators of substring.  <br /></td></tr>
<tr class="separator:ae61f98b244908a02d90c8c6f6fcab6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233f13e910222e1b5ca44df02b51e42f"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a233f13e910222e1b5ca44df02b51e42f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a233f13e910222e1b5ca44df02b51e42f">ustring</a> (input_iterator_t first, input_iterator_t last, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a233f13e910222e1b5ca44df02b51e42f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified first and last iterators of substring and allocator.  <br /></td></tr>
<tr class="separator:a233f13e910222e1b5ca44df02b51e42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea1c1140594578a58b076e047adac21"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#afea1c1140594578a58b076e047adac21">ustring</a> (size_t count, char16_t character)</td></tr>
<tr class="memdesc:afea1c1140594578a58b076e047adac21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character.  <br /></td></tr>
<tr class="separator:afea1c1140594578a58b076e047adac21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa8a8cb6172ef1752d3c25ecb29fd8c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#adfa8a8cb6172ef1752d3c25ecb29fd8c">ustring</a> (size_t count, char16_t character, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:adfa8a8cb6172ef1752d3c25ecb29fd8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character and specified allocator.  <br /></td></tr>
<tr class="separator:adfa8a8cb6172ef1752d3c25ecb29fd8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe57a6d7b4cb655ee1f16156de44b33b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#abe57a6d7b4cb655ee1f16156de44b33b">ustring</a> (size_t count, char32_t character)</td></tr>
<tr class="memdesc:abe57a6d7b4cb655ee1f16156de44b33b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character.  <br /></td></tr>
<tr class="separator:abe57a6d7b4cb655ee1f16156de44b33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82df5c1b3533255a3e0988f8b82c0938"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a82df5c1b3533255a3e0988f8b82c0938">ustring</a> (size_t count, char32_t character, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a82df5c1b3533255a3e0988f8b82c0938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character and specified allocator.  <br /></td></tr>
<tr class="separator:a82df5c1b3533255a3e0988f8b82c0938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29a459a06e5c764d0b18fad075cea34"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ad29a459a06e5c764d0b18fad075cea34">ustring</a> (size_t count, char8_t character)</td></tr>
<tr class="memdesc:ad29a459a06e5c764d0b18fad075cea34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character.  <br /></td></tr>
<tr class="separator:ad29a459a06e5c764d0b18fad075cea34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59db9c06874d4741a6e9c9d18a145eca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a59db9c06874d4741a6e9c9d18a145eca">ustring</a> (size_t count, char8_t character, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a59db9c06874d4741a6e9c9d18a145eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character and specified allocator.  <br /></td></tr>
<tr class="separator:a59db9c06874d4741a6e9c9d18a145eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c6e9bc0de28607372aa298e5886f84"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a09c6e9bc0de28607372aa298e5886f84">ustring</a> (size_t count, value_type character)</td></tr>
<tr class="memdesc:a09c6e9bc0de28607372aa298e5886f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character.  <br /></td></tr>
<tr class="separator:a09c6e9bc0de28607372aa298e5886f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c19dfade464033be0ffb4e86fb1ead"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a94c19dfade464033be0ffb4e86fb1ead">ustring</a> (size_t count, value_type character, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a94c19dfade464033be0ffb4e86fb1ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character and specified allocator.  <br /></td></tr>
<tr class="separator:a94c19dfade464033be0ffb4e86fb1ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0535cd596a71ac846ebf326d2795a230"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a0535cd596a71ac846ebf326d2795a230">ustring</a> (size_t count, wchar_t character)</td></tr>
<tr class="memdesc:a0535cd596a71ac846ebf326d2795a230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character.  <br /></td></tr>
<tr class="separator:a0535cd596a71ac846ebf326d2795a230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54dbbd0d756bcd9fbb1af3d3e4b0d69a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a54dbbd0d756bcd9fbb1af3d3e4b0d69a">ustring</a> (size_t count, wchar_t character, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a54dbbd0d756bcd9fbb1af3d3e4b0d69a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character and specified allocator.  <br /></td></tr>
<tr class="separator:a54dbbd0d756bcd9fbb1af3d3e4b0d69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561273da0bdb033d15ce1d5262a17476"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a561273da0bdb033d15ce1d5262a17476">ustring</a> (std::initializer_list&lt; char16_t &gt; il)</td></tr>
<tr class="memdesc:a561273da0bdb033d15ce1d5262a17476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list.  <br /></td></tr>
<tr class="separator:a561273da0bdb033d15ce1d5262a17476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f64819a9e36f572ee58fa6d1195596"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a85f64819a9e36f572ee58fa6d1195596">ustring</a> (std::initializer_list&lt; char16_t &gt; il, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a85f64819a9e36f572ee58fa6d1195596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list and allocator.  <br /></td></tr>
<tr class="separator:a85f64819a9e36f572ee58fa6d1195596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f69ab4e6372023098faf1606128485"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a15f69ab4e6372023098faf1606128485">ustring</a> (std::initializer_list&lt; char32_t &gt; il)</td></tr>
<tr class="memdesc:a15f69ab4e6372023098faf1606128485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list.  <br /></td></tr>
<tr class="separator:a15f69ab4e6372023098faf1606128485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cc641cc0f76d88950b435a34ed539f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a13cc641cc0f76d88950b435a34ed539f">ustring</a> (std::initializer_list&lt; char32_t &gt; il, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a13cc641cc0f76d88950b435a34ed539f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list and allocator.  <br /></td></tr>
<tr class="separator:a13cc641cc0f76d88950b435a34ed539f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2683c509a0f3e461bf771a19e39a6356"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a2683c509a0f3e461bf771a19e39a6356">ustring</a> (std::initializer_list&lt; char8_t &gt; il)</td></tr>
<tr class="memdesc:a2683c509a0f3e461bf771a19e39a6356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list.  <br /></td></tr>
<tr class="separator:a2683c509a0f3e461bf771a19e39a6356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2189c1d176ce1d7b2ea6013616e91df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ae2189c1d176ce1d7b2ea6013616e91df">ustring</a> (std::initializer_list&lt; char8_t &gt; il, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:ae2189c1d176ce1d7b2ea6013616e91df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list and allocator.  <br /></td></tr>
<tr class="separator:ae2189c1d176ce1d7b2ea6013616e91df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26be076083adc627f2908488f9d5cc01"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a26be076083adc627f2908488f9d5cc01">ustring</a> (std::initializer_list&lt; value_type &gt; il)</td></tr>
<tr class="memdesc:a26be076083adc627f2908488f9d5cc01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list.  <br /></td></tr>
<tr class="separator:a26be076083adc627f2908488f9d5cc01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015261e2eb18d2ac46ca692829cd164d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a015261e2eb18d2ac46ca692829cd164d">ustring</a> (std::initializer_list&lt; value_type &gt; il, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a015261e2eb18d2ac46ca692829cd164d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list and allocator.  <br /></td></tr>
<tr class="separator:a015261e2eb18d2ac46ca692829cd164d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfb1e41dc9e79bd49b86f605d7e2333"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a1dfb1e41dc9e79bd49b86f605d7e2333">ustring</a> (std::initializer_list&lt; wchar_t &gt; il)</td></tr>
<tr class="memdesc:a1dfb1e41dc9e79bd49b86f605d7e2333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list.  <br /></td></tr>
<tr class="separator:a1dfb1e41dc9e79bd49b86f605d7e2333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e9ea27f73c1dd7a9a629c59e072268"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ab8e9ea27f73c1dd7a9a629c59e072268">ustring</a> (std::initializer_list&lt; wchar_t &gt; il, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:ab8e9ea27f73c1dd7a9a629c59e072268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list and allocator.  <br /></td></tr>
<tr class="separator:ab8e9ea27f73c1dd7a9a629c59e072268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb84879a963d77159459e8aee6d21169"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#acb84879a963d77159459e8aee6d21169">ustring</a> (<a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&amp;str) noexcept</td></tr>
<tr class="memdesc:acb84879a963d77159459e8aee6d21169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to move.  <br /></td></tr>
<tr class="separator:acb84879a963d77159459e8aee6d21169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a96f03a62a5c045296bf62e3c4c31f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a50a96f03a62a5c045296bf62e3c4c31f">ustring</a> (<a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&amp;str, const allocator_type &amp;allocator) noexcept</td></tr>
<tr class="memdesc:a50a96f03a62a5c045296bf62e3c4c31f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to move and allocator.  <br /></td></tr>
<tr class="separator:a50a96f03a62a5c045296bf62e3c4c31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4407cb0d803eaca779def996836accae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a4407cb0d803eaca779def996836accae">ustring</a> (value_type *str)</td></tr>
<tr class="memdesc:a4407cb0d803eaca779def996836accae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:a4407cb0d803eaca779def996836accae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30cffa0a677d57c60dbc300e2a63f8e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#aa30cffa0a677d57c60dbc300e2a63f8e">ustring</a> (value_type *str, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:aa30cffa0a677d57c60dbc300e2a63f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator.  <br /></td></tr>
<tr class="separator:aa30cffa0a677d57c60dbc300e2a63f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac502899e85952e57e8a87b431fa9c01"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#aac502899e85952e57e8a87b431fa9c01">ustring</a> (wchar_t *str)</td></tr>
<tr class="memdesc:aac502899e85952e57e8a87b431fa9c01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:aac502899e85952e57e8a87b431fa9c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b87d6c4a7b138aaeb1cd4ab8b2099d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a86b87d6c4a7b138aaeb1cd4ab8b2099d">ustring</a> (wchar_t *str, const allocator_type &amp;allocator)</td></tr>
<tr class="memdesc:a86b87d6c4a7b138aaeb1cd4ab8b2099d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator.  <br /></td></tr>
<tr class="separator:a86b87d6c4a7b138aaeb1cd4ab8b2099d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0e43190da2d939a59a911e46302af1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#aea0e43190da2d939a59a911e46302af1">contains</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;value) const noexcept</td></tr>
<tr class="memdesc:aea0e43190da2d939a59a911e46302af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a value indicating whether a specified substring occurs within this string.  <br /></td></tr>
<tr class="separator:aea0e43190da2d939a59a911e46302af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f37a3f06b8ef5e4a87a33919eba15a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a75f37a3f06b8ef5e4a87a33919eba15a">ends_with</a> (char8_t value) const noexcept</td></tr>
<tr class="memdesc:a75f37a3f06b8ef5e4a87a33919eba15a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the end of this string matches the specified character.  <br /></td></tr>
<tr class="separator:a75f37a3f06b8ef5e4a87a33919eba15a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02f78ca99a3dfb0ee73bc0252b329b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ad02f78ca99a3dfb0ee73bc0252b329b0">ends_with</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;value) const noexcept</td></tr>
<tr class="memdesc:ad02f78ca99a3dfb0ee73bc0252b329b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the end of this string matches the specified string.  <br /></td></tr>
<tr class="separator:ad02f78ca99a3dfb0ee73bc0252b329b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d72ca87fc9bcdae5c8d3db042cdec9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ae9d72ca87fc9bcdae5c8d3db042cdec9">ends_with</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;value, bool ignore_case) const noexcept</td></tr>
<tr class="memdesc:ae9d72ca87fc9bcdae5c8d3db042cdec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the end of this string instance matches the specified string when compared using the specified culture.  <br /></td></tr>
<tr class="separator:ae9d72ca87fc9bcdae5c8d3db042cdec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fcc85777946011f389241af42b27aaf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a8fcc85777946011f389241af42b27aaf">ends_with</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;value, <a class="el" href="group__xtd__core.html#ga04dd6c532656e286dfbf2f9aea3d8ccd">xtd::string_comparison</a> comparison_type) const noexcept</td></tr>
<tr class="memdesc:a8fcc85777946011f389241af42b27aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the end of this string matches the specified string when compared using the specified comparison option.  <br /></td></tr>
<tr class="separator:a8fcc85777946011f389241af42b27aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66c2037568657029c2695e7c5d43d84"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ab66c2037568657029c2695e7c5d43d84">ends_with</a> (value_type value) const noexcept</td></tr>
<tr class="memdesc:ab66c2037568657029c2695e7c5d43d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the end of this string matches the specified character.  <br /></td></tr>
<tr class="separator:ab66c2037568657029c2695e7c5d43d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80f25a3a363194532225ddacc53e663"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ab80f25a3a363194532225ddacc53e663">get_hash_code</a> () const noexcept override</td></tr>
<tr class="memdesc:ab80f25a3a363194532225ddacc53e663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the hash code for this string.  <br /></td></tr>
<tr class="separator:ab80f25a3a363194532225ddacc53e663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde1d8ad0d05e9e769aaeb4510a993cb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#abde1d8ad0d05e9e769aaeb4510a993cb">index_of</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;value) const noexcept</td></tr>
<tr class="memdesc:abde1d8ad0d05e9e769aaeb4510a993cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified string in this string.  <br /></td></tr>
<tr class="separator:abde1d8ad0d05e9e769aaeb4510a993cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af368ba7426298e88fd5b5dc5f06e4c6d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#af368ba7426298e88fd5b5dc5f06e4c6d">index_of</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;value, size_t start_index) const noexcept</td></tr>
<tr class="memdesc:af368ba7426298e88fd5b5dc5f06e4c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified character in this string. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:af368ba7426298e88fd5b5dc5f06e4c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7e84685e335551dd4e9868c110b427"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#aec7e84685e335551dd4e9868c110b427">index_of</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;value, size_t start_index, size_t count) const noexcept</td></tr>
<tr class="memdesc:aec7e84685e335551dd4e9868c110b427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified character in this string. The search starts at a specified character position and examines a specified number of character positions.  <br /></td></tr>
<tr class="separator:aec7e84685e335551dd4e9868c110b427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e9d6260703cb75dbff5a8e458083e3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a74e9d6260703cb75dbff5a8e458083e3">index_of</a> (value_type value) const noexcept</td></tr>
<tr class="memdesc:a74e9d6260703cb75dbff5a8e458083e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified character in this string.  <br /></td></tr>
<tr class="separator:a74e9d6260703cb75dbff5a8e458083e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65748d612fa86854545f4627f8c63601"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a65748d612fa86854545f4627f8c63601">index_of</a> (value_type value, size_t start_index) const noexcept</td></tr>
<tr class="memdesc:a65748d612fa86854545f4627f8c63601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified character in this string. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:a65748d612fa86854545f4627f8c63601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00535c21a723c61d49790a98fc56ac58"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a00535c21a723c61d49790a98fc56ac58">index_of</a> (value_type value, size_t start_index, size_t count) const noexcept</td></tr>
<tr class="memdesc:a00535c21a723c61d49790a98fc56ac58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified character in this string. The search starts at a specified character position and examines a specified number of character positions.  <br /></td></tr>
<tr class="separator:a00535c21a723c61d49790a98fc56ac58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f8ff481971c33c05ccc60ff7c2397e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a52f8ff481971c33c05ccc60ff7c2397e">index_of_any</a> (const std::vector&lt; value_type &gt; &amp;values) const noexcept</td></tr>
<tr class="memdesc:a52f8ff481971c33c05ccc60ff7c2397e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence in this instance of any character in a specified array of characters.  <br /></td></tr>
<tr class="separator:a52f8ff481971c33c05ccc60ff7c2397e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92268eec76bff7c4b3b33a7696cfb12a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a92268eec76bff7c4b3b33a7696cfb12a">index_of_any</a> (const std::vector&lt; value_type &gt; &amp;values, size_t start_index) const noexcept</td></tr>
<tr class="memdesc:a92268eec76bff7c4b3b33a7696cfb12a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:a92268eec76bff7c4b3b33a7696cfb12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ec9a7b572cc3e92aabafe3c6bed320"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ac8ec9a7b572cc3e92aabafe3c6bed320">index_of_any</a> (const std::vector&lt; value_type &gt; &amp;values, size_t start_index, size_t count) const noexcept</td></tr>
<tr class="memdesc:ac8ec9a7b572cc3e92aabafe3c6bed320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:ac8ec9a7b572cc3e92aabafe3c6bed320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb8bd971a50be1f16f8a60f1acc5e8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a4fb8bd971a50be1f16f8a60f1acc5e8e">insert</a> (size_t start_index, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;value) const noexcept</td></tr>
<tr class="memdesc:a4fb8bd971a50be1f16f8a60f1acc5e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a specified instance of string at a specified index position in this instance.  <br /></td></tr>
<tr class="separator:a4fb8bd971a50be1f16f8a60f1acc5e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22354e7aab0bf4e272fcc3d48095e950"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a22354e7aab0bf4e272fcc3d48095e950">is_empty</a> () const noexcept</td></tr>
<tr class="memdesc:a22354e7aab0bf4e272fcc3d48095e950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether this string is an empty string ("").  <br /></td></tr>
<tr class="separator:a22354e7aab0bf4e272fcc3d48095e950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8adab244b1165d2d9b849a39cf8ff55d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a8adab244b1165d2d9b849a39cf8ff55d">last_index_of</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;value) const noexcept</td></tr>
<tr class="memdesc:a8adab244b1165d2d9b849a39cf8ff55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified string in this string.  <br /></td></tr>
<tr class="separator:a8adab244b1165d2d9b849a39cf8ff55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120c87d0c32977516fe5f31ed968a541"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a120c87d0c32977516fe5f31ed968a541">last_index_of</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;value, size_t start_index) const noexcept</td></tr>
<tr class="memdesc:a120c87d0c32977516fe5f31ed968a541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified character in this string. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:a120c87d0c32977516fe5f31ed968a541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125ebf9aadb1dc5948f57b0aca64b72a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a125ebf9aadb1dc5948f57b0aca64b72a">last_index_of</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;value, size_t start_index, size_t count) const noexcept</td></tr>
<tr class="memdesc:a125ebf9aadb1dc5948f57b0aca64b72a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified character in this string. The search starts at a specified character position and examines a specified number of character positions.  <br /></td></tr>
<tr class="separator:a125ebf9aadb1dc5948f57b0aca64b72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6d810543949e28650f92b5206314a5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a1d6d810543949e28650f92b5206314a5">last_index_of</a> (value_type value) const noexcept</td></tr>
<tr class="memdesc:a1d6d810543949e28650f92b5206314a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified character in this tring.  <br /></td></tr>
<tr class="separator:a1d6d810543949e28650f92b5206314a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0899fdfb944945fe56abf5b74b4716"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a2c0899fdfb944945fe56abf5b74b4716">last_index_of</a> (value_type value, size_t start_index) const noexcept</td></tr>
<tr class="memdesc:a2c0899fdfb944945fe56abf5b74b4716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified character in this string. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:a2c0899fdfb944945fe56abf5b74b4716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32dc6a0c560aa072d8ce83151530a75"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ab32dc6a0c560aa072d8ce83151530a75">last_index_of</a> (value_type value, size_t start_index, size_t count) const noexcept</td></tr>
<tr class="memdesc:ab32dc6a0c560aa072d8ce83151530a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified character in this string. The search starts at a specified character position and examines a specified number of character positions.  <br /></td></tr>
<tr class="separator:ab32dc6a0c560aa072d8ce83151530a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088f6faf6f0d3d4df9702c4185b04a30"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a088f6faf6f0d3d4df9702c4185b04a30">last_index_of_any</a> (const std::vector&lt; value_type &gt; &amp;values) const noexcept</td></tr>
<tr class="memdesc:a088f6faf6f0d3d4df9702c4185b04a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence in this instance of any character in a specified array of characters.  <br /></td></tr>
<tr class="separator:a088f6faf6f0d3d4df9702c4185b04a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4834f48993ac33b74f95069aa16357"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#aec4834f48993ac33b74f95069aa16357">last_index_of_any</a> (const std::vector&lt; value_type &gt; &amp;values, size_t start_index) const noexcept</td></tr>
<tr class="memdesc:aec4834f48993ac33b74f95069aa16357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:aec4834f48993ac33b74f95069aa16357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945e24afee50977935bd3aca1cdddb6a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a945e24afee50977935bd3aca1cdddb6a">last_index_of_any</a> (const std::vector&lt; value_type &gt; &amp;values, size_t start_index, size_t count) const noexcept</td></tr>
<tr class="memdesc:a945e24afee50977935bd3aca1cdddb6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:a945e24afee50977935bd3aca1cdddb6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadfe62deb046bd17790cb22207d4f4f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#aadfe62deb046bd17790cb22207d4f4f5">pad_left</a> (size_t total_width) const noexcept</td></tr>
<tr class="memdesc:aadfe62deb046bd17790cb22207d4f4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-aligns the characters in this string, padding with spaces on the left for a specified total length.  <br /></td></tr>
<tr class="separator:aadfe62deb046bd17790cb22207d4f4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1d40bffb5a673ecdb6f13fdf19d954"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a3a1d40bffb5a673ecdb6f13fdf19d954">pad_left</a> (size_t total_width, value_type padding_char) const noexcept</td></tr>
<tr class="memdesc:a3a1d40bffb5a673ecdb6f13fdf19d954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-aligns the characters in this string, padding with spaces on the left for a specified total length.  <br /></td></tr>
<tr class="separator:a3a1d40bffb5a673ecdb6f13fdf19d954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9abb16d8b680c650dd5cad88b8ecdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a7b9abb16d8b680c650dd5cad88b8ecdb">pad_right</a> (size_t total_width) const noexcept</td></tr>
<tr class="memdesc:a7b9abb16d8b680c650dd5cad88b8ecdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-aligns the characters in this string, padding with spaces on the right for a specified total length.  <br /></td></tr>
<tr class="separator:a7b9abb16d8b680c650dd5cad88b8ecdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4acf4abd79ff8bc4eb2b2b314273084b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a4acf4abd79ff8bc4eb2b2b314273084b">pad_right</a> (size_t total_width, value_type padding_char) const noexcept</td></tr>
<tr class="memdesc:a4acf4abd79ff8bc4eb2b2b314273084b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-aligns the characters in this string, padding with spaces on the right for a specified total length.  <br /></td></tr>
<tr class="separator:a4acf4abd79ff8bc4eb2b2b314273084b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e0a7ed099484646436a14ef1279ab5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ac9e0a7ed099484646436a14ef1279ab5">remove</a> (size_t start_index) const noexcept</td></tr>
<tr class="memdesc:ac9e0a7ed099484646436a14ef1279ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all the characters from this string beginning at a specified position and continuing through the last position.  <br /></td></tr>
<tr class="separator:ac9e0a7ed099484646436a14ef1279ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a41355798abb8ab801e4709afae16c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a02a41355798abb8ab801e4709afae16c">remove</a> (size_t start_index, size_t count) const noexcept</td></tr>
<tr class="memdesc:a02a41355798abb8ab801e4709afae16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all the characters from this string beginning at a specified position and continuing through the last position.  <br /></td></tr>
<tr class="separator:a02a41355798abb8ab801e4709afae16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35618679cb579be47165cda420847c0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a35618679cb579be47165cda420847c0b">replace</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;old_string, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;new_string) const noexcept</td></tr>
<tr class="memdesc:a35618679cb579be47165cda420847c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all occurrences of a specified string in this string with another specified string.  <br /></td></tr>
<tr class="separator:a35618679cb579be47165cda420847c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f47776cd7a5e8b7137138c83e12c53d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a8f47776cd7a5e8b7137138c83e12c53d">replace</a> (value_type old_char, value_type new_char) const noexcept</td></tr>
<tr class="memdesc:a8f47776cd7a5e8b7137138c83e12c53d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all occurrences of a specified char_t in this string with another specified char_t.  <br /></td></tr>
<tr class="separator:a8f47776cd7a5e8b7137138c83e12c53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b33020b0d948fe3946a3535e8f8458"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classxtd_1_1ustring.html">ustring</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a66b33020b0d948fe3946a3535e8f8458">split</a> () const noexcept</td></tr>
<tr class="memdesc:a66b33020b0d948fe3946a3535e8f8458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits this string into substrings that are based on the default white-space characters. White-space characters are defined by the c++ standard and return true if they are passed to the std::isspace() or std::iswspace() method.  <br /></td></tr>
<tr class="separator:a66b33020b0d948fe3946a3535e8f8458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accdcbabd839bcc9dcea46df7ad5a8a18"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classxtd_1_1ustring.html">ustring</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#accdcbabd839bcc9dcea46df7ad5a8a18">split</a> (const std::vector&lt; value_type &gt; &amp;separators) const noexcept</td></tr>
<tr class="memdesc:accdcbabd839bcc9dcea46df7ad5a8a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits this string into substrings that are based on the characters in an array.  <br /></td></tr>
<tr class="separator:accdcbabd839bcc9dcea46df7ad5a8a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd5fd437bfcbac1c20e589e62200780"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classxtd_1_1ustring.html">ustring</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a8cd5fd437bfcbac1c20e589e62200780">split</a> (const std::vector&lt; value_type &gt; &amp;separators, size_t count) const noexcept</td></tr>
<tr class="memdesc:a8cd5fd437bfcbac1c20e589e62200780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits this string into a maximum number of substrings based on the characters in an array. You also specify the maximum number of substrings to return.  <br /></td></tr>
<tr class="separator:a8cd5fd437bfcbac1c20e589e62200780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cce1408f2ea06898b33f7427ad712b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classxtd_1_1ustring.html">ustring</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a65cce1408f2ea06898b33f7427ad712b">split</a> (const std::vector&lt; value_type &gt; &amp;separators, size_t count, <a class="el" href="group__xtd__core.html#ga1856f4f531626dc585fd1c8ccc6d596c">string_split_options</a> options) const noexcept</td></tr>
<tr class="memdesc:a65cce1408f2ea06898b33f7427ad712b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits this string into a maximum number of substrings based on the characters in an array.  <br /></td></tr>
<tr class="separator:a65cce1408f2ea06898b33f7427ad712b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d254b792df2455b4c27886cf65cdfa2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classxtd_1_1ustring.html">ustring</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a7d254b792df2455b4c27886cf65cdfa2">split</a> (const std::vector&lt; value_type &gt; &amp;separators, <a class="el" href="group__xtd__core.html#ga1856f4f531626dc585fd1c8ccc6d596c">string_split_options</a> options) const noexcept</td></tr>
<tr class="memdesc:a7d254b792df2455b4c27886cf65cdfa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits this string into substrings based on the characters in an array. You can specify whether the substrings include empty array elements.  <br /></td></tr>
<tr class="separator:a7d254b792df2455b4c27886cf65cdfa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab847e62a85bbb1eb9044b9e8ebaead55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ab847e62a85bbb1eb9044b9e8ebaead55">starts_with</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;value) const noexcept</td></tr>
<tr class="memdesc:ab847e62a85bbb1eb9044b9e8ebaead55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the beginning of this instance of String matches a specified String.  <br /></td></tr>
<tr class="separator:ab847e62a85bbb1eb9044b9e8ebaead55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98b6ee462e44358380fd35f8afb8994"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#af98b6ee462e44358380fd35f8afb8994">starts_with</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;value, bool ignore_case) const noexcept</td></tr>
<tr class="memdesc:af98b6ee462e44358380fd35f8afb8994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the beginning of this instance of String matches a specified String, ignoring or honoring their case.  <br /></td></tr>
<tr class="separator:af98b6ee462e44358380fd35f8afb8994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5334d81e1d6756cb0db9aeefeb5cea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ade5334d81e1d6756cb0db9aeefeb5cea">starts_with</a> (value_type value) const noexcept</td></tr>
<tr class="memdesc:ade5334d81e1d6756cb0db9aeefeb5cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the beginning of this instance of String matches a specified String.  <br /></td></tr>
<tr class="separator:ade5334d81e1d6756cb0db9aeefeb5cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8892581c00c768b278d9657ed6aecf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a7c8892581c00c768b278d9657ed6aecf">starts_with</a> (value_type value, bool ignore_case) const noexcept</td></tr>
<tr class="memdesc:a7c8892581c00c768b278d9657ed6aecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the beginning of this instance of String matches a specified String, ignoring or honoring their case.  <br /></td></tr>
<tr class="separator:a7c8892581c00c768b278d9657ed6aecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27e596eab3904c5084c2d2cb7ae05a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ad27e596eab3904c5084c2d2cb7ae05a1">substring</a> (size_t start_index) const noexcept</td></tr>
<tr class="memdesc:ad27e596eab3904c5084c2d2cb7ae05a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a substring from this instance. The substring starts at a specified character position and has a specified length.  <br /></td></tr>
<tr class="separator:ad27e596eab3904c5084c2d2cb7ae05a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3036669570cf96cc74bc68aad2098e53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a3036669570cf96cc74bc68aad2098e53">substring</a> (size_t start_index, size_t length) const noexcept</td></tr>
<tr class="memdesc:a3036669570cf96cc74bc68aad2098e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a substring from this instance. The substring starts at a specified character position and has a specified length.  <br /></td></tr>
<tr class="separator:a3036669570cf96cc74bc68aad2098e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53db7e47ebfb9f700184263cdffe90fc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a53db7e47ebfb9f700184263cdffe90fc">to_array</a> () const noexcept</td></tr>
<tr class="memdesc:a53db7e47ebfb9f700184263cdffe90fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the characters in this instance to a Unicode character array.  <br /></td></tr>
<tr class="separator:a53db7e47ebfb9f700184263cdffe90fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf5c498288cf53e891ec8a3227cd013"><td class="memItemLeft" align="right" valign="top">std::vector&lt; value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#afbf5c498288cf53e891ec8a3227cd013">to_array</a> (size_t start_index) const noexcept</td></tr>
<tr class="memdesc:afbf5c498288cf53e891ec8a3227cd013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the characters in this instance to a Unicode character array starting at specified index.  <br /></td></tr>
<tr class="separator:afbf5c498288cf53e891ec8a3227cd013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e16fac35c5b5145b14c0d8fa5059313"><td class="memItemLeft" align="right" valign="top">std::vector&lt; value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a0e16fac35c5b5145b14c0d8fa5059313">to_array</a> (size_t start_index, size_t length) const noexcept</td></tr>
<tr class="memdesc:a0e16fac35c5b5145b14c0d8fa5059313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the characters in this instance to a Unicode character array starting at specified index with specified length.  <br /></td></tr>
<tr class="separator:a0e16fac35c5b5145b14c0d8fa5059313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af336a018fa7b2750e7cafe9dd708de4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#af336a018fa7b2750e7cafe9dd708de4b">to_lower</a> () const noexcept</td></tr>
<tr class="memdesc:af336a018fa7b2750e7cafe9dd708de4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the current string converted to lowercase.  <br /></td></tr>
<tr class="separator:af336a018fa7b2750e7cafe9dd708de4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e5a8801e4f4c333649a0920b13b4d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ae1e5a8801e4f4c333649a0920b13b4d7">to_string</a> () const noexcept override</td></tr>
<tr class="memdesc:ae1e5a8801e4f4c333649a0920b13b4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a std::string that represents the current object.  <br /></td></tr>
<tr class="separator:ae1e5a8801e4f4c333649a0920b13b4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459c7cf5ab46bbce3088c6f8b0c87081"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a459c7cf5ab46bbce3088c6f8b0c87081">to_upper</a> () const noexcept</td></tr>
<tr class="memdesc:a459c7cf5ab46bbce3088c6f8b0c87081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the current string converted to uppercase.  <br /></td></tr>
<tr class="separator:a459c7cf5ab46bbce3088c6f8b0c87081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6521e1bcb7f90cc6e5678454c2488e0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a6521e1bcb7f90cc6e5678454c2488e0a">trim</a> () const noexcept</td></tr>
<tr class="memdesc:a6521e1bcb7f90cc6e5678454c2488e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all leading and trailing occurrences of white-space characters from the specified String.  <br /></td></tr>
<tr class="separator:a6521e1bcb7f90cc6e5678454c2488e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201e55d40c55a79e7a10e884c2f472c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a201e55d40c55a79e7a10e884c2f472c1">trim</a> (const std::vector&lt; value_type &gt; &amp;trim_chars) const noexcept</td></tr>
<tr class="memdesc:a201e55d40c55a79e7a10e884c2f472c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all leading and trailing occurrences of a set of characters specified in an array from the specified String.  <br /></td></tr>
<tr class="separator:a201e55d40c55a79e7a10e884c2f472c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ee5015736be282dd15a37aed0dcb47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a47ee5015736be282dd15a37aed0dcb47">trim</a> (value_type trim_char) const noexcept</td></tr>
<tr class="memdesc:a47ee5015736be282dd15a37aed0dcb47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all leading and trailing occurrences of a character specified from the specified String .  <br /></td></tr>
<tr class="separator:a47ee5015736be282dd15a37aed0dcb47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d193fc8b669cf1d49b92fd0fab9ed0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a6d193fc8b669cf1d49b92fd0fab9ed0f">trim_end</a> () const noexcept</td></tr>
<tr class="memdesc:a6d193fc8b669cf1d49b92fd0fab9ed0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all trailing occurrences of white-space characters from the specified String.  <br /></td></tr>
<tr class="separator:a6d193fc8b669cf1d49b92fd0fab9ed0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf27752e3802e2d62fd358004b5c419e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#abf27752e3802e2d62fd358004b5c419e">trim_end</a> (const std::vector&lt; value_type &gt; &amp;trim_chars) const noexcept</td></tr>
<tr class="memdesc:abf27752e3802e2d62fd358004b5c419e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all trailing occurrences of a set of characters specified in an array from the specified String.  <br /></td></tr>
<tr class="separator:abf27752e3802e2d62fd358004b5c419e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa517a64d866a66f04511e9bad2d2af35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#aa517a64d866a66f04511e9bad2d2af35">trim_end</a> (value_type trim_char) const noexcept</td></tr>
<tr class="memdesc:aa517a64d866a66f04511e9bad2d2af35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all trailing occurrences of a character specified from the specified String .  <br /></td></tr>
<tr class="separator:aa517a64d866a66f04511e9bad2d2af35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8778eb32e44c58c7f9576cd2bf5bfceb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a8778eb32e44c58c7f9576cd2bf5bfceb">trim_start</a> () const noexcept</td></tr>
<tr class="memdesc:a8778eb32e44c58c7f9576cd2bf5bfceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all leading occurrences of white-space characters from the specified String.  <br /></td></tr>
<tr class="separator:a8778eb32e44c58c7f9576cd2bf5bfceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb88ae933c826a42b98beab955d0199"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#aceb88ae933c826a42b98beab955d0199">trim_start</a> (const std::vector&lt; value_type &gt; &amp;trim_chars) const noexcept</td></tr>
<tr class="memdesc:aceb88ae933c826a42b98beab955d0199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all leading occurrences of a set of characters specified in an array from the specified String.  <br /></td></tr>
<tr class="separator:aceb88ae933c826a42b98beab955d0199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5bc64baa95dea6d1d28d79438899a31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#af5bc64baa95dea6d1d28d79438899a31">trim_start</a> (value_type trim_char) const noexcept</td></tr>
<tr class="memdesc:af5bc64baa95dea6d1d28d79438899a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all leading occurrences of a character specified from the specified String .  <br /></td></tr>
<tr class="separator:af5bc64baa95dea6d1d28d79438899a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1object.html">xtd::object</a></td></tr>
<tr class="memitem:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ad2cab851376bb6ca085b567bf5da0f5f">object</a> ()=default</td></tr>
<tr class="memdesc:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of the ultimate base class object.  <br /></td></tr>
<tr class="separator:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2743b6f75405882c28eebe2456f3837b inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a2743b6f75405882c28eebe2456f3837b">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;obj) const noexcept</td></tr>
<tr class="memdesc:a2743b6f75405882c28eebe2456f3837b inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object is equal to the current object.  <br /></td></tr>
<tr class="separator:a2743b6f75405882c28eebe2456f3837b inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a1fea096f8a49ac5eef1f2431806109ca">get_hash_code</a> () const noexcept</td></tr>
<tr class="memdesc:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serves as a hash function for a particular type.  <br /></td></tr>
<tr class="separator:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1d6739fb74be554719eced219de59a inherit pub_methods_classxtd_1_1object"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:a7d1d6739fb74be554719eced219de59a inherit pub_methods_classxtd_1_1object"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; object_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a7d1d6739fb74be554719eced219de59a">memberwise_clone</a> () const</td></tr>
<tr class="memdesc:a7d1d6739fb74be554719eced219de59a inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the current instance.  <br /></td></tr>
<tr class="separator:a7d1d6739fb74be554719eced219de59a inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5682215ee76ab97c48580ab162c49507 inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1ustring.html">xtd::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a5682215ee76ab97c48580ab162c49507">to_string</a> () const noexcept</td></tr>
<tr class="memdesc:a5682215ee76ab97c48580ab162c49507 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a std::string that represents the current object.  <br /></td></tr>
<tr class="separator:a5682215ee76ab97c48580ab162c49507 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aafaae6b32a8bbfc8cd20defa2b14dc88"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:aafaae6b32a8bbfc8cd20defa2b14dc88"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#aafaae6b32a8bbfc8cd20defa2b14dc88">class_name</a> ()</td></tr>
<tr class="memdesc:aafaae6b32a8bbfc8cd20defa2b14dc88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the class name of the object_t.  <br /></td></tr>
<tr class="separator:aafaae6b32a8bbfc8cd20defa2b14dc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf26167d0f67d103c069fb005063234"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:a5bf26167d0f67d103c069fb005063234"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a5bf26167d0f67d103c069fb005063234">class_name</a> (const object_t &amp;<a class="el" href="classxtd_1_1object.html">object</a>)</td></tr>
<tr class="memdesc:a5bf26167d0f67d103c069fb005063234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the class name of the specified object.  <br /></td></tr>
<tr class="separator:a5bf26167d0f67d103c069fb005063234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4bcd6d2d8749fb41e52c3c7152fe13"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a7e4bcd6d2d8749fb41e52c3c7152fe13">class_name</a> (const std::type_info &amp;info)</td></tr>
<tr class="memdesc:a7e4bcd6d2d8749fb41e52c3c7152fe13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the class name of the specified object.  <br /></td></tr>
<tr class="separator:a7e4bcd6d2d8749fb41e52c3c7152fe13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade21fb4cb80096fd2a2fd981e6a3c1e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#aade21fb4cb80096fd2a2fd981e6a3c1e">compare</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_a, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_b) noexcept</td></tr>
<tr class="memdesc:aade21fb4cb80096fd2a2fd981e6a3c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two specified string objects and returns an integer that indicates their relative position in the sort order.  <br /></td></tr>
<tr class="separator:aade21fb4cb80096fd2a2fd981e6a3c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489f005f0e9ae03ace38598288ec6c4e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a489f005f0e9ae03ace38598288ec6c4e">compare</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_a, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_b, bool ignore_case) noexcept</td></tr>
<tr class="memdesc:a489f005f0e9ae03ace38598288ec6c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two specified string objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.  <br /></td></tr>
<tr class="separator:a489f005f0e9ae03ace38598288ec6c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7374a548fd02cf24a7c9a0f2ce893e9"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#aa7374a548fd02cf24a7c9a0f2ce893e9">compare</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_a, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_b, <a class="el" href="group__xtd__core.html#ga04dd6c532656e286dfbf2f9aea3d8ccd">xtd::string_comparison</a> comparison_type) noexcept</td></tr>
<tr class="memdesc:aa7374a548fd02cf24a7c9a0f2ce893e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two specified string objects using the specified rules, and returns an integer that indicates their relative position in the sort order.  <br /></td></tr>
<tr class="separator:aa7374a548fd02cf24a7c9a0f2ce893e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5bdabe5dfc8e2160af379447a671778"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#af5bdabe5dfc8e2160af379447a671778">compare</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_a, size_t index_a, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_b, size_t index_b, size_t length) noexcept</td></tr>
<tr class="memdesc:af5bdabe5dfc8e2160af379447a671778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares substrings of two specified string objects and returns an integer that indicates their relative position in the sort order.  <br /></td></tr>
<tr class="separator:af5bdabe5dfc8e2160af379447a671778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912c7cec4b476f3a49c80057588aa989"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a912c7cec4b476f3a49c80057588aa989">compare</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_a, size_t index_a, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_b, size_t index_b, size_t length, bool ignore_case) noexcept</td></tr>
<tr class="memdesc:a912c7cec4b476f3a49c80057588aa989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares substrings of two specified string objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.  <br /></td></tr>
<tr class="separator:a912c7cec4b476f3a49c80057588aa989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257a95d3381a404907617b077d40c915"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a257a95d3381a404907617b077d40c915">compare</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_a, size_t index_a, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_b, size_t index_b, size_t length, <a class="el" href="group__xtd__core.html#ga04dd6c532656e286dfbf2f9aea3d8ccd">xtd::string_comparison</a> comparison_type) noexcept</td></tr>
<tr class="memdesc:a257a95d3381a404907617b077d40c915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares substrings of two specified string objects using the specified rules, and returns an integer that indicates their relative position in the sort order.  <br /></td></tr>
<tr class="separator:a257a95d3381a404907617b077d40c915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f9f5b6643bb4527a966f6ce1f4f6fd"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:a80f9f5b6643bb4527a966f6ce1f4f6fd"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a80f9f5b6643bb4527a966f6ce1f4f6fd">concat</a> (const std::vector&lt; object_t &gt; &amp;args) noexcept</td></tr>
<tr class="memdesc:a80f9f5b6643bb4527a966f6ce1f4f6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates the string representations of the elements in a specified object array.  <br /></td></tr>
<tr class="separator:a80f9f5b6643bb4527a966f6ce1f4f6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb605ccce66373c790611a13db14f14c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#acb605ccce66373c790611a13db14f14c">concat</a> (const std::vector&lt; <a class="el" href="classxtd_1_1ustring.html">ustring</a> &gt; &amp;values) noexcept</td></tr>
<tr class="memdesc:acb605ccce66373c790611a13db14f14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates the elements of a specified string array.  <br /></td></tr>
<tr class="separator:acb605ccce66373c790611a13db14f14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84e9e74970e64e21a97afee579ed6f3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ae84e9e74970e64e21a97afee579ed6f3">concat</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_a, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_b) noexcept</td></tr>
<tr class="memdesc:ae84e9e74970e64e21a97afee579ed6f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two specified instances of string.  <br /></td></tr>
<tr class="separator:ae84e9e74970e64e21a97afee579ed6f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceda089f7586a63df656566d0c815d22"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#aceda089f7586a63df656566d0c815d22">concat</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_a, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_b, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_c) noexcept</td></tr>
<tr class="memdesc:aceda089f7586a63df656566d0c815d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates three specified instances of string.  <br /></td></tr>
<tr class="separator:aceda089f7586a63df656566d0c815d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d492d6b9ce2f2e38661a5062009a32f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a9d492d6b9ce2f2e38661a5062009a32f">concat</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_a, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_b, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_c, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str_d) noexcept</td></tr>
<tr class="memdesc:a9d492d6b9ce2f2e38661a5062009a32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates four specified instances of string.  <br /></td></tr>
<tr class="separator:a9d492d6b9ce2f2e38661a5062009a32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7018e6a7dce9dcf133a1e393b2152ec"><td class="memTemplParams" colspan="2">template&lt;typename object_a_t , typename object_b_t &gt; </td></tr>
<tr class="memitem:aa7018e6a7dce9dcf133a1e393b2152ec"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#aa7018e6a7dce9dcf133a1e393b2152ec">concat</a> (object_a_t obj_a, object_b_t obj_b) noexcept</td></tr>
<tr class="memdesc:aa7018e6a7dce9dcf133a1e393b2152ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two specified instances of object.  <br /></td></tr>
<tr class="separator:aa7018e6a7dce9dcf133a1e393b2152ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06bc47f8af41673e7f3d89c57c9cd525"><td class="memTemplParams" colspan="2">template&lt;typename object_a_t , typename object_b_t , typename object_c_t &gt; </td></tr>
<tr class="memitem:a06bc47f8af41673e7f3d89c57c9cd525"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a06bc47f8af41673e7f3d89c57c9cd525">concat</a> (object_a_t obj_a, object_b_t obj_b, object_c_t obj_c) noexcept</td></tr>
<tr class="memdesc:a06bc47f8af41673e7f3d89c57c9cd525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates three specified instances of object.  <br /></td></tr>
<tr class="separator:a06bc47f8af41673e7f3d89c57c9cd525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745ec7372c85f6c9126b26d010f4ea97"><td class="memTemplParams" colspan="2">template&lt;typename object_a_t , typename object_b_t , typename object_c_t , typename object_d_t &gt; </td></tr>
<tr class="memitem:a745ec7372c85f6c9126b26d010f4ea97"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a745ec7372c85f6c9126b26d010f4ea97">concat</a> (object_a_t obj_a, object_b_t obj_b, object_c_t obj_c, object_d_t obj_d) noexcept</td></tr>
<tr class="memdesc:a745ec7372c85f6c9126b26d010f4ea97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates four specified instances of object.  <br /></td></tr>
<tr class="separator:a745ec7372c85f6c9126b26d010f4ea97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3378d826fc5381609746ce3618084157"><td class="memTemplParams" colspan="2">template&lt;typename value_t &gt; </td></tr>
<tr class="memitem:a3378d826fc5381609746ce3618084157"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a3378d826fc5381609746ce3618084157">concat</a> (value_t value) noexcept</td></tr>
<tr class="memdesc:a3378d826fc5381609746ce3618084157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the string representation of a specified object.  <br /></td></tr>
<tr class="separator:a3378d826fc5381609746ce3618084157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238165aaab69fb9f6c909da1fcdb072f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a238165aaab69fb9f6c909da1fcdb072f">demangle</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;name)</td></tr>
<tr class="memdesc:a238165aaab69fb9f6c909da1fcdb072f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets demangled string of name,.  <br /></td></tr>
<tr class="separator:a238165aaab69fb9f6c909da1fcdb072f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928ab8c4d2e7bc8697ccad67b56f9e3d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a928ab8c4d2e7bc8697ccad67b56f9e3d">empty_string</a> () noexcept</td></tr>
<tr class="memdesc:a928ab8c4d2e7bc8697ccad67b56f9e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the empty string.  <br /></td></tr>
<tr class="separator:a928ab8c4d2e7bc8697ccad67b56f9e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3afd6d163bc6391a48a1f84f28a68ffd"><td class="memTemplParams" colspan="2">template&lt;typename ... args_t&gt; </td></tr>
<tr class="memitem:ga3afd6d163bc6391a48a1f84f28a68ffd"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__format__parse.html#ga3afd6d163bc6391a48a1f84f28a68ffd">format</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;fmt, args_t &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga3afd6d163bc6391a48a1f84f28a68ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the text representation of the specified arguments list, to string using the specified format information.  <br /></td></tr>
<tr class="separator:ga3afd6d163bc6391a48a1f84f28a68ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a65b727872715c7b99958e84a75f61"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:aa6a65b727872715c7b99958e84a75f61"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#aa6a65b727872715c7b99958e84a75f61">full_class_name</a> ()</td></tr>
<tr class="memdesc:aa6a65b727872715c7b99958e84a75f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the fully qualified class name of the objec_t, including the namespace of the objec_t.  <br /></td></tr>
<tr class="separator:aa6a65b727872715c7b99958e84a75f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a0eee00e7f757562565f8e19c7747d"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:a81a0eee00e7f757562565f8e19c7747d"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a81a0eee00e7f757562565f8e19c7747d">full_class_name</a> (const object_t &amp;<a class="el" href="classxtd_1_1object.html">object</a>)</td></tr>
<tr class="memdesc:a81a0eee00e7f757562565f8e19c7747d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the fully qualified class name of the specified object, including the namespace of the specified object.  <br /></td></tr>
<tr class="separator:a81a0eee00e7f757562565f8e19c7747d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c639795fa939f9ccf93342b5a76e45"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#af9c639795fa939f9ccf93342b5a76e45">full_class_name</a> (const std::type_info &amp;info)</td></tr>
<tr class="memdesc:af9c639795fa939f9ccf93342b5a76e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the fully qualified class name of the specified object, including the namespace of the specified object.  <br /></td></tr>
<tr class="separator:af9c639795fa939f9ccf93342b5a76e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37001c9de58f2a351850d0fb3fce995"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:ae37001c9de58f2a351850d0fb3fce995"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#ae37001c9de58f2a351850d0fb3fce995">join</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2aa0f0bc95016c862498bbad29d1f4d9d4">separator</a>, const collection_t &amp;values, size_t index) noexcept</td></tr>
<tr class="memdesc:ae37001c9de58f2a351850d0fb3fce995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates a specified separator string between each element of a specified object array, yielding a single concatenated string.  <br /></td></tr>
<tr class="separator:ae37001c9de58f2a351850d0fb3fce995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506719218360ffaff29724ee5f15a5ff"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:a506719218360ffaff29724ee5f15a5ff"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a506719218360ffaff29724ee5f15a5ff">join</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2aa0f0bc95016c862498bbad29d1f4d9d4">separator</a>, const collection_t &amp;values, size_t index, size_t count) noexcept</td></tr>
<tr class="memdesc:a506719218360ffaff29724ee5f15a5ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates a specified separator string between each element of a specified Object array, yielding a single concatenated string.  <br /></td></tr>
<tr class="separator:a506719218360ffaff29724ee5f15a5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95694998a854ba65dde682b879eec355"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:a95694998a854ba65dde682b879eec355"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1ustring.html#a95694998a854ba65dde682b879eec355">join</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2aa0f0bc95016c862498bbad29d1f4d9d4">separator</a>, const collection_t &amp;values) noexcept</td></tr>
<tr class="memdesc:a95694998a854ba65dde682b879eec355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates a specified separator string between each element of a specified object array, yielding a single concatenated string.  <br /></td></tr>
<tr class="separator:a95694998a854ba65dde682b879eec355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90aeac5b1761195838734b45d1268dd3"><td class="memTemplParams" colspan="2"><a id="a90aeac5b1761195838734b45d1268dd3" name="a90aeac5b1761195838734b45d1268dd3"></a>
template&lt;typename value_t &gt; </td></tr>
<tr class="memitem:a90aeac5b1761195838734b45d1268dd3"><td class="memTemplItemLeft" align="right" valign="top">static value_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parse</b> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str)</td></tr>
<tr class="separator:a90aeac5b1761195838734b45d1268dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c65606fb81f84e4d9ea43002114d8de"><td class="memTemplParams" colspan="2">template&lt;typename ... args_t&gt; </td></tr>
<tr class="memitem:ga0c65606fb81f84e4d9ea43002114d8de"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__format__parse.html#ga0c65606fb81f84e4d9ea43002114d8de">sprintf</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;fmt, args_t &amp;&amp;... args) noexcept</td></tr>
<tr class="memdesc:ga0c65606fb81f84e4d9ea43002114d8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the text representation of the specified arguments list, to string using the specified format information.  <br /></td></tr>
<tr class="separator:ga0c65606fb81f84e4d9ea43002114d8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0975a450a98f2c65f5649d2144a0bf0e"><td class="memTemplParams" colspan="2"><a id="a0975a450a98f2c65f5649d2144a0bf0e" name="a0975a450a98f2c65f5649d2144a0bf0e"></a>
template&lt;typename value_t &gt; </td></tr>
<tr class="memitem:a0975a450a98f2c65f5649d2144a0bf0e"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_parse</b> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str, value_t &amp;value)</td></tr>
<tr class="separator:a0975a450a98f2c65f5649d2144a0bf0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classxtd_1_1object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classxtd_1_1object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classxtd_1_1object.html">xtd::object</a></td></tr>
<tr class="memitem:a75cb9ed56172fb088ca6697d5d836b13 inherit pub_static_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a75cb9ed56172fb088ca6697d5d836b13">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_a, const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a75cb9ed56172fb088ca6697d5d836b13 inherit pub_static_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are considered equal.  <br /></td></tr>
<tr class="separator:a75cb9ed56172fb088ca6697d5d836b13 inherit pub_static_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee13700465eead7934f450749b952d7 inherit pub_static_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a1ee13700465eead7934f450749b952d7">reference_equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_a, const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a1ee13700465eead7934f450749b952d7 inherit pub_static_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are the same instance.  <br /></td></tr>
<tr class="separator:a1ee13700465eead7934f450749b952d7 inherit pub_static_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="add61d5146149ee689a7f9bed1309cfad" name="add61d5146149ee689a7f9bed1309cfad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add61d5146149ee689a7f9bed1309cfad">&#9670;&#160;</a></span>ustring() <span class="overload">[1/64]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>. </p>

</div>
</div>
<a id="a08170f266741991ebf47b057a34ba124" name="a08170f266741991ebf47b057a34ba124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08170f266741991ebf47b057a34ba124">&#9670;&#160;</a></span>ustring() <span class="overload">[2/64]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09c6e9bc0de28607372aa298e5886f84" name="a09c6e9bc0de28607372aa298e5886f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c6e9bc0de28607372aa298e5886f84">&#9670;&#160;</a></span>ustring() <span class="overload">[3/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>character</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94c19dfade464033be0ffb4e86fb1ead" name="a94c19dfade464033be0ffb4e86fb1ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c19dfade464033be0ffb4e86fb1ead">&#9670;&#160;</a></span>ustring() <span class="overload">[4/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character and specified allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad29a459a06e5c764d0b18fad075cea34" name="ad29a459a06e5c764d0b18fad075cea34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29a459a06e5c764d0b18fad075cea34">&#9670;&#160;</a></span>ustring() <span class="overload">[5/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char8_t&#160;</td>
          <td class="paramname"><em>character</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59db9c06874d4741a6e9c9d18a145eca" name="a59db9c06874d4741a6e9c9d18a145eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59db9c06874d4741a6e9c9d18a145eca">&#9670;&#160;</a></span>ustring() <span class="overload">[6/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char8_t&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character and specified allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afea1c1140594578a58b076e047adac21" name="afea1c1140594578a58b076e047adac21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea1c1140594578a58b076e047adac21">&#9670;&#160;</a></span>ustring() <span class="overload">[7/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t&#160;</td>
          <td class="paramname"><em>character</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfa8a8cb6172ef1752d3c25ecb29fd8c" name="adfa8a8cb6172ef1752d3c25ecb29fd8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa8a8cb6172ef1752d3c25ecb29fd8c">&#9670;&#160;</a></span>ustring() <span class="overload">[8/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character and specified allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe57a6d7b4cb655ee1f16156de44b33b" name="abe57a6d7b4cb655ee1f16156de44b33b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe57a6d7b4cb655ee1f16156de44b33b">&#9670;&#160;</a></span>ustring() <span class="overload">[9/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t&#160;</td>
          <td class="paramname"><em>character</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82df5c1b3533255a3e0988f8b82c0938" name="a82df5c1b3533255a3e0988f8b82c0938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82df5c1b3533255a3e0988f8b82c0938">&#9670;&#160;</a></span>ustring() <span class="overload">[10/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character and specified allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0535cd596a71ac846ebf326d2795a230" name="a0535cd596a71ac846ebf326d2795a230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0535cd596a71ac846ebf326d2795a230">&#9670;&#160;</a></span>ustring() <span class="overload">[11/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t&#160;</td>
          <td class="paramname"><em>character</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54dbbd0d756bcd9fbb1af3d3e4b0d69a" name="a54dbbd0d756bcd9fbb1af3d3e4b0d69a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54dbbd0d756bcd9fbb1af3d3e4b0d69a">&#9670;&#160;</a></span>ustring() <span class="overload">[12/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified count copies of character and specified allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09e9d9b1b3d1dd5c2431aff1fb936b34" name="a09e9d9b1b3d1dd5c2431aff1fb936b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e9d9b1b3d1dd5c2431aff1fb936b34">&#9670;&#160;</a></span>ustring() <span class="overload">[13/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified substring at index and count characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a961a9ba4c72a3ef7e30ce00744fab282" name="a961a9ba4c72a3ef7e30ce00744fab282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961a9ba4c72a3ef7e30ce00744fab282">&#9670;&#160;</a></span>ustring() <span class="overload">[14/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified substring at index, count characters and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0dd03c9c81d6dcf7686bf80ef7183b0" name="ac0dd03c9c81d6dcf7686bf80ef7183b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0dd03c9c81d6dcf7686bf80ef7183b0">&#9670;&#160;</a></span>ustring() <span class="overload">[15/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified substring at index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a378a1ead97b2b5db84cc20e6dfd0a71d" name="a378a1ead97b2b5db84cc20e6dfd0a71d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a378a1ead97b2b5db84cc20e6dfd0a71d">&#9670;&#160;</a></span>ustring() <span class="overload">[16/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified substring at index and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a175105db0d4fd8d70afd6bf68e901c43" name="a175105db0d4fd8d70afd6bf68e901c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a175105db0d4fd8d70afd6bf68e901c43">&#9670;&#160;</a></span>ustring() <span class="overload">[17/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const value_type *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified substring and count characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94daf332e8506577c406ff8be31a68ed" name="a94daf332e8506577c406ff8be31a68ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94daf332e8506577c406ff8be31a68ed">&#9670;&#160;</a></span>ustring() <span class="overload">[18/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const value_type *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified substring, count characters and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22c52720442dea9e80a0ee939e0e8644" name="a22c52720442dea9e80a0ee939e0e8644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22c52720442dea9e80a0ee939e0e8644">&#9670;&#160;</a></span>ustring() <span class="overload">[19/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const value_type *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy. </p>

</div>
</div>
<a id="a82d9fbd84544ded58b56bb258c839977" name="a82d9fbd84544ded58b56bb258c839977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82d9fbd84544ded58b56bb258c839977">&#9670;&#160;</a></span>ustring() <span class="overload">[20/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const value_type *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4407cb0d803eaca779def996836accae" name="a4407cb0d803eaca779def996836accae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4407cb0d803eaca779def996836accae">&#9670;&#160;</a></span>ustring() <span class="overload">[21/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">value_type *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy. </p>

</div>
</div>
<a id="aa30cffa0a677d57c60dbc300e2a63f8e" name="aa30cffa0a677d57c60dbc300e2a63f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30cffa0a677d57c60dbc300e2a63f8e">&#9670;&#160;</a></span>ustring() <span class="overload">[22/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">value_type *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acaeedea48ef4f24dafe9ec8fb70092c5" name="acaeedea48ef4f24dafe9ec8fb70092c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaeedea48ef4f24dafe9ec8fb70092c5">&#9670;&#160;</a></span>ustring() <span class="overload">[23/64]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97ca1e3a8ea546462fe2490d87161e67" name="a97ca1e3a8ea546462fe2490d87161e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ca1e3a8ea546462fe2490d87161e67">&#9670;&#160;</a></span>ustring() <span class="overload">[24/64]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1d943de2665ca7471a3c7012f0ac85a" name="aa1d943de2665ca7471a3c7012f0ac85a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d943de2665ca7471a3c7012f0ac85a">&#9670;&#160;</a></span>ustring() <span class="overload">[25/64]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c224c965990e3a8674037250c9c466d" name="a9c224c965990e3a8674037250c9c466d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c224c965990e3a8674037250c9c466d">&#9670;&#160;</a></span>ustring() <span class="overload">[26/64]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1fcf93d304874f014d6a802be7666c1c" name="a1fcf93d304874f014d6a802be7666c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fcf93d304874f014d6a802be7666c1c">&#9670;&#160;</a></span>ustring() <span class="overload">[27/64]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const std::u8string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31e269e43bbcacd9b0071ccb1fe5e158" name="a31e269e43bbcacd9b0071ccb1fe5e158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e269e43bbcacd9b0071ccb1fe5e158">&#9670;&#160;</a></span>ustring() <span class="overload">[28/64]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const std::u8string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba1d8d4fc56116870e6e9098e801abff" name="aba1d8d4fc56116870e6e9098e801abff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba1d8d4fc56116870e6e9098e801abff">&#9670;&#160;</a></span>ustring() <span class="overload">[29/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const char8_t *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy. </p>

</div>
</div>
<a id="a237d083b73a7a66e19352951564776cd" name="a237d083b73a7a66e19352951564776cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237d083b73a7a66e19352951564776cd">&#9670;&#160;</a></span>ustring() <span class="overload">[30/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const char8_t *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a240c2a49a7a79d0b7507aafeaa589c97" name="a240c2a49a7a79d0b7507aafeaa589c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240c2a49a7a79d0b7507aafeaa589c97">&#9670;&#160;</a></span>ustring() <span class="overload">[31/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">char8_t *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy. </p>

</div>
</div>
<a id="adad2a2ae2c3230d2224e2f6f83f044b3" name="adad2a2ae2c3230d2224e2f6f83f044b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad2a2ae2c3230d2224e2f6f83f044b3">&#9670;&#160;</a></span>ustring() <span class="overload">[32/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">char8_t *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6819b6bf89183d64b7ac6d474772b07" name="ae6819b6bf89183d64b7ac6d474772b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6819b6bf89183d64b7ac6d474772b07">&#9670;&#160;</a></span>ustring() <span class="overload">[33/64]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const std::u16string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf6c2740de5260fc6cc9d3fa7066fbfe" name="abf6c2740de5260fc6cc9d3fa7066fbfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf6c2740de5260fc6cc9d3fa7066fbfe">&#9670;&#160;</a></span>ustring() <span class="overload">[34/64]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const std::u16string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9369a25f55d85baee88d5582e48d60a8" name="a9369a25f55d85baee88d5582e48d60a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9369a25f55d85baee88d5582e48d60a8">&#9670;&#160;</a></span>ustring() <span class="overload">[35/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy. </p>

</div>
</div>
<a id="ae5b32bfe4c25616b5cf7235017a7ee69" name="ae5b32bfe4c25616b5cf7235017a7ee69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b32bfe4c25616b5cf7235017a7ee69">&#9670;&#160;</a></span>ustring() <span class="overload">[36/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14ceb01ac4e91b4e8d249438bb82bca5" name="a14ceb01ac4e91b4e8d249438bb82bca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ceb01ac4e91b4e8d249438bb82bca5">&#9670;&#160;</a></span>ustring() <span class="overload">[37/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy. </p>

</div>
</div>
<a id="ad0bdd3aaccceb76e4c954980515aafee" name="ad0bdd3aaccceb76e4c954980515aafee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0bdd3aaccceb76e4c954980515aafee">&#9670;&#160;</a></span>ustring() <span class="overload">[38/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8c728901774cc83ca604138421d6268" name="ab8c728901774cc83ca604138421d6268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c728901774cc83ca604138421d6268">&#9670;&#160;</a></span>ustring() <span class="overload">[39/64]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const std::u32string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada4269aa64ca67c250c758763e6819cd" name="ada4269aa64ca67c250c758763e6819cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada4269aa64ca67c250c758763e6819cd">&#9670;&#160;</a></span>ustring() <span class="overload">[40/64]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const std::u32string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5568aa4bf07ade1928ee8bdf1572d960" name="a5568aa4bf07ade1928ee8bdf1572d960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5568aa4bf07ade1928ee8bdf1572d960">&#9670;&#160;</a></span>ustring() <span class="overload">[41/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy. </p>

</div>
</div>
<a id="a034d5156c913a076caa79b2ffbdba894" name="a034d5156c913a076caa79b2ffbdba894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a034d5156c913a076caa79b2ffbdba894">&#9670;&#160;</a></span>ustring() <span class="overload">[42/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac114e8fcb219ab9a4e5c24eb4d2859c5" name="ac114e8fcb219ab9a4e5c24eb4d2859c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac114e8fcb219ab9a4e5c24eb4d2859c5">&#9670;&#160;</a></span>ustring() <span class="overload">[43/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy. </p>

</div>
</div>
<a id="a2b5aaaef3ba5b68b59fb5c35d588edd6" name="a2b5aaaef3ba5b68b59fb5c35d588edd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b5aaaef3ba5b68b59fb5c35d588edd6">&#9670;&#160;</a></span>ustring() <span class="overload">[44/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6051d53b2892b7585b6278a2a5601b9" name="ac6051d53b2892b7585b6278a2a5601b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6051d53b2892b7585b6278a2a5601b9">&#9670;&#160;</a></span>ustring() <span class="overload">[45/64]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c026c8d5a2e188a7737ea902ae9c9f1" name="a2c026c8d5a2e188a7737ea902ae9c9f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c026c8d5a2e188a7737ea902ae9c9f1">&#9670;&#160;</a></span>ustring() <span class="overload">[46/64]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a175944050c9f206c169e9cf989f074e6" name="a175944050c9f206c169e9cf989f074e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a175944050c9f206c169e9cf989f074e6">&#9670;&#160;</a></span>ustring() <span class="overload">[47/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy. </p>

</div>
</div>
<a id="a88d993078380eb54472f7dd5ac45fa7c" name="a88d993078380eb54472f7dd5ac45fa7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d993078380eb54472f7dd5ac45fa7c">&#9670;&#160;</a></span>ustring() <span class="overload">[48/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac502899e85952e57e8a87b431fa9c01" name="aac502899e85952e57e8a87b431fa9c01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac502899e85952e57e8a87b431fa9c01">&#9670;&#160;</a></span>ustring() <span class="overload">[49/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy. </p>

</div>
</div>
<a id="a86b87d6c4a7b138aaeb1cd4ab8b2099d" name="a86b87d6c4a7b138aaeb1cd4ab8b2099d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b87d6c4a7b138aaeb1cd4ab8b2099d">&#9670;&#160;</a></span>ustring() <span class="overload">[50/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to copy, and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb84879a963d77159459e8aee6d21169" name="acb84879a963d77159459e8aee6d21169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb84879a963d77159459e8aee6d21169">&#9670;&#160;</a></span>ustring() <span class="overload">[51/64]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to move. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50a96f03a62a5c045296bf62e3c4c31f" name="a50a96f03a62a5c045296bf62e3c4c31f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a96f03a62a5c045296bf62e3c4c31f">&#9670;&#160;</a></span>ustring() <span class="overload">[52/64]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified string to move and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to move. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae61f98b244908a02d90c8c6f6fcab6eb" name="ae61f98b244908a02d90c8c6f6fcab6eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61f98b244908a02d90c8c6f6fcab6eb">&#9670;&#160;</a></span>ustring() <span class="overload">[53/64]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified first and last iterators of substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator of substring. </td></tr>
    <tr><td class="paramname">last</td><td>The first iterator of substring. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a233f13e910222e1b5ca44df02b51e42f" name="a233f13e910222e1b5ca44df02b51e42f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a233f13e910222e1b5ca44df02b51e42f">&#9670;&#160;</a></span>ustring() <span class="overload">[54/64]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified first and last iterators of substring and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator of substring. </td></tr>
    <tr><td class="paramname">last</td><td>The first iterator of substring. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26be076083adc627f2908488f9d5cc01" name="a26be076083adc627f2908488f9d5cc01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26be076083adc627f2908488f9d5cc01">&#9670;&#160;</a></span>ustring() <span class="overload">[55/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to fill. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a015261e2eb18d2ac46ca692829cd164d" name="a015261e2eb18d2ac46ca692829cd164d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015261e2eb18d2ac46ca692829cd164d">&#9670;&#160;</a></span>ustring() <span class="overload">[56/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to fill. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2683c509a0f3e461bf771a19e39a6356" name="a2683c509a0f3e461bf771a19e39a6356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2683c509a0f3e461bf771a19e39a6356">&#9670;&#160;</a></span>ustring() <span class="overload">[57/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; char8_t &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to fill. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2189c1d176ce1d7b2ea6013616e91df" name="ae2189c1d176ce1d7b2ea6013616e91df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2189c1d176ce1d7b2ea6013616e91df">&#9670;&#160;</a></span>ustring() <span class="overload">[58/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; char8_t &gt;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to fill. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a561273da0bdb033d15ce1d5262a17476" name="a561273da0bdb033d15ce1d5262a17476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561273da0bdb033d15ce1d5262a17476">&#9670;&#160;</a></span>ustring() <span class="overload">[59/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; char16_t &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to fill. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85f64819a9e36f572ee58fa6d1195596" name="a85f64819a9e36f572ee58fa6d1195596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f64819a9e36f572ee58fa6d1195596">&#9670;&#160;</a></span>ustring() <span class="overload">[60/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; char16_t &gt;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to fill. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15f69ab4e6372023098faf1606128485" name="a15f69ab4e6372023098faf1606128485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f69ab4e6372023098faf1606128485">&#9670;&#160;</a></span>ustring() <span class="overload">[61/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; char32_t &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to fill. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13cc641cc0f76d88950b435a34ed539f" name="a13cc641cc0f76d88950b435a34ed539f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13cc641cc0f76d88950b435a34ed539f">&#9670;&#160;</a></span>ustring() <span class="overload">[62/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; char32_t &gt;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to fill. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1dfb1e41dc9e79bd49b86f605d7e2333" name="a1dfb1e41dc9e79bd49b86f605d7e2333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dfb1e41dc9e79bd49b86f605d7e2333">&#9670;&#160;</a></span>ustring() <span class="overload">[63/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; wchar_t &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to fill. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8e9ea27f73c1dd7a9a629c59e072268" name="ab8e9ea27f73c1dd7a9a629c59e072268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e9ea27f73c1dd7a9a629c59e072268">&#9670;&#160;</a></span>ustring() <span class="overload">[64/64]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; wchar_t &gt;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> with specified initializer list and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to fill. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aafaae6b32a8bbfc8cd20defa2b14dc88" name="aafaae6b32a8bbfc8cd20defa2b14dc88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafaae6b32a8bbfc8cd20defa2b14dc88">&#9670;&#160;</a></span>class_name() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename object_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::class_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the class name of the object_t. </p>
<dl class="section return"><dt>Returns</dt><dd>The class name of the object_t. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example, the name of the ustring type is ustring. </dd></dl>

</div>
</div>
<a id="a5bf26167d0f67d103c069fb005063234" name="a5bf26167d0f67d103c069fb005063234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf26167d0f67d103c069fb005063234">&#9670;&#160;</a></span>class_name() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename object_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::class_name </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the class name of the specified object. </p>
<dl class="section return"><dt>Returns</dt><dd>The class name of the specified object. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example, the name of the ustring type is ustring. </dd></dl>

</div>
</div>
<a id="a7e4bcd6d2d8749fb41e52c3c7152fe13" name="a7e4bcd6d2d8749fb41e52c3c7152fe13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e4bcd6d2d8749fb41e52c3c7152fe13">&#9670;&#160;</a></span>class_name() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::class_name </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the class name of the specified object. </p>
<dl class="section return"><dt>Returns</dt><dd>The class name of the specified object. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example, the name of the ustring type is ustring. </dd></dl>

</div>
</div>
<a id="aade21fb4cb80096fd2a2fd981e6a3c1e" name="aade21fb4cb80096fd2a2fd981e6a3c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aade21fb4cb80096fd2a2fd981e6a3c1e">&#9670;&#160;</a></span>compare() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int xtd::ustring::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two specified string objects and returns an integer that indicates their relative position in the sort order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first string to compare. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second string to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates the lexical relationship between the two compares. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">str_a precedes str_b in the sort order.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">str_a occurs in the same position as str_b in the sort order.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">str_a follows str_b in the sort order.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a489f005f0e9ae03ace38598288ec6c4e" name="a489f005f0e9ae03ace38598288ec6c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489f005f0e9ae03ace38598288ec6c4e">&#9670;&#160;</a></span>compare() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int xtd::ustring::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_case</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two specified string objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first string to compare. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second string to compare. </td></tr>
    <tr><td class="paramname">ignore_case</td><td>true to ignore case during the comparison; otherwise, false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates the lexical relationship between the two compares. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">str_a precedes str_b in the sort order.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">str_a occurs in the same position as str_b in the sort order.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">str_a follows str_b in the sort order.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="aa7374a548fd02cf24a7c9a0f2ce893e9" name="aa7374a548fd02cf24a7c9a0f2ce893e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7374a548fd02cf24a7c9a0f2ce893e9">&#9670;&#160;</a></span>compare() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int xtd::ustring::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__xtd__core.html#ga04dd6c532656e286dfbf2f9aea3d8ccd">xtd::string_comparison</a>&#160;</td>
          <td class="paramname"><em>comparison_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two specified string objects using the specified rules, and returns an integer that indicates their relative position in the sort order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first string to compare. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second string to compare. </td></tr>
    <tr><td class="paramname">comparison_type</td><td>One of the enumeration values that specifies the rules to use in the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates the lexical relationship between the two compares. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">str_a precedes str_b in the sort order.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">str_a occurs in the same position as str_b in the sort order.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">str_a follows str_b in the sort order.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="af5bdabe5dfc8e2160af379447a671778" name="af5bdabe5dfc8e2160af379447a671778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5bdabe5dfc8e2160af379447a671778">&#9670;&#160;</a></span>compare() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int xtd::ustring::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares substrings of two specified string objects and returns an integer that indicates their relative position in the sort order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first string to use in the comparison. </td></tr>
    <tr><td class="paramname">index_a</td><td>The position of the substring within str_a. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second string to use in the comparison. </td></tr>
    <tr><td class="paramname">index_b</td><td>The position of the substring within str_b. </td></tr>
    <tr><td class="paramname">length</td><td>The maximum number of characters in the substrings to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates the lexical relationship between the two compares. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">str_a precedes str_b in the sort order.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">str_a occurs in the same position as str_b in the sort order.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">str_a follows str_b in the sort order.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a912c7cec4b476f3a49c80057588aa989" name="a912c7cec4b476f3a49c80057588aa989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a912c7cec4b476f3a49c80057588aa989">&#9670;&#160;</a></span>compare() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int xtd::ustring::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_case</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares substrings of two specified string objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first string to use in the comparison. </td></tr>
    <tr><td class="paramname">index_a</td><td>The position of the substring within str_a. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second string to use in the comparison. </td></tr>
    <tr><td class="paramname">index_b</td><td>The position of the substring within str_b. </td></tr>
    <tr><td class="paramname">length</td><td>The maximum number of characters in the substrings to compare </td></tr>
    <tr><td class="paramname">ignore_case</td><td>true to ignore case during the comparison; otherwise, false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates the lexical relationship between the two compares. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">str_a precedes str_b in the sort order.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">str_a occurs in the same position as str_b in the sort order.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">str_a follows str_b in the sort order.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a257a95d3381a404907617b077d40c915" name="a257a95d3381a404907617b077d40c915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a257a95d3381a404907617b077d40c915">&#9670;&#160;</a></span>compare() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int xtd::ustring::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__xtd__core.html#ga04dd6c532656e286dfbf2f9aea3d8ccd">xtd::string_comparison</a>&#160;</td>
          <td class="paramname"><em>comparison_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares substrings of two specified string objects using the specified rules, and returns an integer that indicates their relative position in the sort order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first string to use in the comparison. </td></tr>
    <tr><td class="paramname">index_a</td><td>The position of the substring within str_a. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second string to use in the comparison. </td></tr>
    <tr><td class="paramname">index_b</td><td>The position of the substring within str_b. </td></tr>
    <tr><td class="paramname">length</td><td>The maximum number of characters in the substrings to compare </td></tr>
    <tr><td class="paramname">comparison_type</td><td>One of the enumeration values that specifies the rules to use in the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates the lexical relationship between the two compares. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">str_a precedes str_b in the sort order.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">str_a occurs in the same position as str_b in the sort order.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">str_a follows str_b in the sort order.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a80f9f5b6643bb4527a966f6ce1f4f6fd" name="a80f9f5b6643bb4527a966f6ce1f4f6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f9f5b6643bb4527a966f6ce1f4f6fd">&#9670;&#160;</a></span>concat() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename object_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::concat </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; object_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates the string representations of the elements in a specified object array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>An object array that contains the elements to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The concatenated string representations of the values of the elements in args. </dd></dl>

</div>
</div>
<a id="acb605ccce66373c790611a13db14f14c" name="acb605ccce66373c790611a13db14f14c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb605ccce66373c790611a13db14f14c">&#9670;&#160;</a></span>concat() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::concat </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classxtd_1_1ustring.html">ustring</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates the elements of a specified string array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An array of string instances. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The concatenated elements of values. </dd></dl>

</div>
</div>
<a id="ae84e9e74970e64e21a97afee579ed6f3" name="ae84e9e74970e64e21a97afee579ed6f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84e9e74970e64e21a97afee579ed6f3">&#9670;&#160;</a></span>concat() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates two specified instances of string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first string to concatenate. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second string to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string The concatenation of str_a and str_b. </dd></dl>

</div>
</div>
<a id="aceda089f7586a63df656566d0c815d22" name="aceda089f7586a63df656566d0c815d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceda089f7586a63df656566d0c815d22">&#9670;&#160;</a></span>concat() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates three specified instances of string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first string to concatenate. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second string to concatenate. </td></tr>
    <tr><td class="paramname">str_c</td><td>The third string to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string The concatenation of str_a, str_b and str_c. </dd></dl>

</div>
</div>
<a id="a9d492d6b9ce2f2e38661a5062009a32f" name="a9d492d6b9ce2f2e38661a5062009a32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d492d6b9ce2f2e38661a5062009a32f">&#9670;&#160;</a></span>concat() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str_d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates four specified instances of string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first string to concatenate. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second string to concatenate. </td></tr>
    <tr><td class="paramname">str_c</td><td>The third string to concatenate. </td></tr>
    <tr><td class="paramname">str_d</td><td>The fourth string to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The concatenation of str_a, str_b, str_c and str_d. </dd></dl>

</div>
</div>
<a id="aa7018e6a7dce9dcf133a1e393b2152ec" name="aa7018e6a7dce9dcf133a1e393b2152ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7018e6a7dce9dcf133a1e393b2152ec">&#9670;&#160;</a></span>concat() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename object_a_t , typename object_b_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::concat </td>
          <td>(</td>
          <td class="paramtype">object_a_t&#160;</td>
          <td class="paramname"><em>obj_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object_b_t&#160;</td>
          <td class="paramname"><em>obj_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates two specified instances of object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj_a</td><td>The first object to concatenate. </td></tr>
    <tr><td class="paramname">obj_b</td><td>The second object to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The concatenation of obj_a and obj_b. </dd></dl>

</div>
</div>
<a id="a06bc47f8af41673e7f3d89c57c9cd525" name="a06bc47f8af41673e7f3d89c57c9cd525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06bc47f8af41673e7f3d89c57c9cd525">&#9670;&#160;</a></span>concat() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename object_a_t , typename object_b_t , typename object_c_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::concat </td>
          <td>(</td>
          <td class="paramtype">object_a_t&#160;</td>
          <td class="paramname"><em>obj_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object_b_t&#160;</td>
          <td class="paramname"><em>obj_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object_c_t&#160;</td>
          <td class="paramname"><em>obj_c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates three specified instances of object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj_a</td><td>The first object to concatenate. </td></tr>
    <tr><td class="paramname">obj_b</td><td>The second object to concatenate. </td></tr>
    <tr><td class="paramname">obj_c</td><td>The third object to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The concatenation of obj_a, obj_b and obj_c. </dd></dl>

</div>
</div>
<a id="a745ec7372c85f6c9126b26d010f4ea97" name="a745ec7372c85f6c9126b26d010f4ea97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a745ec7372c85f6c9126b26d010f4ea97">&#9670;&#160;</a></span>concat() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename object_a_t , typename object_b_t , typename object_c_t , typename object_d_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::concat </td>
          <td>(</td>
          <td class="paramtype">object_a_t&#160;</td>
          <td class="paramname"><em>obj_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object_b_t&#160;</td>
          <td class="paramname"><em>obj_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object_c_t&#160;</td>
          <td class="paramname"><em>obj_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object_d_t&#160;</td>
          <td class="paramname"><em>obj_d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates four specified instances of object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj_a</td><td>The first object to concatenate. </td></tr>
    <tr><td class="paramname">obj_b</td><td>The second object to concatenate. </td></tr>
    <tr><td class="paramname">obj_c</td><td>The third object to concatenate. </td></tr>
    <tr><td class="paramname">obj_d</td><td>The fourth object to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The concatenation of obj_a, obj_b, obj_c and obj_d. </dd></dl>

</div>
</div>
<a id="a3378d826fc5381609746ce3618084157" name="a3378d826fc5381609746ce3618084157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3378d826fc5381609746ce3618084157">&#9670;&#160;</a></span>concat() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::concat </td>
          <td>(</td>
          <td class="paramtype">value_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the string representation of a specified object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The object to represent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string representation of the value of arg. </dd></dl>

</div>
</div>
<a id="aea0e43190da2d939a59a911e46302af1" name="aea0e43190da2d939a59a911e46302af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea0e43190da2d939a59a911e46302af1">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::ustring::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a value indicating whether a specified substring occurs within this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string to seek. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value parameter occurs within this string, or if value is the empty string (""); otherwise, false. </dd></dl>

</div>
</div>
<a id="a238165aaab69fb9f6c909da1fcdb072f" name="a238165aaab69fb9f6c909da1fcdb072f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a238165aaab69fb9f6c909da1fcdb072f">&#9670;&#160;</a></span>demangle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::demangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets demangled string of name,. </p>
<dl class="section return"><dt>Returns</dt><dd>The demangled string of name. </dd></dl>

</div>
</div>
<a id="a928ab8c4d2e7bc8697ccad67b56f9e3d" name="a928ab8c4d2e7bc8697ccad67b56f9e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928ab8c4d2e7bc8697ccad67b56f9e3d">&#9670;&#160;</a></span>empty_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::empty_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the empty string. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The value of this method is the zero-length string, "". </dd></dl>

</div>
</div>
<a id="a75f37a3f06b8ef5e4a87a33919eba15a" name="a75f37a3f06b8ef5e4a87a33919eba15a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f37a3f06b8ef5e4a87a33919eba15a">&#9670;&#160;</a></span>ends_with() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::ustring::ends_with </td>
          <td>(</td>
          <td class="paramtype">char8_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the end of this string matches the specified character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The char_t to compare to the substring at the end of this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if value matches the end of this instance; otherwise, false. </dd></dl>

</div>
</div>
<a id="ad02f78ca99a3dfb0ee73bc0252b329b0" name="ad02f78ca99a3dfb0ee73bc0252b329b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02f78ca99a3dfb0ee73bc0252b329b0">&#9670;&#160;</a></span>ends_with() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::ustring::ends_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the end of this string matches the specified string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string to compare to the substring at the end of this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if value matches the end of this instance; otherwise, false. </dd></dl>

</div>
</div>
<a id="ae9d72ca87fc9bcdae5c8d3db042cdec9" name="ae9d72ca87fc9bcdae5c8d3db042cdec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d72ca87fc9bcdae5c8d3db042cdec9">&#9670;&#160;</a></span>ends_with() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::ustring::ends_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_case</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the end of this string instance matches the specified string when compared using the specified culture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ignore_case</td><td>true to ignore case during the comparison; otherwise, false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if value matches the end of the specified string; otherwise, false. </dd></dl>

</div>
</div>
<a id="a8fcc85777946011f389241af42b27aaf" name="a8fcc85777946011f389241af42b27aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fcc85777946011f389241af42b27aaf">&#9670;&#160;</a></span>ends_with() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::ustring::ends_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__xtd__core.html#ga04dd6c532656e286dfbf2f9aea3d8ccd">xtd::string_comparison</a>&#160;</td>
          <td class="paramname"><em>comparison_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the end of this string matches the specified string when compared using the specified comparison option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comparison_type</td><td>One of the enumeration values that determines how this string and value are compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if value matches the end of the specified string; otherwise, false. </dd></dl>

</div>
</div>
<a id="ab66c2037568657029c2695e7c5d43d84" name="ab66c2037568657029c2695e7c5d43d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab66c2037568657029c2695e7c5d43d84">&#9670;&#160;</a></span>ends_with() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::ustring::ends_with </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the end of this string matches the specified character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The char_t to compare to the substring at the end of this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if value matches the end of this instance; otherwise, false. </dd></dl>

</div>
</div>
<a id="aa6a65b727872715c7b99958e84a75f61" name="aa6a65b727872715c7b99958e84a75f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a65b727872715c7b99958e84a75f61">&#9670;&#160;</a></span>full_class_name() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename object_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::full_class_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the fully qualified class name of the objec_t, including the namespace of the objec_t. </p>
<dl class="section return"><dt>Returns</dt><dd>The fully qualified class name of the objec_t, including the namespace of the objec_t. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example, the fully qualified name of the ustring type is <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>. </dd></dl>

</div>
</div>
<a id="a81a0eee00e7f757562565f8e19c7747d" name="a81a0eee00e7f757562565f8e19c7747d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a0eee00e7f757562565f8e19c7747d">&#9670;&#160;</a></span>full_class_name() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename object_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::full_class_name </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the fully qualified class name of the specified object, including the namespace of the specified object. </p>
<dl class="section return"><dt>Returns</dt><dd>The fully qualified class name of the objec_t, including the namespace of the specified object. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example, the fully qualified name of the ustring type is <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>. </dd></dl>

</div>
</div>
<a id="af9c639795fa939f9ccf93342b5a76e45" name="af9c639795fa939f9ccf93342b5a76e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c639795fa939f9ccf93342b5a76e45">&#9670;&#160;</a></span>full_class_name() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::full_class_name </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the fully qualified class name of the specified object, including the namespace of the specified object. </p>
<dl class="section return"><dt>Returns</dt><dd>The fully qualified class name of the objec_t, including the namespace of the specified object. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example, the fully qualified name of the ustring type is <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a>. </dd></dl>

</div>
</div>
<a id="ab80f25a3a363194532225ddacc53e663" name="ab80f25a3a363194532225ddacc53e663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80f25a3a363194532225ddacc53e663">&#9670;&#160;</a></span>get_hash_code()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::get_hash_code </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the hash code for this string. </p>
<dl class="section return"><dt>Returns</dt><dd>A hash code. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1object.html#a1fea096f8a49ac5eef1f2431806109ca">xtd::object</a>.</p>

</div>
</div>
<a id="abde1d8ad0d05e9e769aaeb4510a993cb" name="abde1d8ad0d05e9e769aaeb4510a993cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde1d8ad0d05e9e769aaeb4510a993cb">&#9670;&#160;</a></span>index_of() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified string in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="af368ba7426298e88fd5b5dc5f06e4c6d" name="af368ba7426298e88fd5b5dc5f06e4c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af368ba7426298e88fd5b5dc5f06e4c6d">&#9670;&#160;</a></span>index_of() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified character in this string. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="aec7e84685e335551dd4e9868c110b427" name="aec7e84685e335551dd4e9868c110b427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7e84685e335551dd4e9868c110b427">&#9670;&#160;</a></span>index_of() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified character in this string. The search starts at a specified character position and examines a specified number of character positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="a74e9d6260703cb75dbff5a8e458083e3" name="a74e9d6260703cb75dbff5a8e458083e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e9d6260703cb75dbff5a8e458083e3">&#9670;&#160;</a></span>index_of() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::index_of </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified character in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="a65748d612fa86854545f4627f8c63601" name="a65748d612fa86854545f4627f8c63601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65748d612fa86854545f4627f8c63601">&#9670;&#160;</a></span>index_of() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::index_of </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified character in this string. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="a00535c21a723c61d49790a98fc56ac58" name="a00535c21a723c61d49790a98fc56ac58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00535c21a723c61d49790a98fc56ac58">&#9670;&#160;</a></span>index_of() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::index_of </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified character in this string. The search starts at a specified character position and examines a specified number of character positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="a52f8ff481971c33c05ccc60ff7c2397e" name="a52f8ff481971c33c05ccc60ff7c2397e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f8ff481971c33c05ccc60ff7c2397e">&#9670;&#160;</a></span>index_of_any() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::index_of_any </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence in this instance of any character in a specified array of characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>

</div>
</div>
<a id="a92268eec76bff7c4b3b33a7696cfb12a" name="a92268eec76bff7c4b3b33a7696cfb12a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92268eec76bff7c4b3b33a7696cfb12a">&#9670;&#160;</a></span>index_of_any() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::index_of_any </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>

</div>
</div>
<a id="ac8ec9a7b572cc3e92aabafe3c6bed320" name="ac8ec9a7b572cc3e92aabafe3c6bed320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ec9a7b572cc3e92aabafe3c6bed320">&#9670;&#160;</a></span>index_of_any() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::index_of_any </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>

</div>
</div>
<a id="a4fb8bd971a50be1f16f8a60f1acc5e8e" name="a4fb8bd971a50be1f16f8a60f1acc5e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb8bd971a50be1f16f8a60f1acc5e8e">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::insert </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a specified instance of string at a specified index position in this instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The index position of the insertion. </td></tr>
    <tr><td class="paramname">value</td><td>The string to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new string equivalent to this instance but with value inserted at position start_index. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If start_index is equal to the length of this instance, value is appended to the end of this instance. </dd>
<dd>
For example, the return value of "abc".Insert(2, "XYZ") is "abXYZc". </dd></dl>

</div>
</div>
<a id="a22354e7aab0bf4e272fcc3d48095e950" name="a22354e7aab0bf4e272fcc3d48095e950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22354e7aab0bf4e272fcc3d48095e950">&#9670;&#160;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::ustring::is_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this string is an empty string (""). </p>
<dl class="section return"><dt>Returns</dt><dd>true if the value parameter is null or an empty string (""); otherwise, false. </dd></dl>

</div>
</div>
<a id="ae37001c9de58f2a351850d0fb3fce995" name="ae37001c9de58f2a351850d0fb3fce995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae37001c9de58f2a351850d0fb3fce995">&#9670;&#160;</a></span>join() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates a specified separator string between each element of a specified object array, yielding a single concatenated string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>A string separator. </td></tr>
    <tr><td class="paramname">values</td><td>An array of Object. </td></tr>
    <tr><td class="paramname">start_index</td><td>The first array element in value to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string consisting of the elements of value interspersed with the separator string. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example if separator is ", " and the elements of value are "red", "blue", "green", and "yellow", Join(separator, value) returns "red, blue, green, yellow". </dd>
<dd>
stream &lt;&lt; operator is called on each object to generate the content. </dd></dl>

</div>
</div>
<a id="a506719218360ffaff29724ee5f15a5ff" name="a506719218360ffaff29724ee5f15a5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a506719218360ffaff29724ee5f15a5ff">&#9670;&#160;</a></span>join() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates a specified separator string between each element of a specified Object array, yielding a single concatenated string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>A string separator. </td></tr>
    <tr><td class="paramname">values</td><td>An array of Object. </td></tr>
    <tr><td class="paramname">start_index</td><td>The first array element in value to use. </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements of value to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string consisting of the elements of value interspersed with the separator string. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example if separator is ", " and the elements of value are "red", "blue", "green", and "yellow", Join(separator, value) returns "red, blue, green, yellow". </dd>
<dd>
stream &lt;&lt; operator is called on each object to generate the content. </dd></dl>

</div>
</div>
<a id="a95694998a854ba65dde682b879eec355" name="a95694998a854ba65dde682b879eec355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95694998a854ba65dde682b879eec355">&#9670;&#160;</a></span>join() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates a specified separator string between each element of a specified object array, yielding a single concatenated string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>A string separator. </td></tr>
    <tr><td class="paramname">values</td><td>An array of Object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string consisting of the elements of value interspersed with the separator string. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example if separator is ", " and the elements of value are "red", "blue", "green", and "yellow", Join(separator, value) returns "red, blue, green, yellow". </dd>
<dd>
stream &lt;&lt; operator is called on each object to generate the content. </dd></dl>

</div>
</div>
<a id="a8adab244b1165d2d9b849a39cf8ff55d" name="a8adab244b1165d2d9b849a39cf8ff55d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8adab244b1165d2d9b849a39cf8ff55d">&#9670;&#160;</a></span>last_index_of() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::last_index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified string in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="a120c87d0c32977516fe5f31ed968a541" name="a120c87d0c32977516fe5f31ed968a541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120c87d0c32977516fe5f31ed968a541">&#9670;&#160;</a></span>last_index_of() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::last_index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified character in this string. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="a125ebf9aadb1dc5948f57b0aca64b72a" name="a125ebf9aadb1dc5948f57b0aca64b72a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125ebf9aadb1dc5948f57b0aca64b72a">&#9670;&#160;</a></span>last_index_of() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::last_index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified character in this string. The search starts at a specified character position and examines a specified number of character positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="a1d6d810543949e28650f92b5206314a5" name="a1d6d810543949e28650f92b5206314a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6d810543949e28650f92b5206314a5">&#9670;&#160;</a></span>last_index_of() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::last_index_of </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified character in this tring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="a2c0899fdfb944945fe56abf5b74b4716" name="a2c0899fdfb944945fe56abf5b74b4716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0899fdfb944945fe56abf5b74b4716">&#9670;&#160;</a></span>last_index_of() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::last_index_of </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified character in this string. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="ab32dc6a0c560aa072d8ce83151530a75" name="ab32dc6a0c560aa072d8ce83151530a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab32dc6a0c560aa072d8ce83151530a75">&#9670;&#160;</a></span>last_index_of() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::last_index_of </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified character in this string. The search starts at a specified character position and examines a specified number of character positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>A string to find last index of. </td></tr>
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="a088f6faf6f0d3d4df9702c4185b04a30" name="a088f6faf6f0d3d4df9702c4185b04a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a088f6faf6f0d3d4df9702c4185b04a30">&#9670;&#160;</a></span>last_index_of_any() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::last_index_of_any </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence in this instance of any character in a specified array of characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>

</div>
</div>
<a id="aec4834f48993ac33b74f95069aa16357" name="aec4834f48993ac33b74f95069aa16357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec4834f48993ac33b74f95069aa16357">&#9670;&#160;</a></span>last_index_of_any() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::last_index_of_any </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>

</div>
</div>
<a id="a945e24afee50977935bd3aca1cdddb6a" name="a945e24afee50977935bd3aca1cdddb6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a945e24afee50977935bd3aca1cdddb6a">&#9670;&#160;</a></span>last_index_of_any() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t xtd::ustring::last_index_of_any </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>

</div>
</div>
<a id="aadfe62deb046bd17790cb22207d4f4f5" name="aadfe62deb046bd17790cb22207d4f4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadfe62deb046bd17790cb22207d4f4f5">&#9670;&#160;</a></span>pad_left() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::pad_left </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>total_width</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Right-aligns the characters in this string, padding with spaces on the left for a specified total length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">total_width</td><td>The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new string that is equivalent to the specified string, but right-aligned and padded on the left with as many spaces as needed to create a length of total_width. Or, if total_width is less than the length of the specified string, a new string object that is identical to the specified string. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>An unicode space is defined as hexadecimal 0x20. </dd>
<dd>
The pad_left(const std::basic_string&lt;char_t&gt;&amp;, int) method pads the beginning of the returned string. This means that, when used with right-to-left languages, it pads the right portion of the string.. </dd></dl>

</div>
</div>
<a id="a3a1d40bffb5a673ecdb6f13fdf19d954" name="a3a1d40bffb5a673ecdb6f13fdf19d954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1d40bffb5a673ecdb6f13fdf19d954">&#9670;&#160;</a></span>pad_left() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::pad_left </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>total_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>padding_char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Right-aligns the characters in this string, padding with spaces on the left for a specified total length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">total_width</td><td>The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters. </td></tr>
    <tr><td class="paramname">paddingChar</td><td>An unicode padding character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new string that is equivalent to the specified string, but right-aligned and padded on the left with as many spaces as needed to create a length of total_width. Or, if total_width is less than the length of the specified string, a new string object that is identical the specified string. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>An unicode space is defined as hexadecimal 0x20. </dd>
<dd>
The pad_left(const std::basic_string&lt;char_t&gt;&amp;, int) method pads the beginning of the returned string. This means that, when used with right-to-left languages, it pads the right portion of the string.. </dd></dl>

</div>
</div>
<a id="a7b9abb16d8b680c650dd5cad88b8ecdb" name="a7b9abb16d8b680c650dd5cad88b8ecdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b9abb16d8b680c650dd5cad88b8ecdb">&#9670;&#160;</a></span>pad_right() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::pad_right </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>total_width</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Left-aligns the characters in this string, padding with spaces on the right for a specified total length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">totalWidth</td><td>The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new string that is equivalent to the specified string, but left-aligned and padded on the right with as many spaces as needed to create a length of totalWidth. Or, if totalWidth is less than the length of the specified string, a new string object that is identical to the specified string. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>An unicode space is defined as hexadecimal 0x20. </dd>
<dd>
The PadRight(const std::basic_string&lt;char_t&gt;&amp;, int) method pads the end of the returned string. This means that, when used with right-to-left languages, it pads the left portion of the string.. </dd></dl>

</div>
</div>
<a id="a4acf4abd79ff8bc4eb2b2b314273084b" name="a4acf4abd79ff8bc4eb2b2b314273084b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4acf4abd79ff8bc4eb2b2b314273084b">&#9670;&#160;</a></span>pad_right() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::pad_right </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>total_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>padding_char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Left-aligns the characters in this string, padding with spaces on the right for a specified total length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">totalWidth</td><td>The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters. </td></tr>
    <tr><td class="paramname">paddingChar</td><td>An unicode padding character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new string that is equivalent to the specified string, but left-aligned and padded on the tight with as many spaces as needed to create a length of totalWidth. Or, if totalWidth is less than the length of the specified string, a new string object that is identical to the specified string. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>An unicode space is defined as hexadecimal 0x20. </dd>
<dd>
The <a class="el" href="classxtd_1_1ustring.html#a7b9abb16d8b680c650dd5cad88b8ecdb" title="Left-aligns the characters in this string, padding with spaces on the right for a specified total len...">xtd::ustring::pad_right</a> method pads the end of the returned string. This means that, when used with right-to-left languages, it pads the left portion of the string.. </dd></dl>

</div>
</div>
<a id="ac9e0a7ed099484646436a14ef1279ab5" name="ac9e0a7ed099484646436a14ef1279ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e0a7ed099484646436a14ef1279ab5">&#9670;&#160;</a></span>remove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::remove </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes all the characters from this string beginning at a specified position and continuing through the last position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The position to begin deleting characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new string object that is equivalent to this string less the removed characters. </dd></dl>

</div>
</div>
<a id="a02a41355798abb8ab801e4709afae16c" name="a02a41355798abb8ab801e4709afae16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a41355798abb8ab801e4709afae16c">&#9670;&#160;</a></span>remove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::remove </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes all the characters from this string beginning at a specified position and continuing through the last position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The position to begin deleting characters. </td></tr>
    <tr><td class="paramname">count</td><td>The number of characters to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new string object that is equivalent to this string less the removed characters. </dd></dl>

</div>
</div>
<a id="a35618679cb579be47165cda420847c0b" name="a35618679cb579be47165cda420847c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35618679cb579be47165cda420847c0b">&#9670;&#160;</a></span>replace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>old_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>new_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces all occurrences of a specified string in this string with another specified string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_string</td><td>A string to be replaced. </td></tr>
    <tr><td class="paramname">new_string</td><td>A string to replace all occurrences of old_string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new string equivalent to the specified string but with all instances of old_string replaced with new_string. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If new_string is empty, all occurrences of old_string are removed </dd></dl>

</div>
</div>
<a id="a8f47776cd7a5e8b7137138c83e12c53d" name="a8f47776cd7a5e8b7137138c83e12c53d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f47776cd7a5e8b7137138c83e12c53d">&#9670;&#160;</a></span>replace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::replace </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>old_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>new_char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces all occurrences of a specified char_t in this string with another specified char_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_char</td><td>A char_t to be replaced. </td></tr>
    <tr><td class="paramname">new_char</td><td>A char_t to replace all occurrences of old_char. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new string equivalent to the specified string but with all instances of old_char replaced with new_char. </dd></dl>

</div>
</div>
<a id="a66b33020b0d948fe3946a3535e8f8458" name="a66b33020b0d948fe3946a3535e8f8458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b33020b0d948fe3946a3535e8f8458">&#9670;&#160;</a></span>split() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classxtd_1_1ustring.html">ustring</a> &gt; xtd::ustring::split </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits this string into substrings that are based on the default white-space characters. White-space characters are defined by the c++ standard and return true if they are passed to the std::isspace() or std::iswspace() method. </p>
<dl class="section return"><dt>Returns</dt><dd>An array whose elements contain the substrings in this string that are delimited by one or more characters in white-space separators. For more information, see the Remarks section. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Delimiter characters are not included in the elements of the returned array. </dd>
<dd>
If the specified string does not contain any of the characters in separator, or the count parameter is 1, the returned array consists of a single element that contains the specified string. </dd></dl>

</div>
</div>
<a id="accdcbabd839bcc9dcea46df7ad5a8a18" name="accdcbabd839bcc9dcea46df7ad5a8a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accdcbabd839bcc9dcea46df7ad5a8a18">&#9670;&#160;</a></span>split() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classxtd_1_1ustring.html">ustring</a> &gt; xtd::ustring::split </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>separators</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits this string into substrings that are based on the characters in an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separators</td><td>A character array that delimits the substrings in this string, an empty array that contains no delimiters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array whose elements contain the substrings in this string that are delimited by one or more characters in separators. For more information, see the Remarks section. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Delimiter characters are not included in the elements of the returned array. </dd>
<dd>
If the specified string does not contain any of the characters in separator, or the count parameter is 1, the returned array consists of a single element that contains the specified string. </dd></dl>

</div>
</div>
<a id="a8cd5fd437bfcbac1c20e589e62200780" name="a8cd5fd437bfcbac1c20e589e62200780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cd5fd437bfcbac1c20e589e62200780">&#9670;&#160;</a></span>split() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classxtd_1_1ustring.html">ustring</a> &gt; xtd::ustring::split </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>separators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits this string into a maximum number of substrings based on the characters in an array. You also specify the maximum number of substrings to return. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separators</td><td>A character array that delimits the substrings in this string, an empty array that contains no delimiters. </td></tr>
    <tr><td class="paramname">count</td><td>The maximum number of substrings to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Delimiter characters are not included in the elements of the returned array. </dd>
<dd>
If the specified string does not contain any of the characters in separator, or the count parameter is 1, the returned array consists of a single element that contains the specified string. </dd>
<dd>
If the separator parameter contains no characters, white-space characters are assumed to be the delimiters. White-space characters are defined by the Unicode standard and return true if they are passed to the char_t.IsWhiteSpace method. </dd>
<dd>
Each element of separator defines a separate delimiter character. If two delimiters are adjacent, or a delimiter is found at the beginning or end of the specified string, the corresponding array element contains empty string. </dd>
<dd>
If there are more than count substrings in the specified string, the first count minus 1 substrings are returned in the first count minus 1 elements of the return value, and the remaining characters in the specified string are returned in the last element of the return value. </dd></dl>

</div>
</div>
<a id="a65cce1408f2ea06898b33f7427ad712b" name="a65cce1408f2ea06898b33f7427ad712b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65cce1408f2ea06898b33f7427ad712b">&#9670;&#160;</a></span>split() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classxtd_1_1ustring.html">ustring</a> &gt; xtd::ustring::split </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>separators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__xtd__core.html#ga1856f4f531626dc585fd1c8ccc6d596c">string_split_options</a>&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits this string into a maximum number of substrings based on the characters in an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separators</td><td>A character array that delimits the substrings in this string, an empty array that contains no delimiters. </td></tr>
    <tr><td class="paramname">count</td><td>The maximum number of substrings to return. </td></tr>
    <tr><td class="paramname">options</td><td><a class="el" href="group__xtd__core.html#gga1856f4f531626dc585fd1c8ccc6d596ca554bc886886f880e29b898519e657f9a" title="The return value does not include array elements that contain an empty string.">xtd::string_split_options::remove_empty_entries</a> to omit empty array elements from the array returned; or None to include empty array elements in the array returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array whose elements contain the substrings in this string that are delimited by one or more characters in separators. For more information, see the Remarks section. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Delimiter characters are not included in the elements of the returned array. </dd>
<dd>
If the specified string does not contain any of the characters in separator, or the count parameter is 1, the returned array consists of a single element that contains the specified string. </dd>
<dd>
If the count parameter is zero, or the options parameter is remove_empty_entries and the length of the specified string is zero, an empty array is returned. </dd>
<dd>
Each element of separator defines a separate delimiter character. If the options parameter is None, and two delimiters are adjacent or a delimiter is found at the beginning or end of the specified string, the corresponding array element contains an empty string. </dd>
<dd>
If there are more than count substrings in the specified string, the first count minus 1 substrings are returned in the first count minus 1 elements of the return value, and the remaining characters in the specified string are returned in the last element of the return value. </dd>
<dd>
If count is greater than the number of substrings, the available substrings are returned. </dd></dl>

</div>
</div>
<a id="a7d254b792df2455b4c27886cf65cdfa2" name="a7d254b792df2455b4c27886cf65cdfa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d254b792df2455b4c27886cf65cdfa2">&#9670;&#160;</a></span>split() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classxtd_1_1ustring.html">ustring</a> &gt; xtd::ustring::split </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>separators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__xtd__core.html#ga1856f4f531626dc585fd1c8ccc6d596c">string_split_options</a>&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits this string into substrings based on the characters in an array. You can specify whether the substrings include empty array elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separators</td><td>A character array that delimits the substrings in this string, an empty array that contains no delimiters. </td></tr>
    <tr><td class="paramname">options</td><td><a class="el" href="group__xtd__core.html#gga1856f4f531626dc585fd1c8ccc6d596ca554bc886886f880e29b898519e657f9a" title="The return value does not include array elements that contain an empty string.">xtd::string_split_options::remove_empty_entries</a> to omit empty array elements from the array returned; or None to include empty array elements in the array returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array whose elements contain the substrings in this string that are delimited by one or more characters in separators. For more information, see the Remarks section. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Delimiter characters are not included in the elements of the returned array. </dd>
<dd>
If the specified string does not contain any of the characters in separator, or the count parameter is 1, the returned array consists of a single element that contains the specified string. </dd>
<dd>
If the specified string does not contain any of the characters in separator, the returned array consists of a single element that contains the specified string. </dd>
<dd>
If the options parameter is remove_empty_entries and the length of the specified string is zero, the method returns an empty array. </dd>
<dd>
Each element of separator defines a separate delimiter that consists of a single character. If the options argument is none, and two delimiters are adjacent or a delimiter is found at the beginning or end of the specified string, the corresponding array element contains empty string. For example, if separator includes two elements, "-" and "_", the value of the string instance is "-_aa-_", and the value of the options argument is None, the method returns a string array with the following five elements:<ol type="1">
<li>empty string, which represents the empty string that precedes the "-" character at index 0.</li>
<li>empty string, which represents the empty string between the "-" character at index 0 and the "_" character at index 1.</li>
<li>"aa",</li>
<li>empty string, which represents the empty string that follows the "_" character at index 4.</li>
<li>empty string, which represents the empty string that follows the "-" character at index 5. </li>
</ol>
</dd>
<dd>
If the separator parameter contains no characters, white-space characters are assumed to be the delimiters. White-space characters are defined by the c++ standard and return true if they are passed to the std::isspace() or std::iswspace() method. </dd>
<dd>
If count is greater than the number of substrings, the available substrings are returned. </dd></dl>

</div>
</div>
<a id="ab847e62a85bbb1eb9044b9e8ebaead55" name="ab847e62a85bbb1eb9044b9e8ebaead55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab847e62a85bbb1eb9044b9e8ebaead55">&#9670;&#160;</a></span>starts_with() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::ustring::starts_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the beginning of this instance of String matches a specified String. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A String to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if value matches the beginning of the specified string; otherwise, false. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method compares value to the substring at the beginning of the specified string that is the same length as value, and returns an indication whether they are equal. To be equal, value must be a reference to this same instance, or match the beginning of the specified string. </dd></dl>

</div>
</div>
<a id="af98b6ee462e44358380fd35f8afb8994" name="af98b6ee462e44358380fd35f8afb8994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af98b6ee462e44358380fd35f8afb8994">&#9670;&#160;</a></span>starts_with() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::ustring::starts_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_case</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the beginning of this instance of String matches a specified String, ignoring or honoring their case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A String to compare to. </td></tr>
    <tr><td class="paramname">ignore_case</td><td>true to ignore case when comparing the specified string and value; otherwise, false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if value matches the beginning of the specified string; otherwise, false. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method compares value to the substring at the beginning of the specified string that is the same length as value, and returns an indication whether they are equal. To be equal, value must be a reference to this same instance, or match the beginning of the specified string. </dd></dl>

</div>
</div>
<a id="ade5334d81e1d6756cb0db9aeefeb5cea" name="ade5334d81e1d6756cb0db9aeefeb5cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5334d81e1d6756cb0db9aeefeb5cea">&#9670;&#160;</a></span>starts_with() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::ustring::starts_with </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the beginning of this instance of String matches a specified String. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A String to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if value matches the beginning of the specified string; otherwise, false. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method compares value to the substring at the beginning of the specified string that is the same length as value, and returns an indication whether they are equal. To be equal, value must be a reference to this same instance, or match the beginning of the specified string. </dd></dl>

</div>
</div>
<a id="a7c8892581c00c768b278d9657ed6aecf" name="a7c8892581c00c768b278d9657ed6aecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8892581c00c768b278d9657ed6aecf">&#9670;&#160;</a></span>starts_with() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::ustring::starts_with </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_case</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the beginning of this instance of String matches a specified String, ignoring or honoring their case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A String to compare to. </td></tr>
    <tr><td class="paramname">ignore_case</td><td>true to ignore case when comparing the specified string and value; otherwise, false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if value matches the beginning of the specified string; otherwise, false. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method compares value to the substring at the beginning of the specified string that is the same length as value, and returns an indication whether they are equal. To be equal, value must be a reference to this same instance, or match the beginning of the specified string. </dd></dl>

</div>
</div>
<a id="ad27e596eab3904c5084c2d2cb7ae05a1" name="ad27e596eab3904c5084c2d2cb7ae05a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27e596eab3904c5084c2d2cb7ae05a1">&#9670;&#160;</a></span>substring() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::substring </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a substring from this instance. The substring starts at a specified character position and has a specified length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to substring. </td></tr>
    <tr><td class="paramname">start_index</td><td>The zero-based starting character position of a substring in this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string equivalent to the substring of length length that begins at start_index in this instance, or Empty if start_index is equal to the length of this instance and length is zero. </dd></dl>

</div>
</div>
<a id="a3036669570cf96cc74bc68aad2098e53" name="a3036669570cf96cc74bc68aad2098e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3036669570cf96cc74bc68aad2098e53">&#9670;&#160;</a></span>substring() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::substring </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a substring from this instance. The substring starts at a specified character position and has a specified length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The zero-based starting character position of a substring in this instance. </td></tr>
    <tr><td class="paramname">length</td><td>The number of characters in the substring. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string equivalent to the substring of length length that begins at start_index in this instance, or Empty if start_index is equal to the length of this instance and length is zero. </dd></dl>

</div>
</div>
<a id="a53db7e47ebfb9f700184263cdffe90fc" name="a53db7e47ebfb9f700184263cdffe90fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53db7e47ebfb9f700184263cdffe90fc">&#9670;&#160;</a></span>to_array() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; value_type &gt; xtd::ustring::to_array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the characters in this instance to a Unicode character array. </p>
<dl class="section return"><dt>Returns</dt><dd>A character array whose elements are the individual characters of this instance. If this instance is an empty String, the returned array is empty and has a zero length. </dd></dl>

</div>
</div>
<a id="afbf5c498288cf53e891ec8a3227cd013" name="afbf5c498288cf53e891ec8a3227cd013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf5c498288cf53e891ec8a3227cd013">&#9670;&#160;</a></span>to_array() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; value_type &gt; xtd::ustring::to_array </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the characters in this instance to a Unicode character array starting at specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The starting position of string to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A character array whose elements are the individual characters of this instance. If this instance is an empty String, the returned array is empty and has a zero length. </dd></dl>

</div>
</div>
<a id="a0e16fac35c5b5145b14c0d8fa5059313" name="a0e16fac35c5b5145b14c0d8fa5059313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e16fac35c5b5145b14c0d8fa5059313">&#9670;&#160;</a></span>to_array() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; value_type &gt; xtd::ustring::to_array </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the characters in this instance to a Unicode character array starting at specified index with specified length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The starting position of string to convert. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the string to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A character array whose elements are the individual characters of this instance. If this instance is an empty String, the returned array is empty and has a zero length. </dd></dl>

</div>
</div>
<a id="af336a018fa7b2750e7cafe9dd708de4b" name="af336a018fa7b2750e7cafe9dd708de4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af336a018fa7b2750e7cafe9dd708de4b">&#9670;&#160;</a></span>to_lower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::to_lower </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the current string converted to lowercase. </p>
<dl class="section return"><dt>Returns</dt><dd>A new string in lowercase. </dd></dl>

</div>
</div>
<a id="ae1e5a8801e4f4c333649a0920b13b4d7" name="ae1e5a8801e4f4c333649a0920b13b4d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e5a8801e4f4c333649a0920b13b4d7">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a std::string that represents the current object. </p>
<dl class="section return"><dt>Returns</dt><dd>A string that represents the current object. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates what to_string returns. <div class="fragment"></div><!-- fragment --> </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1object.html#a5682215ee76ab97c48580ab162c49507">xtd::object</a>.</p>

</div>
</div>
<a id="a459c7cf5ab46bbce3088c6f8b0c87081" name="a459c7cf5ab46bbce3088c6f8b0c87081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a459c7cf5ab46bbce3088c6f8b0c87081">&#9670;&#160;</a></span>to_upper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::to_upper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the current string converted to uppercase. </p>
<dl class="section return"><dt>Returns</dt><dd>A new string in uppercase. </dd></dl>

</div>
</div>
<a id="a6521e1bcb7f90cc6e5678454c2488e0a" name="a6521e1bcb7f90cc6e5678454c2488e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6521e1bcb7f90cc6e5678454c2488e0a">&#9670;&#160;</a></span>trim() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::trim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all leading and trailing occurrences of white-space characters from the specified String. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to trim end. </td></tr>
    <tr><td class="paramname">trim_char</td><td>A character to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The String that remains after all occurrences of the character in the trim_char parameter are removed from the start and te and of the specified String. </dd></dl>

</div>
</div>
<a id="a201e55d40c55a79e7a10e884c2f472c1" name="a201e55d40c55a79e7a10e884c2f472c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a201e55d40c55a79e7a10e884c2f472c1">&#9670;&#160;</a></span>trim() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::trim </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>trim_chars</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all leading and trailing occurrences of a set of characters specified in an array from the specified String. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to trim end. </td></tr>
    <tr><td class="paramname">trim_chars</td><td>An array of characters to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The String that remains after all occurrences of the characters in the trim_chars parameter are removed from the start and the edn of the specified String. </dd></dl>

</div>
</div>
<a id="a47ee5015736be282dd15a37aed0dcb47" name="a47ee5015736be282dd15a37aed0dcb47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ee5015736be282dd15a37aed0dcb47">&#9670;&#160;</a></span>trim() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::trim </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>trim_char</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all leading and trailing occurrences of a character specified from the specified String . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to trim start. </td></tr>
    <tr><td class="paramname">trim_char</td><td>A character to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The String that remains after all occurrences of the character in the trim_char parameter are removed from the start and the end of the specified String. </dd></dl>

</div>
</div>
<a id="a6d193fc8b669cf1d49b92fd0fab9ed0f" name="a6d193fc8b669cf1d49b92fd0fab9ed0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d193fc8b669cf1d49b92fd0fab9ed0f">&#9670;&#160;</a></span>trim_end() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::trim_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all trailing occurrences of white-space characters from the specified String. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to trim end. </td></tr>
    <tr><td class="paramname">trim_char</td><td>A character to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The String that remains after all occurrences of the character in the trim_char parameter are removed from the end of the specified String. </dd></dl>

</div>
</div>
<a id="abf27752e3802e2d62fd358004b5c419e" name="abf27752e3802e2d62fd358004b5c419e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf27752e3802e2d62fd358004b5c419e">&#9670;&#160;</a></span>trim_end() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::trim_end </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>trim_chars</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all trailing occurrences of a set of characters specified in an array from the specified String. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to trim end. </td></tr>
    <tr><td class="paramname">trim_chars</td><td>An array of characters to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The String that remains after all occurrences of the characters in the trim_chars parameter are removed from the end of the specified String. </dd></dl>

</div>
</div>
<a id="aa517a64d866a66f04511e9bad2d2af35" name="aa517a64d866a66f04511e9bad2d2af35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa517a64d866a66f04511e9bad2d2af35">&#9670;&#160;</a></span>trim_end() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::trim_end </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>trim_char</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all trailing occurrences of a character specified from the specified String . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to trim start. </td></tr>
    <tr><td class="paramname">trim_char</td><td>A character to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The String that remains after all occurrences of the character in the trim_char parameter are removed from the end of the specified String. </dd></dl>

</div>
</div>
<a id="a8778eb32e44c58c7f9576cd2bf5bfceb" name="a8778eb32e44c58c7f9576cd2bf5bfceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8778eb32e44c58c7f9576cd2bf5bfceb">&#9670;&#160;</a></span>trim_start() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::trim_start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all leading occurrences of white-space characters from the specified String. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to trim start. </td></tr>
    <tr><td class="paramname">trim_char</td><td>A character to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The String that remains after all occurrences of the character in the trim_char parameter are removed from the start of the specified String. </dd></dl>

</div>
</div>
<a id="aceb88ae933c826a42b98beab955d0199" name="aceb88ae933c826a42b98beab955d0199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceb88ae933c826a42b98beab955d0199">&#9670;&#160;</a></span>trim_start() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::trim_start </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>trim_chars</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all leading occurrences of a set of characters specified in an array from the specified String. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to trim start. </td></tr>
    <tr><td class="paramname">trim_chars</td><td>An array of characters to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The String that remains after all occurrences of the characters in the trim_chars parameter are removed from the start of the specified String. </dd></dl>

</div>
</div>
<a id="af5bc64baa95dea6d1d28d79438899a31" name="af5bc64baa95dea6d1d28d79438899a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5bc64baa95dea6d1d28d79438899a31">&#9670;&#160;</a></span>trim_start() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::ustring::trim_start </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>trim_char</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all leading occurrences of a character specified from the specified String . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to trim start. </td></tr>
    <tr><td class="paramname">trim_char</td><td>A character to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The String that remains after all occurrences of the character in the trim_char parameter are removed from the start of the specified String. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/<a class="el" href="ustring_8h_source.html">ustring.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 12 2024 16:25:10 for xtd - Reference Guide by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
