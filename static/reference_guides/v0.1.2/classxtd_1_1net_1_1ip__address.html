<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<meta name="generator" content="Doxygen 1.9.7"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		<title>xtd - Reference Guide: xtd::net::ip_address Class Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
	</head>
	<body>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
			<table cellspacing="0" cellpadding="0">
				<tbody>
					<tr style="height: 56px;">
						<td id="projectlogo"><img alt="Logo" src="xtd_doxygen.png"/></td>
						<td id="projectalign" style="padding-left: 0.5em;">
							<div id="projectname">xtd - Reference Guide
								&#160;<span id="projectnumber">0.1.2</span>
							</div>
							<div id="projectbrief">Modern c++17/20 framework to create console, GUI and unit test applications on Windows, macOS, Linux, iOS and android.</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part --><!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="namespacextd_1_1net.html">net</a></li><li class="navelem"><a class="el" href="classxtd_1_1net_1_1ip__address.html">ip_address</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classxtd_1_1net_1_1ip__address-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::net::ip_address Class Reference<div class="ingroups"><a class="el" href="group__libraries.html">libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a> &raquo; <a class="el" href="group__net.html">net</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="ip__address_8h_source.html">ip_address.h</a>&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><p>Provides an Internet Protocol (IP) address. </p>
<dl class="section user"><dt>Namespace</dt><dd><a class="el" href="namespacextd_1_1net.html" title="The xtd::net namespace provides a simple programming interface for many of the protocols used on netw...">xtd::net</a> </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core </dd></dl>
</div>
<p>Inherits <a class="el" href="classxtd_1_1object.html">xtd::object</a>, and <a class="el" href="classxtd_1_1iequatable.html">xtd::iequatable&lt; ip_address &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a7c9f9e74d8b2b7c4e003f20736cb3d7a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1net_1_1ip__address.html">ip_address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#a7c9f9e74d8b2b7c4e003f20736cb3d7a">any</a></td></tr>
<tr class="memdesc:a7c9f9e74d8b2b7c4e003f20736cb3d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an IP address that indicates that the server must listen for client activity on all network interfaces. This field is constant.  <br /></td></tr>
<tr class="separator:a7c9f9e74d8b2b7c4e003f20736cb3d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d8d0f4440ac8cf10403534c9b2e0c6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1net_1_1ip__address.html">ip_address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#a08d8d0f4440ac8cf10403534c9b2e0c6">broadcast</a></td></tr>
<tr class="memdesc:a08d8d0f4440ac8cf10403534c9b2e0c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the IP broadcast address. This field is constant.  <br /></td></tr>
<tr class="separator:a08d8d0f4440ac8cf10403534c9b2e0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ad2c7df265c44764e325d02df1895e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1net_1_1ip__address.html">ip_address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#a09ad2c7df265c44764e325d02df1895e">ip_v6_any</a></td></tr>
<tr class="memdesc:a09ad2c7df265c44764e325d02df1895e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Socket::Bind method uses the cIPv6Any field to indicate that a Socket must listen for client activity on all network interfaces. This field is constant.  <br /></td></tr>
<tr class="separator:a09ad2c7df265c44764e325d02df1895e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec19e1f22b8910e852dce40a4c6caf60"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1net_1_1ip__address.html">ip_address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#aec19e1f22b8910e852dce40a4c6caf60">ip_v6_loopback</a></td></tr>
<tr class="memdesc:aec19e1f22b8910e852dce40a4c6caf60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the IP loopback address. This field is constant.  <br /></td></tr>
<tr class="separator:aec19e1f22b8910e852dce40a4c6caf60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e65be30fda89784598cf8292360a25a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1net_1_1ip__address.html">ip_address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#a0e65be30fda89784598cf8292360a25a">ip_v6_none</a></td></tr>
<tr class="memdesc:a0e65be30fda89784598cf8292360a25a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an IP address that indicates that no network interface should be used. This field is constant.  <br /></td></tr>
<tr class="separator:a0e65be30fda89784598cf8292360a25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97ec37d5ae5e391246dc8f19afaa626"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1net_1_1ip__address.html">ip_address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#af97ec37d5ae5e391246dc8f19afaa626">loopback</a></td></tr>
<tr class="memdesc:af97ec37d5ae5e391246dc8f19afaa626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the IP loopback address. This field is constant.  <br /></td></tr>
<tr class="separator:af97ec37d5ae5e391246dc8f19afaa626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6288112f5979aec314ea716836961a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1net_1_1ip__address.html">ip_address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#acb6288112f5979aec314ea716836961a">none</a></td></tr>
<tr class="memdesc:acb6288112f5979aec314ea716836961a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an IP address that indicates that no network interface should be used. This field is constant.  <br /></td></tr>
<tr class="separator:acb6288112f5979aec314ea716836961a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5cf17e49fc477fe3cf30ddca978c30ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#a5cf17e49fc477fe3cf30ddca978c30ac">ip_address</a> ()=default</td></tr>
<tr class="memdesc:a5cf17e49fc477fe3cf30ddca978c30ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1net_1_1ip__address.html" title="Provides an Internet Protocol (IP) address.">xtd::net::ip_address</a>.  <br /></td></tr>
<tr class="separator:a5cf17e49fc477fe3cf30ddca978c30ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8dcf9f72e20f5be4b083c3ee810fa62"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#ad8dcf9f72e20f5be4b083c3ee810fa62">ip_address</a> (byte_t quad_part_address1, byte_t quad_part_address2, byte_t quad_part_address3, byte_t quad_part_address4)</td></tr>
<tr class="memdesc:ad8dcf9f72e20f5be4b083c3ee810fa62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1net_1_1ip__address.html" title="Provides an Internet Protocol (IP) address.">xtd::net::ip_address</a> class with the address specified as a four Bytes.  <br /></td></tr>
<tr class="separator:ad8dcf9f72e20f5be4b083c3ee810fa62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce19db5bef8790f9008dd5868adc7f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#a0ce19db5bef8790f9008dd5868adc7f5">ip_address</a> (const std::vector&lt; byte_t &gt; &amp;address)</td></tr>
<tr class="memdesc:a0ce19db5bef8790f9008dd5868adc7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1net_1_1ip__address.html" title="Provides an Internet Protocol (IP) address.">xtd::net::ip_address</a> class with the address specified as a byte array.  <br /></td></tr>
<tr class="separator:a0ce19db5bef8790f9008dd5868adc7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c8a521a38c0d4a85d50c8142c75516"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#a47c8a521a38c0d4a85d50c8142c75516">ip_address</a> (const std::vector&lt; byte_t &gt; &amp;address, uint32_t <a class="el" href="classxtd_1_1net_1_1ip__address.html#a5530d86e599758767cf87067e2e73f9f">scope_id</a>)</td></tr>
<tr class="memdesc:a47c8a521a38c0d4a85d50c8142c75516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1net_1_1ip__address.html" title="Provides an Internet Protocol (IP) address.">xtd::net::ip_address</a> class with the address specified as a byte array.  <br /></td></tr>
<tr class="separator:a47c8a521a38c0d4a85d50c8142c75516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd1a85a12c8a82d57a750f85b90a014"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#aecd1a85a12c8a82d57a750f85b90a014">ip_address</a> (uint32_t address)</td></tr>
<tr class="memdesc:aecd1a85a12c8a82d57a750f85b90a014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1net_1_1ip__address.html" title="Provides an Internet Protocol (IP) address.">xtd::net::ip_address</a> class with the address specified as an int64_t.  <br /></td></tr>
<tr class="separator:aecd1a85a12c8a82d57a750f85b90a014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac71bd917d3323d6eb19483354b07bf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__xtd__core.html#ga5c7a488efbbc9c766286c1485399aef3">sockets::address_family</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#aac71bd917d3323d6eb19483354b07bf5">address_family</a> () const noexcept</td></tr>
<tr class="memdesc:aac71bd917d3323d6eb19483354b07bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the address family of the IP address.  <br /></td></tr>
<tr class="separator:aac71bd917d3323d6eb19483354b07bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac33b15af7d135a85f7ea83f64e61f9"><td class="memItemLeft" align="right" valign="top"><a id="a0ac33b15af7d135a85f7ea83f64e61f9" name="a0ac33b15af7d135a85f7ea83f64e61f9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>equals</b> (const <a class="el" href="classxtd_1_1net_1_1ip__address.html">ip_address</a> &amp;other) const noexcept override</td></tr>
<tr class="separator:a0ac33b15af7d135a85f7ea83f64e61f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a037b61573882b1da1157216b7e2613"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#a3a037b61573882b1da1157216b7e2613">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;other) const noexcept override</td></tr>
<tr class="memdesc:a3a037b61573882b1da1157216b7e2613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object is equal to the current object.  <br /></td></tr>
<tr class="separator:a3a037b61573882b1da1157216b7e2613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f30bf5c411ba143a7385eb7962d423"><td class="memItemLeft" align="right" valign="top">std::vector&lt; byte_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#ac9f30bf5c411ba143a7385eb7962d423">get_address_bytes</a> () const</td></tr>
<tr class="memdesc:ac9f30bf5c411ba143a7385eb7962d423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a copy of the IPAddress as an array of bytes.  <br /></td></tr>
<tr class="separator:ac9f30bf5c411ba143a7385eb7962d423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af612d35827ddd1cab111165226c1c38c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#af612d35827ddd1cab111165226c1c38c">is_ip_v4_mapped_to_ip_v6</a> () const noexcept</td></tr>
<tr class="memdesc:af612d35827ddd1cab111165226c1c38c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether the IP address is an IPv4-mapped IPv6 address.  <br /></td></tr>
<tr class="separator:af612d35827ddd1cab111165226c1c38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5d7c5d30ef7c4e9dbfa9409d7a7bf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#a8f5d7c5d30ef7c4e9dbfa9409d7a7bf3">is_ip_v6_link_local</a> () const noexcept</td></tr>
<tr class="memdesc:a8f5d7c5d30ef7c4e9dbfa9409d7a7bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether the address is an IPv6 link local address.  <br /></td></tr>
<tr class="separator:a8f5d7c5d30ef7c4e9dbfa9409d7a7bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eee0ed2d8aabaf44ea53316f168a5a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#a9eee0ed2d8aabaf44ea53316f168a5a3">is_ip_v6_multicast</a> () const noexcept</td></tr>
<tr class="memdesc:a9eee0ed2d8aabaf44ea53316f168a5a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether the address is an IPv6 multicast global address.  <br /></td></tr>
<tr class="separator:a9eee0ed2d8aabaf44ea53316f168a5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff921c3a571077951246ef3dd5c59e99"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#aff921c3a571077951246ef3dd5c59e99">is_ip_v6_site_local</a> () const noexcept</td></tr>
<tr class="memdesc:aff921c3a571077951246ef3dd5c59e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether the address is an IPv6 site local address.  <br /></td></tr>
<tr class="separator:aff921c3a571077951246ef3dd5c59e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244eb15fc215fca6488aa2118111dc1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#a244eb15fc215fca6488aa2118111dc1a">is_ip_v6_teredo</a> () const noexcept</td></tr>
<tr class="memdesc:a244eb15fc215fca6488aa2118111dc1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether the address is an IPv6 Teredo address.  <br /></td></tr>
<tr class="separator:a244eb15fc215fca6488aa2118111dc1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11920203958cff3746c7d17f6fe988d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1net_1_1ip__address.html">ip_address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#ae11920203958cff3746c7d17f6fe988d">map_to_ip_v4</a> () const noexcept</td></tr>
<tr class="memdesc:ae11920203958cff3746c7d17f6fe988d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps the <a class="el" href="classxtd_1_1net_1_1ip__address.html" title="Provides an Internet Protocol (IP) address.">xtd::net::ip_address</a> object to an IPv4 address.  <br /></td></tr>
<tr class="separator:ae11920203958cff3746c7d17f6fe988d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59f8b5a2d22acba13172a18f5cf553d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1net_1_1ip__address.html">ip_address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#ae59f8b5a2d22acba13172a18f5cf553d">map_to_ip_v6</a> () const noexcept</td></tr>
<tr class="memdesc:ae59f8b5a2d22acba13172a18f5cf553d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps the <a class="el" href="classxtd_1_1net_1_1ip__address.html" title="Provides an Internet Protocol (IP) address.">xtd::net::ip_address</a> object to an IPv6 address.  <br /></td></tr>
<tr class="separator:ae59f8b5a2d22acba13172a18f5cf553d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5530d86e599758767cf87067e2e73f9f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#a5530d86e599758767cf87067e2e73f9f">scope_id</a> () const</td></tr>
<tr class="memdesc:a5530d86e599758767cf87067e2e73f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the IPv6 address scope identifier.  <br /></td></tr>
<tr class="separator:a5530d86e599758767cf87067e2e73f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded48f1d69d6d163e6aa68701d1c89be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1net_1_1ip__address.html">ip_address</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#aded48f1d69d6d163e6aa68701d1c89be">scope_id</a> (uint32_t value)</td></tr>
<tr class="memdesc:aded48f1d69d6d163e6aa68701d1c89be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the IPv6 address scope identifier.  <br /></td></tr>
<tr class="separator:aded48f1d69d6d163e6aa68701d1c89be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ae0bff8c72f67a47c1122465204650"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#ae2ae0bff8c72f67a47c1122465204650">to_string</a> () const noexcept override</td></tr>
<tr class="memdesc:ae2ae0bff8c72f67a47c1122465204650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an Internet address to its standard notation.  <br /></td></tr>
<tr class="separator:ae2ae0bff8c72f67a47c1122465204650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1object.html">xtd::object</a></td></tr>
<tr class="memitem:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ad2cab851376bb6ca085b567bf5da0f5f">object</a> ()=default</td></tr>
<tr class="memdesc:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of the ultimate base class object.  <br /></td></tr>
<tr class="separator:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2743b6f75405882c28eebe2456f3837b inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a2743b6f75405882c28eebe2456f3837b">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;obj) const noexcept</td></tr>
<tr class="memdesc:a2743b6f75405882c28eebe2456f3837b inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object is equal to the current object.  <br /></td></tr>
<tr class="separator:a2743b6f75405882c28eebe2456f3837b inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a1fea096f8a49ac5eef1f2431806109ca">get_hash_code</a> () const noexcept</td></tr>
<tr class="memdesc:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serves as a hash function for a particular type.  <br /></td></tr>
<tr class="separator:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1d6739fb74be554719eced219de59a inherit pub_methods_classxtd_1_1object"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:a7d1d6739fb74be554719eced219de59a inherit pub_methods_classxtd_1_1object"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; object_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a7d1d6739fb74be554719eced219de59a">memberwise_clone</a> () const</td></tr>
<tr class="memdesc:a7d1d6739fb74be554719eced219de59a inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the current instance.  <br /></td></tr>
<tr class="separator:a7d1d6739fb74be554719eced219de59a inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5682215ee76ab97c48580ab162c49507 inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1ustring.html">xtd::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a5682215ee76ab97c48580ab162c49507">to_string</a> () const noexcept</td></tr>
<tr class="memdesc:a5682215ee76ab97c48580ab162c49507 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a std::string that represents the current object.  <br /></td></tr>
<tr class="separator:a5682215ee76ab97c48580ab162c49507 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1iequatable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1iequatable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1iequatable.html">xtd::iequatable&lt; ip_address &gt;</a></td></tr>
<tr class="memitem:a1f8bbde943d2e5ecf565734c60e23903 inherit pub_methods_classxtd_1_1iequatable"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1iequatable.html#a1f8bbde943d2e5ecf565734c60e23903">equals</a> (const ip_address &amp;) const noexcept=0</td></tr>
<tr class="memdesc:a1f8bbde943d2e5ecf565734c60e23903 inherit pub_methods_classxtd_1_1iequatable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the current object is equal to another object of the same type.  <br /></td></tr>
<tr class="separator:a1f8bbde943d2e5ecf565734c60e23903 inherit pub_methods_classxtd_1_1iequatable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f642819e9d04a6d0414172c2fcaf99 inherit pub_methods_classxtd_1_1iequatable"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1iequatable.html#ab4f642819e9d04a6d0414172c2fcaf99">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;) const noexcept=0</td></tr>
<tr class="memdesc:ab4f642819e9d04a6d0414172c2fcaf99 inherit pub_methods_classxtd_1_1iequatable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the current object is equal to another object of the same type.  <br /></td></tr>
<tr class="separator:ab4f642819e9d04a6d0414172c2fcaf99 inherit pub_methods_classxtd_1_1iequatable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:adb7843e3ef7df8ab39e71a4f0cd020d7"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#adb7843e3ef7df8ab39e71a4f0cd020d7">host_to_network_order</a> (double host)</td></tr>
<tr class="memdesc:adb7843e3ef7df8ab39e71a4f0cd020d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Double value from host byte order to network byte order.  <br /></td></tr>
<tr class="separator:adb7843e3ef7df8ab39e71a4f0cd020d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88f40e546ba7aa0d1395c5a64b31b58"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#aa88f40e546ba7aa0d1395c5a64b31b58">host_to_network_order</a> (float host)</td></tr>
<tr class="memdesc:aa88f40e546ba7aa0d1395c5a64b31b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Single value from host byte order to network byte order.  <br /></td></tr>
<tr class="separator:aa88f40e546ba7aa0d1395c5a64b31b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d3493357113475e915f4981fb327c4"><td class="memItemLeft" align="right" valign="top">static int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#ac6d3493357113475e915f4981fb327c4">host_to_network_order</a> (int16_t host)</td></tr>
<tr class="memdesc:ac6d3493357113475e915f4981fb327c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a short value from host byte order to network byte order.  <br /></td></tr>
<tr class="separator:ac6d3493357113475e915f4981fb327c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f677771303bb77180d36e90e68e43d"><td class="memItemLeft" align="right" valign="top">static int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#a91f677771303bb77180d36e90e68e43d">host_to_network_order</a> (int32_t host)</td></tr>
<tr class="memdesc:a91f677771303bb77180d36e90e68e43d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a integer value from host byte order to network byte order.  <br /></td></tr>
<tr class="separator:a91f677771303bb77180d36e90e68e43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea890909455c6531a9d3c4c1161526a"><td class="memItemLeft" align="right" valign="top">static int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#acea890909455c6531a9d3c4c1161526a">host_to_network_order</a> (int64_t host)</td></tr>
<tr class="memdesc:acea890909455c6531a9d3c4c1161526a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a long value from host byte order to network byte order.  <br /></td></tr>
<tr class="separator:acea890909455c6531a9d3c4c1161526a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abefdd9b886845080c8f48726f188c22a"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#abefdd9b886845080c8f48726f188c22a">host_to_network_order</a> (uint16_t host)</td></tr>
<tr class="memdesc:abefdd9b886845080c8f48726f188c22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a short value from host byte order to network byte order.  <br /></td></tr>
<tr class="separator:abefdd9b886845080c8f48726f188c22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cef1adfde0b3aa7a8e523e796d8c1c6"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#a3cef1adfde0b3aa7a8e523e796d8c1c6">host_to_network_order</a> (uint32_t host)</td></tr>
<tr class="memdesc:a3cef1adfde0b3aa7a8e523e796d8c1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a integer value from host byte order to network byte order.  <br /></td></tr>
<tr class="separator:a3cef1adfde0b3aa7a8e523e796d8c1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80e940a192f5477b368e42aa3876a9c"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#af80e940a192f5477b368e42aa3876a9c">host_to_network_order</a> (uint64_t host)</td></tr>
<tr class="memdesc:af80e940a192f5477b368e42aa3876a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a long value from host byte order to network byte order.  <br /></td></tr>
<tr class="separator:af80e940a192f5477b368e42aa3876a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5835797f1567c87a180992a02421cf7"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#ad5835797f1567c87a180992a02421cf7">is_loopback</a> (const <a class="el" href="classxtd_1_1net_1_1ip__address.html">ip_address</a> &amp;address)</td></tr>
<tr class="memdesc:ad5835797f1567c87a180992a02421cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the specified IP address is the loopback address.  <br /></td></tr>
<tr class="separator:ad5835797f1567c87a180992a02421cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0c1f0a68652df154405f7744da8a11"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#a7e0c1f0a68652df154405f7744da8a11">network_to_host_order</a> (double network)</td></tr>
<tr class="memdesc:a7e0c1f0a68652df154405f7744da8a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Double value from network byte order to host byte order.  <br /></td></tr>
<tr class="separator:a7e0c1f0a68652df154405f7744da8a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde0a480c49a1b537c99551865aaf92d"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#afde0a480c49a1b537c99551865aaf92d">network_to_host_order</a> (float network)</td></tr>
<tr class="memdesc:afde0a480c49a1b537c99551865aaf92d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Single value from network byte order to host byte order.  <br /></td></tr>
<tr class="separator:afde0a480c49a1b537c99551865aaf92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5860bc766c99855c957e7e5320bd7cd7"><td class="memItemLeft" align="right" valign="top">static int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#a5860bc766c99855c957e7e5320bd7cd7">network_to_host_order</a> (int16_t network)</td></tr>
<tr class="memdesc:a5860bc766c99855c957e7e5320bd7cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a short value from network byte order to host byte order.  <br /></td></tr>
<tr class="separator:a5860bc766c99855c957e7e5320bd7cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97731d2852fb7ab59962650fa4b44320"><td class="memItemLeft" align="right" valign="top">static int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#a97731d2852fb7ab59962650fa4b44320">network_to_host_order</a> (int32_t host)</td></tr>
<tr class="memdesc:a97731d2852fb7ab59962650fa4b44320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a integer value from network byte order to host byte order.  <br /></td></tr>
<tr class="separator:a97731d2852fb7ab59962650fa4b44320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2bd573ca1f99922caa41c22f692682"><td class="memItemLeft" align="right" valign="top">static int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#acb2bd573ca1f99922caa41c22f692682">network_to_host_order</a> (int64_t network)</td></tr>
<tr class="memdesc:acb2bd573ca1f99922caa41c22f692682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a long value from network byte order to host byte order.  <br /></td></tr>
<tr class="separator:acb2bd573ca1f99922caa41c22f692682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad758e4bd2b9e0802edb8ff534f719fef"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#ad758e4bd2b9e0802edb8ff534f719fef">network_to_host_order</a> (uint16_t network)</td></tr>
<tr class="memdesc:ad758e4bd2b9e0802edb8ff534f719fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a short value from network byte order to host byte order.  <br /></td></tr>
<tr class="separator:ad758e4bd2b9e0802edb8ff534f719fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c4d4974a0d4fa6627e4ecad0a3f00f"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#ac5c4d4974a0d4fa6627e4ecad0a3f00f">network_to_host_order</a> (uint32_t network)</td></tr>
<tr class="memdesc:ac5c4d4974a0d4fa6627e4ecad0a3f00f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a integer value from network byte order to host byte order.  <br /></td></tr>
<tr class="separator:ac5c4d4974a0d4fa6627e4ecad0a3f00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf1474ccada516e65344bb596ea926f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#gab5833228ed21371660af349c9b1fe797">uint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#aacf1474ccada516e65344bb596ea926f">network_to_host_order</a> (<a class="el" href="group__types.html#gab5833228ed21371660af349c9b1fe797">uint64</a> network)</td></tr>
<tr class="memdesc:aacf1474ccada516e65344bb596ea926f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a long value from network byte order to host byte order.  <br /></td></tr>
<tr class="separator:aacf1474ccada516e65344bb596ea926f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb24c4d707c78902b01687a7c95ec6fd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1net_1_1ip__address.html">ip_address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#adb24c4d707c78902b01687a7c95ec6fd">parse</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str)</td></tr>
<tr class="memdesc:adb24c4d707c78902b01687a7c95ec6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an IP address string to an <a class="el" href="classxtd_1_1net_1_1ip__address.html" title="Provides an Internet Protocol (IP) address.">xtd::net::ip_address</a> instance.  <br /></td></tr>
<tr class="separator:adb24c4d707c78902b01687a7c95ec6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab325cc37dd4150d4904cd21af4b253a9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1net_1_1ip__address.html#ab325cc37dd4150d4904cd21af4b253a9">try_parse</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;str, <a class="el" href="classxtd_1_1net_1_1ip__address.html">ip_address</a> &amp;address)</td></tr>
<tr class="memdesc:ab325cc37dd4150d4904cd21af4b253a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a string is a valid IP address.  <br /></td></tr>
<tr class="separator:ab325cc37dd4150d4904cd21af4b253a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classxtd_1_1object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classxtd_1_1object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classxtd_1_1object.html">xtd::object</a></td></tr>
<tr class="memitem:a75cb9ed56172fb088ca6697d5d836b13 inherit pub_static_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a75cb9ed56172fb088ca6697d5d836b13">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_a, const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a75cb9ed56172fb088ca6697d5d836b13 inherit pub_static_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are considered equal.  <br /></td></tr>
<tr class="separator:a75cb9ed56172fb088ca6697d5d836b13 inherit pub_static_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee13700465eead7934f450749b952d7 inherit pub_static_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a1ee13700465eead7934f450749b952d7">reference_equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_a, const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a1ee13700465eead7934f450749b952d7 inherit pub_static_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are the same instance.  <br /></td></tr>
<tr class="separator:a1ee13700465eead7934f450749b952d7 inherit pub_static_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5cf17e49fc477fe3cf30ddca978c30ac" name="a5cf17e49fc477fe3cf30ddca978c30ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf17e49fc477fe3cf30ddca978c30ac">&#9670;&#160;</a></span>ip_address() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::net::ip_address::ip_address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1net_1_1ip__address.html" title="Provides an Internet Protocol (IP) address.">xtd::net::ip_address</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="classxtd_1_1net_1_1ip__address.html" title="Provides an Internet Protocol (IP) address.">ip_address</a> is initialized by default value <a class="el" href="classxtd_1_1net_1_1ip__address.html#acb6288112f5979aec314ea716836961a" title="Provides an IP address that indicates that no network interface should be used. This field is constan...">xtd::net::ip_address::none</a>. </dd></dl>

</div>
</div>
<a id="aecd1a85a12c8a82d57a750f85b90a014" name="aecd1a85a12c8a82d57a750f85b90a014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecd1a85a12c8a82d57a750f85b90a014">&#9670;&#160;</a></span>ip_address() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::net::ip_address::ip_address </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1net_1_1ip__address.html" title="Provides an Internet Protocol (IP) address.">xtd::net::ip_address</a> class with the address specified as an int64_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The value of the IP address. For example, the value 0x2414188F in big-endian format would be the IP address "143.24.20.36". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ce19db5bef8790f9008dd5868adc7f5" name="a0ce19db5bef8790f9008dd5868adc7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ce19db5bef8790f9008dd5868adc7f5">&#9670;&#160;</a></span>ip_address() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::net::ip_address::ip_address </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1net_1_1ip__address.html" title="Provides an Internet Protocol (IP) address.">xtd::net::ip_address</a> class with the address specified as a byte array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The byte array value of the IP address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47c8a521a38c0d4a85d50c8142c75516" name="a47c8a521a38c0d4a85d50c8142c75516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c8a521a38c0d4a85d50c8142c75516">&#9670;&#160;</a></span>ip_address() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::net::ip_address::ip_address </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>scope_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1net_1_1ip__address.html" title="Provides an Internet Protocol (IP) address.">xtd::net::ip_address</a> class with the address specified as a byte array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The byte array value of the IP address. </td></tr>
    <tr><td class="paramname">scope_id</td><td>The long value of the scope identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>scope_id &lt; 0 or scope_id &gt; 0x00000000FFFFFFFF. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This constructor instantiates an IPv6 address. The scope_dd identifies a network interface in the case of a link-local address. </dd>
<dd>
The scope is valid only for link-local and site-local addresses. </dd>
<dd>
The byte array is assumed to be in network byte order with the most significant byte first in index position 0. </dd></dl>

</div>
</div>
<a id="ad8dcf9f72e20f5be4b083c3ee810fa62" name="ad8dcf9f72e20f5be4b083c3ee810fa62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8dcf9f72e20f5be4b083c3ee810fa62">&#9670;&#160;</a></span>ip_address() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::net::ip_address::ip_address </td>
          <td>(</td>
          <td class="paramtype">byte_t&#160;</td>
          <td class="paramname"><em>quad_part_address1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte_t&#160;</td>
          <td class="paramname"><em>quad_part_address2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte_t&#160;</td>
          <td class="paramname"><em>quad_part_address3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte_t&#160;</td>
          <td class="paramname"><em>quad_part_address4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1net_1_1ip__address.html" title="Provides an Internet Protocol (IP) address.">xtd::net::ip_address</a> class with the address specified as a four Bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quad_part_address1</td><td>The first quad part of the IP address. </td></tr>
    <tr><td class="paramname">quad_part_address2</td><td>The second quad part of the IP address. </td></tr>
    <tr><td class="paramname">quad_part_address3</td><td>The third quad part of the IP address. </td></tr>
    <tr><td class="paramname">quad_part_address4</td><td>The fourth quad part of the IP address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aac71bd917d3323d6eb19483354b07bf5" name="aac71bd917d3323d6eb19483354b07bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac71bd917d3323d6eb19483354b07bf5">&#9670;&#160;</a></span>address_family()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__xtd__core.html#ga5c7a488efbbc9c766286c1485399aef3">sockets::address_family</a> xtd::net::ip_address::address_family </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the address family of the IP address. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <a class="el" href="group__xtd__core.html#gga5c7a488efbbc9c766286c1485399aef3a1f418e7c6026fdaf0077607eedd4ccaa" title="Address for IP version 4.">sockets::address_family::inter_network</a> for IPv4 or <a class="el" href="group__xtd__core.html#gga5c7a488efbbc9c766286c1485399aef3a927e80579d412742c19c0a31fe89369a" title="Address for IP version 6.">sockets::address_family::inter_network_v6</a> for IPv6. </dd></dl>

</div>
</div>
<a id="a3a037b61573882b1da1157216b7e2613" name="a3a037b61573882b1da1157216b7e2613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a037b61573882b1da1157216b7e2613">&#9670;&#160;</a></span>equals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::net::ip_address::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1object.html">object</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the specified object is equal to the current object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object to compare with the current object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the specified object is equal to the current object. otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example compares the current instance with another object. <div class="fragment"></div><!-- fragment --> </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1object.html#a2743b6f75405882c28eebe2456f3837b">xtd::object</a>.</p>

</div>
</div>
<a id="ac9f30bf5c411ba143a7385eb7962d423" name="ac9f30bf5c411ba143a7385eb7962d423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f30bf5c411ba143a7385eb7962d423">&#9670;&#160;</a></span>get_address_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; byte_t &gt; xtd::net::ip_address::get_address_bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides a copy of the IPAddress as an array of bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>A byte array. </dd></dl>

</div>
</div>
<a id="adb7843e3ef7df8ab39e71a4f0cd020d7" name="adb7843e3ef7df8ab39e71a4f0cd020d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7843e3ef7df8ab39e71a4f0cd020d7">&#9670;&#160;</a></span>host_to_network_order() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double xtd::net::ip_address::host_to_network_order </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>host</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a Double value from host byte order to network byte order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The number to convert, expressed in host byte order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Double value, expressed in network byte order. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Different computers use different conventions for ordering the bytes within multibyte integer values.Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order). To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first. </dd>
<dd>
The xtd::net::sockets::socket::host_to_network_order method converts multibyte integer values that are stored on the host system from the byte order used by the host to the byte order used by the network. </dd></dl>

</div>
</div>
<a id="aa88f40e546ba7aa0d1395c5a64b31b58" name="aa88f40e546ba7aa0d1395c5a64b31b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa88f40e546ba7aa0d1395c5a64b31b58">&#9670;&#160;</a></span>host_to_network_order() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float xtd::net::ip_address::host_to_network_order </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>host</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a Single value from host byte order to network byte order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The number to convert, expressed in host byte order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Single value, expressed in network byte order. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Different computers use different conventions for ordering the bytes within multibyte integer values.Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order). To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first. </dd>
<dd>
The xtd::net::sockets::socket::host_to_network_order method converts multibyte integer values that are stored on the host system from the byte order used by the host to the byte order used by the network. </dd></dl>

</div>
</div>
<a id="ac6d3493357113475e915f4981fb327c4" name="ac6d3493357113475e915f4981fb327c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d3493357113475e915f4981fb327c4">&#9670;&#160;</a></span>host_to_network_order() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int16_t xtd::net::ip_address::host_to_network_order </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>host</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a short value from host byte order to network byte order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The number to convert, expressed in host byte order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A short value, expressed in network byte order. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Different computers use different conventions for ordering the bytes within multibyte integer values.Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order). To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first. </dd>
<dd>
The xtd::net::sockets::socket::host_to_network_order method converts multibyte integer values that are stored on the host system from the byte order used by the host to the byte order used by the network. </dd></dl>

</div>
</div>
<a id="a91f677771303bb77180d36e90e68e43d" name="a91f677771303bb77180d36e90e68e43d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f677771303bb77180d36e90e68e43d">&#9670;&#160;</a></span>host_to_network_order() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t xtd::net::ip_address::host_to_network_order </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>host</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a integer value from host byte order to network byte order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The number to convert, expressed in host byte order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A integer value, expressed in network byte order. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Different computers use different conventions for ordering the bytes within multibyte integer values.Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order). To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first. </dd>
<dd>
The xtd::net::sockets::socket::host_to_network_order method converts multibyte integer values that are stored on the host system from the byte order used by the host to the byte order used by the network. </dd></dl>

</div>
</div>
<a id="acea890909455c6531a9d3c4c1161526a" name="acea890909455c6531a9d3c4c1161526a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea890909455c6531a9d3c4c1161526a">&#9670;&#160;</a></span>host_to_network_order() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int64_t xtd::net::ip_address::host_to_network_order </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>host</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a long value from host byte order to network byte order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The number to convert, expressed in host byte order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A long value, expressed in network byte order. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Different computers use different conventions for ordering the bytes within multibyte integer values.Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order). To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first. </dd>
<dd>
The xtd::net::sockets::socket::host_to_network_order method converts multibyte integer values that are stored on the host system from the byte order used by the host to the byte order used by the network. </dd></dl>

</div>
</div>
<a id="abefdd9b886845080c8f48726f188c22a" name="abefdd9b886845080c8f48726f188c22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abefdd9b886845080c8f48726f188c22a">&#9670;&#160;</a></span>host_to_network_order() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t xtd::net::ip_address::host_to_network_order </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>host</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a short value from host byte order to network byte order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The number to convert, expressed in host byte order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unsigned short value, expressed in network byte order. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Different computers use different conventions for ordering the bytes within multibyte integer values.Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order). To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first. </dd>
<dd>
The xtd::net::sockets::socket::host_to_network_order method converts multibyte integer values that are stored on the host system from the byte order used by the host to the byte order used by the network. </dd></dl>

</div>
</div>
<a id="a3cef1adfde0b3aa7a8e523e796d8c1c6" name="a3cef1adfde0b3aa7a8e523e796d8c1c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cef1adfde0b3aa7a8e523e796d8c1c6">&#9670;&#160;</a></span>host_to_network_order() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t xtd::net::ip_address::host_to_network_order </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>host</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a integer value from host byte order to network byte order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The number to convert, expressed in host byte order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unsigned integer value, expressed in network byte order. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Different computers use different conventions for ordering the bytes within multibyte integer values.Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order). To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first. </dd>
<dd>
The xtd::net::sockets::socket::host_to_network_order method converts multibyte integer values that are stored on the host system from the byte order used by the host to the byte order used by the network. </dd></dl>

</div>
</div>
<a id="af80e940a192f5477b368e42aa3876a9c" name="af80e940a192f5477b368e42aa3876a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80e940a192f5477b368e42aa3876a9c">&#9670;&#160;</a></span>host_to_network_order() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t xtd::net::ip_address::host_to_network_order </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>host</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a long value from host byte order to network byte order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The number to convert, expressed in host byte order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unsigned long value, expressed in network byte order. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Different computers use different conventions for ordering the bytes within multibyte integer values.Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order). To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first. </dd>
<dd>
The xtd::net::sockets::socket::host_to_network_order method converts multibyte integer values that are stored on the host system from the byte order used by the host to the byte order used by the network. </dd></dl>

</div>
</div>
<a id="af612d35827ddd1cab111165226c1c38c" name="af612d35827ddd1cab111165226c1c38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af612d35827ddd1cab111165226c1c38c">&#9670;&#160;</a></span>is_ip_v4_mapped_to_ip_v6()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::net::ip_address::is_ip_v4_mapped_to_ip_v6 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether the IP address is an IPv4-mapped IPv6 address. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the IP address is an IPv4-mapped IPv6 address; otherwise, false. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Dual-stack sockets always require IPv6 addresses. The ability to interact with an IPv4 address requires the use of the IPv4-mapped IPv6 address format. Any IPv4 addresses must be represented in the IPv4-mapped IPv6 address format which enables an IPv6 only application to communicate with an IPv4 node. The IPv4-mapped IPv6 address format allows the IPv4 address of an IPv4 node to be represented as an IPv6 address. The IPv4 address is encoded into the low-order 32 bits of the IPv6 address, and the high-order 96 bits hold the fixed prefix 0:0:0:0:0:FFFF. The IPv4-mapped IPv6 address format is specified in RFC 4291. For more information, see www.ietf.org/rfc/rfc4291.txt. </dd></dl>

</div>
</div>
<a id="a8f5d7c5d30ef7c4e9dbfa9409d7a7bf3" name="a8f5d7c5d30ef7c4e9dbfa9409d7a7bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5d7c5d30ef7c4e9dbfa9409d7a7bf3">&#9670;&#160;</a></span>is_ip_v6_link_local()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::net::ip_address::is_ip_v6_link_local </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether the address is an IPv6 link local address. </p>
<dl class="section return"><dt>Returns</dt><dd>bool true if the IP address is an IPv6 link local address; otherwise, false. </dd></dl>

</div>
</div>
<a id="a9eee0ed2d8aabaf44ea53316f168a5a3" name="a9eee0ed2d8aabaf44ea53316f168a5a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eee0ed2d8aabaf44ea53316f168a5a3">&#9670;&#160;</a></span>is_ip_v6_multicast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::net::ip_address::is_ip_v6_multicast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether the address is an IPv6 multicast global address. </p>
<dl class="section return"><dt>Returns</dt><dd>bool true if the IP address is an IPv6 multicast global address; otherwise, false. </dd></dl>

</div>
</div>
<a id="aff921c3a571077951246ef3dd5c59e99" name="aff921c3a571077951246ef3dd5c59e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff921c3a571077951246ef3dd5c59e99">&#9670;&#160;</a></span>is_ip_v6_site_local()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::net::ip_address::is_ip_v6_site_local </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether the address is an IPv6 site local address. </p>
<dl class="section return"><dt>Returns</dt><dd>bool true if the IP address is an IPv6 site local address; otherwise, false. </dd></dl>

</div>
</div>
<a id="a244eb15fc215fca6488aa2118111dc1a" name="a244eb15fc215fca6488aa2118111dc1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244eb15fc215fca6488aa2118111dc1a">&#9670;&#160;</a></span>is_ip_v6_teredo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::net::ip_address::is_ip_v6_teredo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether the address is an IPv6 Teredo address. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the IP address is an IPv6 Teredo address; otherwise, false. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>A Teredo address is an IPv6 address with the prefix of 2001::/32. Teredo addresses can be returned through normal DNS name resolution or enumerated as an IPv6 address assigned to a local interface. </dd></dl>

</div>
</div>
<a id="ad5835797f1567c87a180992a02421cf7" name="ad5835797f1567c87a180992a02421cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5835797f1567c87a180992a02421cf7">&#9670;&#160;</a></span>is_loopback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::net::ip_address::is_loopback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1net_1_1ip__address.html">ip_address</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the specified IP address is the loopback address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>An IP address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if address is the loopback address; otherwise, false. </dd></dl>

</div>
</div>
<a id="ae11920203958cff3746c7d17f6fe988d" name="ae11920203958cff3746c7d17f6fe988d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11920203958cff3746c7d17f6fe988d">&#9670;&#160;</a></span>map_to_ip_v4()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1net_1_1ip__address.html">ip_address</a> xtd::net::ip_address::map_to_ip_v4 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps the <a class="el" href="classxtd_1_1net_1_1ip__address.html" title="Provides an Internet Protocol (IP) address.">xtd::net::ip_address</a> object to an IPv4 address. </p>
<dl class="section return"><dt>Returns</dt><dd>An IPv4 address. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Dual-stack sockets always require IPv6 addresses. The ability to interact with an IPv4 address requires the use of the IPv4-mapped IPv6 address format. Any IPv4 addresses must be represented in the IPv4-mapped IPv6 address format which enables an IPv6 only application to communicate with an IPv4 node. The IPv4-mapped IPv6 address format allows the IPv4 address of an IPv4 node to be represented as an IPv6 address. The IPv4 address is encoded into the low-order 32 bits of the IPv6 address, and the high-order 96 bits hold the fixed prefix 0:0:0:0:0:FFFF. The IPv4-mapped IPv6 address format is specified in RFC 4291. For more information, see www.ietf.org/rfc/rfc4291.txt. </dd></dl>

</div>
</div>
<a id="ae59f8b5a2d22acba13172a18f5cf553d" name="ae59f8b5a2d22acba13172a18f5cf553d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae59f8b5a2d22acba13172a18f5cf553d">&#9670;&#160;</a></span>map_to_ip_v6()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1net_1_1ip__address.html">ip_address</a> xtd::net::ip_address::map_to_ip_v6 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps the <a class="el" href="classxtd_1_1net_1_1ip__address.html" title="Provides an Internet Protocol (IP) address.">xtd::net::ip_address</a> object to an IPv6 address. </p>
<dl class="section return"><dt>Returns</dt><dd>An IPv6 address. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Dual-stack sockets always require IPv6 addresses. The ability to interact with an IPv4 address requires the use of the IPv4-mapped IPv6 address format. Any IPv4 addresses must be represented in the IPv4-mapped IPv6 address format which enables an IPv6 only application to communicate with an IPv4 node. The IPv4-mapped IPv6 address format allows the IPv4 address of an IPv4 node to be represented as an IPv6 address. The IPv4 address is encoded into the low-order 32 bits of the IPv6 address, and the high-order 96 bits hold the fixed prefix 0:0:0:0:0:FFFF. The IPv4-mapped IPv6 address format is specified in RFC 4291. For more information, see www.ietf.org/rfc/rfc4291.txt. </dd></dl>

</div>
</div>
<a id="a7e0c1f0a68652df154405f7744da8a11" name="a7e0c1f0a68652df154405f7744da8a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0c1f0a68652df154405f7744da8a11">&#9670;&#160;</a></span>network_to_host_order() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double xtd::net::ip_address::network_to_host_order </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>network</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a Double value from network byte order to host byte order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">network</td><td>The number to convert, expressed in network byte order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Double value, expressed in host byte order. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Different computers use different conventions for ordering the bytes within multibyte integer values. Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order). To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first. </dd>
<dd>
The xtd::net::sockets::socket::network_to_host_order method converts multibyte integer values that are stored on the host system from the byte order used by the network to the byte order used by the host. </dd></dl>

</div>
</div>
<a id="afde0a480c49a1b537c99551865aaf92d" name="afde0a480c49a1b537c99551865aaf92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde0a480c49a1b537c99551865aaf92d">&#9670;&#160;</a></span>network_to_host_order() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float xtd::net::ip_address::network_to_host_order </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>network</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a Single value from network byte order to host byte order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">network</td><td>The number to convert, expressed in host byte order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Single value, expressed in host byte order. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Different computers use different conventions for ordering the bytes within multibyte integer values. Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order). To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first. </dd>
<dd>
The xtd::net::sockets::socket::network_to_host_order method converts multibyte integer values that are stored on the host system from the byte order used by the network to the byte order used by the host. </dd></dl>

</div>
</div>
<a id="a5860bc766c99855c957e7e5320bd7cd7" name="a5860bc766c99855c957e7e5320bd7cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5860bc766c99855c957e7e5320bd7cd7">&#9670;&#160;</a></span>network_to_host_order() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int16_t xtd::net::ip_address::network_to_host_order </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>network</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a short value from network byte order to host byte order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">network</td><td>The number to convert, expressed in network byte order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A short value, expressed in host byte order. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Different computers use different conventions for ordering the bytes within multibyte integer values. Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order). To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first. </dd>
<dd>
The xtd::net::sockets::socket::network_to_host_order method converts multibyte integer values that are stored on the host system from the byte order used by the network to the byte order used by the host. </dd></dl>

</div>
</div>
<a id="a97731d2852fb7ab59962650fa4b44320" name="a97731d2852fb7ab59962650fa4b44320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97731d2852fb7ab59962650fa4b44320">&#9670;&#160;</a></span>network_to_host_order() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t xtd::net::ip_address::network_to_host_order </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>host</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a integer value from network byte order to host byte order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The number to convert, expressed in network byte order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A integer value, expressed in host byte order. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Different computers use different conventions for ordering the bytes within multibyte integer values. Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order). To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first. </dd>
<dd>
The xtd::net::sockets::socket::network_to_host_order method converts multibyte integer values that are stored on the host system from the byte order used by the network to the byte order used by the host. </dd></dl>

</div>
</div>
<a id="acb2bd573ca1f99922caa41c22f692682" name="acb2bd573ca1f99922caa41c22f692682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2bd573ca1f99922caa41c22f692682">&#9670;&#160;</a></span>network_to_host_order() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int64_t xtd::net::ip_address::network_to_host_order </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>network</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a long value from network byte order to host byte order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">network</td><td>The number to convert, expressed in network byte order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A long value, expressed in host byte order. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Different computers use different conventions for ordering the bytes within multibyte integer values. Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order). To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first. </dd>
<dd>
The xtd::net::sockets::socket::network_to_host_order method converts multibyte integer values that are stored on the host system from the byte order used by the network to the byte order used by the host. </dd></dl>

</div>
</div>
<a id="ad758e4bd2b9e0802edb8ff534f719fef" name="ad758e4bd2b9e0802edb8ff534f719fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad758e4bd2b9e0802edb8ff534f719fef">&#9670;&#160;</a></span>network_to_host_order() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t xtd::net::ip_address::network_to_host_order </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>network</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a short value from network byte order to host byte order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">network</td><td>The number to convert, expressed in network byte order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unsigned short value, expressed in host byte order. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Different computers use different conventions for ordering the bytes within multibyte integer values. Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order). To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first. </dd>
<dd>
The xtd::net::sockets::socket::network_to_host_order method converts multibyte integer values that are stored on the host system from the byte order used by the network to the byte order used by the host. </dd></dl>

</div>
</div>
<a id="ac5c4d4974a0d4fa6627e4ecad0a3f00f" name="ac5c4d4974a0d4fa6627e4ecad0a3f00f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c4d4974a0d4fa6627e4ecad0a3f00f">&#9670;&#160;</a></span>network_to_host_order() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t xtd::net::ip_address::network_to_host_order </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>network</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a integer value from network byte order to host byte order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">network</td><td>The number to convert, expressed in network byte order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unsigned integer value, expressed in host byte order. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Different computers use different conventions for ordering the bytes within multibyte integer values. Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order). To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first. </dd>
<dd>
The xtd::net::sockets::socket::network_to_host_order method converts multibyte integer values that are stored on the host system from the byte order used by the network to the byte order used by the host. </dd></dl>

</div>
</div>
<a id="aacf1474ccada516e65344bb596ea926f" name="aacf1474ccada516e65344bb596ea926f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf1474ccada516e65344bb596ea926f">&#9670;&#160;</a></span>network_to_host_order() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#gab5833228ed21371660af349c9b1fe797">uint64</a> xtd::net::ip_address::network_to_host_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#gab5833228ed21371660af349c9b1fe797">uint64</a>&#160;</td>
          <td class="paramname"><em>network</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a long value from network byte order to host byte order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">network</td><td>The number to convert, expressed in network byte order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unsigned long value, expressed in host byte order. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Different computers use different conventions for ordering the bytes within multibyte integer values. Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order). To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first. </dd>
<dd>
The xtd::net::sockets::socket::network_to_host_order method converts multibyte integer values that are stored on the host system from the byte order used by the network to the byte order used by the host. </dd></dl>

</div>
</div>
<a id="adb24c4d707c78902b01687a7c95ec6fd" name="adb24c4d707c78902b01687a7c95ec6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb24c4d707c78902b01687a7c95ec6fd">&#9670;&#160;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1net_1_1ip__address.html">ip_address</a> xtd::net::ip_address::parse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an IP address string to an <a class="el" href="classxtd_1_1net_1_1ip__address.html" title="Provides an Internet Protocol (IP) address.">xtd::net::ip_address</a> instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>A string that contains an IP address in dotted-quad notation for IPv4 and in colon-hexadecimal notation for IPv6. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1net_1_1ip__address.html" title="Provides an Internet Protocol (IP) address.">xtd::net::ip_address</a> instance. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1format__exception.html" title="The exception that is thrown when the format of an argument does not meet the parameter specification...">xtd::format_exception</a></td><td>str is not a valid IP address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The static <a class="el" href="classxtd_1_1net_1_1ip__address.html#adb24c4d707c78902b01687a7c95ec6fd" title="Converts an IP address string to an xtd::net::ip_address instance.">xtd::net::ip_address::parse</a> method creates an <a class="el" href="classxtd_1_1net_1_1ip__address.html" title="Provides an Internet Protocol (IP) address.">xtd::net::ip_address</a> instance from an IP address expressed in dotted-quad notation for IPv4 and in colon-hexadecimal notation for IPv6. </dd>
<dd>
The number of parts (each part is separated by a period) in str determines how the IP address is constructed. A one part address is stored directly in the network address. A two part address, convenient for specifying a class A address, puts the leading part in the first byte and the trailing part in the right-most three bytes of the network address. A three part address, convenient for specifying a class B address, puts the first part in the first byte, the second part in the second byte, and the final part in the right-most two bytes of the network address. </dd></dl>

</div>
</div>
<a id="a5530d86e599758767cf87067e2e73f9f" name="a5530d86e599758767cf87067e2e73f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5530d86e599758767cf87067e2e73f9f">&#9670;&#160;</a></span>scope_id() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t xtd::net::ip_address::scope_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the IPv6 address scope identifier. </p>
<dl class="section return"><dt>Returns</dt><dd>A uint32_t that specifies the scope of the address. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__exception.html" title="The exception that is thrown when a socket error occurs.">xtd::net::sockets::socket_exception</a></td><td>if address_family = <a class="el" href="group__xtd__core.html#gga5c7a488efbbc9c766286c1485399aef3a1f418e7c6026fdaf0077607eedd4ccaa" title="Address for IP version 4.">sockets::address_family::inter_network</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aded48f1d69d6d163e6aa68701d1c89be" name="aded48f1d69d6d163e6aa68701d1c89be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aded48f1d69d6d163e6aa68701d1c89be">&#9670;&#160;</a></span>scope_id() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1net_1_1ip__address.html">ip_address</a> &amp; xtd::net::ip_address::scope_id </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the IPv6 address scope identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A uint32_t that specifies the scope of the address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__exception.html" title="The exception that is thrown when a socket error occurs.">xtd::net::sockets::socket_exception</a></td><td>if address_family = <a class="el" href="group__xtd__core.html#gga5c7a488efbbc9c766286c1485399aef3a1f418e7c6026fdaf0077607eedd4ccaa" title="Address for IP version 4.">sockets::address_family::inter_network</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2ae0bff8c72f67a47c1122465204650" name="ae2ae0bff8c72f67a47c1122465204650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ae0bff8c72f67a47c1122465204650">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::net::ip_address::to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an Internet address to its standard notation. </p>
<dl class="section return"><dt>Returns</dt><dd>A string that contains the IP address in either IPv4 dotted-quad or in IPv6 colon-hexadecimal notation. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1object.html#a5682215ee76ab97c48580ab162c49507">xtd::object</a>.</p>

</div>
</div>
<a id="ab325cc37dd4150d4904cd21af4b253a9" name="ab325cc37dd4150d4904cd21af4b253a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab325cc37dd4150d4904cd21af4b253a9">&#9670;&#160;</a></span>try_parse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::net::ip_address::try_parse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1net_1_1ip__address.html">ip_address</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether a string is a valid IP address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to validate. </td></tr>
    <tr><td class="paramname">address</td><td>The <a class="el" href="classxtd_1_1net_1_1ip__address.html" title="Provides an Internet Protocol (IP) address.">xtd::net::ip_address</a> version of the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if str is a valid IP address; otherwise, false. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7c9f9e74d8b2b7c4e003f20736cb3d7a" name="a7c9f9e74d8b2b7c4e003f20736cb3d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9f9e74d8b2b7c4e003f20736cb3d7a">&#9670;&#160;</a></span>any</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1net_1_1ip__address.html">ip_address</a> xtd::net::ip_address::any</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides an IP address that indicates that the server must listen for client activity on all network interfaces. This field is constant. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The td::net::ip_address::any field is equivalent to 0.0.0.0 in dotted-quad notation </dd></dl>

</div>
</div>
<a id="a08d8d0f4440ac8cf10403534c9b2e0c6" name="a08d8d0f4440ac8cf10403534c9b2e0c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08d8d0f4440ac8cf10403534c9b2e0c6">&#9670;&#160;</a></span>broadcast</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1net_1_1ip__address.html">ip_address</a> xtd::net::ip_address::broadcast</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides the IP broadcast address. This field is constant. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The td::net::ip_address::broadcast field is equivalent to 255.255.255.255 in dotted-quad notation. </dd></dl>

</div>
</div>
<a id="a09ad2c7df265c44764e325d02df1895e" name="a09ad2c7df265c44764e325d02df1895e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ad2c7df265c44764e325d02df1895e">&#9670;&#160;</a></span>ip_v6_any</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1net_1_1ip__address.html">ip_address</a> xtd::net::ip_address::ip_v6_any</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Socket::Bind method uses the cIPv6Any field to indicate that a Socket must listen for client activity on all network interfaces. This field is constant. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The td::net::ip_address::ip_v6_any field is equivalent to 0:0:0:0:0:0:0:0 in colon-hexadecimal notation, or to :: in compact notation. </dd></dl>

</div>
</div>
<a id="aec19e1f22b8910e852dce40a4c6caf60" name="aec19e1f22b8910e852dce40a4c6caf60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec19e1f22b8910e852dce40a4c6caf60">&#9670;&#160;</a></span>ip_v6_loopback</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1net_1_1ip__address.html">ip_address</a> xtd::net::ip_address::ip_v6_loopback</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides the IP loopback address. This field is constant. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The td::net::ip_address::ip_v6_loopback field is equivalent to 0:0:0:0:0:0:0:1 in colon-hexadecimal notation, or to ::1 in compact notation. </dd></dl>

</div>
</div>
<a id="a0e65be30fda89784598cf8292360a25a" name="a0e65be30fda89784598cf8292360a25a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e65be30fda89784598cf8292360a25a">&#9670;&#160;</a></span>ip_v6_none</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1net_1_1ip__address.html">ip_address</a> xtd::net::ip_address::ip_v6_none</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides an IP address that indicates that no network interface should be used. This field is constant. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The Socket::Bind method uses the cIPv6None field to indicate that a Socket must not listen for client activity. </dd>
<dd>
The td::net::ip_address::ip_v6_none field is equivalent to 0:0:0:0:0:0:0:0 in colon-hexadecimal notation, or to ::0 in compact notation. </dd></dl>

</div>
</div>
<a id="af97ec37d5ae5e391246dc8f19afaa626" name="af97ec37d5ae5e391246dc8f19afaa626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97ec37d5ae5e391246dc8f19afaa626">&#9670;&#160;</a></span>loopback</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1net_1_1ip__address.html">ip_address</a> xtd::net::ip_address::loopback</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides the IP loopback address. This field is constant. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The td::net::ip_address::loopback field is equivalent to 127.0.0.1 in dotted-quad notation. </dd></dl>

</div>
</div>
<a id="acb6288112f5979aec314ea716836961a" name="acb6288112f5979aec314ea716836961a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb6288112f5979aec314ea716836961a">&#9670;&#160;</a></span>none</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1net_1_1ip__address.html">ip_address</a> xtd::net::ip_address::none</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides an IP address that indicates that no network interface should be used. This field is constant. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The td::net::ip_address::none field is equivalent to 255.255.255.255 in dotted-quad notation. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/net/<a class="el" href="ip__address_8h_source.html">ip_address.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 12 2024 16:25:12 for xtd - Reference Guide by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
