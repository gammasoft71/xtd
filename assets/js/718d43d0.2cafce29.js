"use strict";(self.webpackChunkxtd=self.webpackChunkxtd||[]).push([[5887],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>c});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),d=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(o.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=d(n),c=r,g=u["".concat(o,".").concat(c)]||u[c]||m[c]||i;return n?a.createElement(g,s(s({ref:t},p),{},{components:n})):a.createElement(g,s({ref:t},p))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=u;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l.mdxType="string"==typeof e?e:r,s[1]=l;for(var d=2;d<i;d++)s[d]=n[d];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},97147:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>s,default:()=>m,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var a=n(87462),r=(n(67294),n(3905));const i={},s="Names of Classes, Structs and Interfaces",l={unversionedId:"documentation/Design Guidelines/Naming Guidelines/names_of_classes_structs_and_interfaces",id:"documentation/Design Guidelines/Naming Guidelines/names_of_classes_structs_and_interfaces",title:"Names of Classes, Structs and Interfaces",description:"The naming guidelines that follow apply to general type naming.",source:"@site/docs/documentation/Design Guidelines/Naming Guidelines/names_of_classes_structs_and_interfaces.md",sourceDirName:"documentation/Design Guidelines/Naming Guidelines",slug:"/documentation/Design Guidelines/Naming Guidelines/names_of_classes_structs_and_interfaces",permalink:"/xtd/docs/documentation/Design Guidelines/Naming Guidelines/names_of_classes_structs_and_interfaces",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"General Naming Conventions",permalink:"/xtd/docs/documentation/Design Guidelines/Naming Guidelines/general_naming_conventions"},next:{title:"Names of Libraries and DLLs",permalink:"/xtd/docs/documentation/Design Guidelines/Naming Guidelines/names_of_libraries_and_dlls"}},o={},d=[{value:"Names of Generic Type Parameters",id:"names-of-generic-type-parameters",level:2},{value:"Names of Common Types",id:"names-of-common-types",level:2},{value:"Naming Enumerations",id:"naming-enumerations",level:2}],p={toc:d};function m(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"names-of-classes-structs-and-interfaces"},"Names of Classes, Structs and Interfaces"),(0,r.kt)("p",null,"The naming guidelines that follow apply to general type naming."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," name classes and structs with nouns or noun phrases, using snake_casing."),(0,r.kt)("p",null,"This distinguishes type names from methods, which are named with verb phrases."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," name interfaces with adjective phrases, or occasionally with nouns or noun phrases."),(0,r.kt)("p",null,"Nouns and noun phrases should be used rarely and they might indicate that the type should be an abstract class, and not an interface."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u274c DO NOT"),' give class names a prefix (e.g., "C", "c").'),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f CONSIDER")," ending the name of derived classes with the name of the base class."),(0,r.kt)("p",null,"This is very readable and explains the relationship clearly. Some examples of this in code are: argument_out_of_range_exception, which is a kind of exception, and serializable_attribute, which is a kind of attribute. However, it is important to use reasonable judgment in applying this guideline; for example, the button class is a kind of control event, although control doesn't appear in its name."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO"),' prefix interface names with the letter "i", to indicate that the type is an interface.'),(0,r.kt)("p",null,"For example, icomponent (descriptive noun), icustom_attribute_provider (noun phrase), and ipersistable (adjective) are appropriate interface names. As with other type names, avoid abbreviations."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO"),' ensure that the names differ only by the "i" prefix on the interface name when you are defining a class\u2013interface pair where the class is a standard implementation of the interface.'),(0,r.kt)("h2",{id:"names-of-generic-type-parameters"},"Names of Generic Type Parameters"),(0,r.kt)("p",null,"Generics (template) has identifier called type parameter."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," name generic type parameters with descriptive names unless a single-letter name is completely self-explanatory and a descriptive name would not add value."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f CONSIDER")," using type_t as the type parameter name for types with generic type parameter."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename type_t>\nclass predicate : public deletegate<bool(type_t)> {\n  ...\n};\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename type_t = object>\nstruct nullable : public type_t {\n  ...\n};\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," postfix descriptive type parameter names with _t."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename session_t = isession>\nclass isession_channel interface_ {\n  virtual session_t get_session() = 0;\n};\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f CONSIDER")," indicating constraints placed on a type parameter in the name of the parameter."),(0,r.kt)("p",null,"For example, a parameter constrained to isession might be called session_t."),(0,r.kt)("h2",{id:"names-of-common-types"},"Names of Common Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," follow the guidelines described in the following table when naming types derived from or implementing certain xtd Framework types."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Base Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Derived/Implementing Type Guideline"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"xtd::delegate"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"\u2714\ufe0f DO"),' add the suffix "_event_handler" to names of delegates that are used in events.')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"xtd::delegate"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"\u2714\ufe0f DO"),' add the suffix "_callback" to names of delegates other than those used as event handlers.')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"xtd::delegate"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"\u274c DO NOT"),' add the suffix "_delegate" to a delegate.')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"xtd::event_args"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"\u2714\ufe0f DO"),' add the suffix "_event_args".')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"xtd::event_handler"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"\u2714\ufe0f DO"),' add the suffix "_event_handler".')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"enum class"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"\u274c DO NOT"),' add the suffix "_enum" or "_flag".')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"\xa0xtd::system_exception"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"\u2714\ufe0f DO"),' add the suffix "_exception".')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"std::array"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"\u2714\ufe0f DO"),' add the suffix "_collection" for sequence container.')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"std::vector"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"\u2714\ufe0f DO"),' add the suffix "_collection" for sequence container.')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"std::deque"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"\u2714\ufe0f DO"),' add the suffix "_collection" for sequence container.')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"std::forward_list"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"\u2714\ufe0f DO"),' add the suffix "_collection" for sequence container.')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"std::list"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"\u2714\ufe0f DO"),' add the suffix "_collection" for sequence container.')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"std::set"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"\u2714\ufe0f DO"),' add the suffix "_dictionary" for associative container.')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"std::multiset"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"\u2714\ufe0f DO"),' add the suffix "_dictionary" for associative container.')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"std::map"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"\u2714\ufe0f DO"),' add the suffix "_dictionary" for associative container.')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"std::multimap"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"\u2714\ufe0f DO"),' add the suffix "_dictionary" for associative container.')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"std::unordered_set"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"\u2714\ufe0f DO"),' add the suffix "_dictionary" for unordered associative container.')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"std::unordered_multiset"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"\u2714\ufe0f DO"),' add the suffix "_dictionary" for unordered associative container.')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"std::unordered_map"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"\u2714\ufe0f DO"),' add the suffix "_dictionary" for unordered associative container.')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"std::unordered_multimap"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"\u2714\ufe0f DO"),' add the suffix "_dictionary" for unordered associative container.')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"std::span"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"\u2714\ufe0f DO"),' add the suffix "_span".')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"std::istream"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"\u2714\ufe0f DO"),' add the suffix "_stream".')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"std::ostream"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"\u2714\ufe0f DO"),' add the suffix "_stream".')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"std::iostream"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"\u2714\ufe0f DO"),' add the suffix "_stream".')))),(0,r.kt)("h2",{id:"naming-enumerations"},"Naming Enumerations"),(0,r.kt)("p",null,"Names of enumeration types (also called enums) in general should follow the standard type-naming rules (snake_casing, etc.). However, there are additional guidelines that apply specifically to enums."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," use a singular type name for an enumeration unless its values are bit fields."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," use a plural type name for an enumeration with bit fields as values, also called flags enum."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u274c DO NOT"),' use an "_enum" suffix in enum type names.'),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u274c DO NOT"),' use "_flag" or "_flags" suffixes in enum type names.'),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u274c DO NOT"),' use a prefix on enumeration value names (e.g., "ad" for ADO enums, "rtf" for rich text enums, etc.).'),(0,r.kt)("h1",{id:"see-also"},"See also"),(0,r.kt)("p",null,"\u200b"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/documentation/Design%20Guidelines/Naming%20Guidelines"},"Naming Guidelines")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/documentation/Design%20Guidelines"},"Design Guidelines")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/documentation"},"Documentation"))))}m.isMDXComponent=!0}}]);