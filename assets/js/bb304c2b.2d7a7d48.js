"use strict";(self.webpackChunkxtd=self.webpackChunkxtd||[]).push([[4633],{91971:(e,t,r)=>{r.d(t,{Zo:()=>c,kt:()=>f});var n=r(76687);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var l=n.createContext({}),m=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},c=function(e){var t=m(e.components);return n.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=m(r),p=o,f=u["".concat(l,".").concat(p)]||u[p]||d[p]||a;return r?n.createElement(f,i(i({ref:t},c),{},{components:r})):n.createElement(f,i({ref:t},c))}));function f(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:o,i[1]=s;for(var m=2;m<a;m++)i[m]=r[m];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}p.displayName="MDXCreateElement"},34465:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>m});var n=r(855),o=(r(76687),r(91971));const a={},i="Overview: How to format numbers, dates, enums, and other types in xtd",s={unversionedId:"documentation/Guides/xtd.core/Format number dates other types/overview",id:"documentation/Guides/xtd.core/Format number dates other types/overview",title:"Overview: How to format numbers, dates, enums, and other types in xtd",description:"Formatting is the process of converting an instance of a class or structure, or an enumeration value, to a string representation.",source:"@site/docs/documentation/Guides/xtd.core/Format number dates other types/overview.md",sourceDirName:"documentation/Guides/xtd.core/Format number dates other types",slug:"/documentation/Guides/xtd.core/Format number dates other types/overview",permalink:"/xtd/docs/documentation/Guides/xtd.core/Format number dates other types/overview",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Enumeration format strings",permalink:"/xtd/docs/documentation/Guides/xtd.core/Format number dates other types/enumeration_format_strings"},next:{title:"Standard date and time format strings",permalink:"/xtd/docs/documentation/Guides/xtd.core/Format number dates other types/standard_date_and_time_format_strings"}},l={},m=[{value:"Notes",id:"notes",level:2}],c={toc:m},u="wrapper";function d(e){let{components:t,...r}=e;return(0,o.kt)(u,(0,n.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"overview-how-to-format-numbers-dates-enums-and-other-types-in-xtd"},"Overview: How to format numbers, dates, enums, and other types in xtd"),(0,o.kt)("p",null,"Formatting is the process of converting an instance of a class or structure, or an enumeration value, to a string representation.\nThe purpose is to display the resulting string to users or to deserialize it later to restore the original data type.\nThis article introduces the formatting mechanisms that xtd provides."),(0,o.kt)("h2",{id:"notes"},"Notes"),(0,o.kt)("p",null,"  Parsing is the inverse of formatting.\nA parsing operation creates an instance of a data type from its string representation.\nFor more information, see ",(0,o.kt)("a",{parentName:"p",href:"/docs/documentation/Guides/xtd.core/Parse/overview"},"Parsing Strings"),". "),(0,o.kt)("p",null,"The basic mechanism for formatting is the default implementation of the ",(0,o.kt)("a",{parentName:"p",href:"https://gammasoft71.github.io/xtd/reference_guides/latest/classxtd_1_1object.html#a5682215ee76ab97c48580ab162c49507"},"xtd::object::to_string")," method, which is discussed in the ",(0,o.kt)("a",{parentName:"p",href:"#default-formatting-using-the-to-strin-method"},"Default Formatting Using the to_string Method")," section later in this topic.\nHowever, xtd provides several ways to modify and extend its default formatting support.\nThese include the following:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Overriding the ",(0,o.kt)("a",{parentName:"li",href:"https://gammasoft71.github.io/xtd/reference_guides/latest/classxtd_1_1object.html#a5682215ee76ab97c48580ab162c49507"},"xtd::object::to_string")," method to define a custom string representation of an object's value. For more information, see the ",(0,o.kt)("a",{parentName:"li",href:"#override-the-to-string-method"},"Override the to_string Method")," section later in this topic."),(0,o.kt)("li",{parentName:"ul"},'Defining format specifiers that enable the string representation of an object\'s value to take multiple forms. For example, the "X" format specifier in the following statement converts an integer to the string representation of a hexadecimal value.')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'int integer_value = 60312;\nxtd::console::write_line(xtd::to_string(integer_value, "X"));   // Displays EB98.\n')),(0,o.kt)("p",null,"For more information about format specifiers, see the ",(0,o.kt)("a",{parentName:"p",href:"#to_string-method-and-format-strings"},"to_string Method and Format Strings")," section."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Using format providers to implement the formatting conventions of a specific culture. For example, the following statement displays a currency value by using the formatting conventions of the en-US culture.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'double cost = 1632.54;\nxtd::console::write_line(xtd::to_string(cost, "C", std::locale("en_US.UTF-8")));\n// The example displays the following output:\n//\n// $1,632.54\n')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Implementing the IFormattable interface to support both string conversion with the Convert class and composite formatting. For more information, see the IFormattable Interface section."),(0,o.kt)("li",{parentName:"ul"},"Using composite formatting to embed the string representation of a value in a larger string. For more information, see the Composite Formatting section."),(0,o.kt)("li",{parentName:"ul"},"Using string interpolation, a more readable syntax to embed the string representation of a value in a larger string. For more information, see String interpolation."),(0,o.kt)("li",{parentName:"ul"},"Implementing ICustomFormatter and IFormatProvider to provide a complete custom formatting solution. For more information, see the Custom Formatting with ICustomFormatter section.")),(0,o.kt)("p",null,"The following sections examine these methods for converting an object to its string representation."),(0,o.kt)("h1",{id:"see-also"},"See also"),(0,o.kt)("p",null,"\u200b"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/docs/documentation/Guides"},"Guides")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/docs/documentation"},"Documentation"))))}d.isMDXComponent=!0}}]);