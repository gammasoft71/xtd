"use strict";(self.webpackChunkxtd=self.webpackChunkxtd||[]).push([[3693],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>y});var s=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,s)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,s,i=function(e,t){if(null==e)return{};var n,s,i={},a=Object.keys(e);for(s=0;s<a.length;s++)n=a[s],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(s=0;s<a.length;s++)n=a[s],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=s.createContext({}),p=function(e){var t=s.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=p(e.components);return s.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return s.createElement(s.Fragment,{},t)}},u=s.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),u=p(n),y=i,h=u["".concat(l,".").concat(y)]||u[y]||c[y]||a;return n?s.createElement(h,r(r({ref:t},d),{},{components:n})):s.createElement(h,r({ref:t},d))}));function y(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,r=new Array(a);r[0]=u;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:i,r[1]=o;for(var p=2;p<a;p++)r[p]=n[p];return s.createElement.apply(null,r)}return s.createElement.apply(null,n)}u.displayName="MDXCreateElement"},51320:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>a,metadata:()=>o,toc:()=>p});var s=n(87462),i=(n(67294),n(3905));const a={},r="Nested Types",o={unversionedId:"documentation/Design Guidelines/Type Design Guidelines/nested_types",id:"documentation/Design Guidelines/Type Design Guidelines/nested_types",title:"Nested Types",description:"A nested type is a type defined within the scope of another type, which is called the enclosing type. A nested type has access to all members of its enclosing type. For example, it has access to private fields defined in the enclosing type and to protected fields defined in all ascendants of the enclosing type.",source:"@site/docs/documentation/Design Guidelines/Type Design Guidelines/nested_types.md",sourceDirName:"documentation/Design Guidelines/Type Design Guidelines",slug:"/documentation/Design Guidelines/Type Design Guidelines/nested_types",permalink:"/xtd/docs/documentation/Design Guidelines/Type Design Guidelines/nested_types",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Interface Design",permalink:"/xtd/docs/documentation/Design Guidelines/Type Design Guidelines/interface_design"},next:{title:"Static Class Design",permalink:"/xtd/docs/documentation/Design Guidelines/Type Design Guidelines/static_class_design"}},l={},p=[],d={toc:p};function c(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,s.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"nested-types"},"Nested Types"),(0,i.kt)("p",null,"A nested type is a type defined within the scope of another type, which is called the enclosing type. A nested type has access to all members of its enclosing type. For example, it has access to private fields defined in the enclosing type and to protected fields defined in all ascendants of the enclosing type."),(0,i.kt)("p",null,"In general, nested types should be used sparingly. There are several reasons for this. Some developers are not fully familiar with the concept. These developers might, for example, have problems with the syntax of declaring variables of nested types. Nested types are also very tightly coupled with their enclosing types, and as such are not suited to be general-purpose types."),(0,i.kt)("p",null,"Nested types are best suited for modeling implementation details of their enclosing types. The end user should rarely have to declare variables of a nested type and almost never should have to explicitly instantiate nested types. For example, the enumerator of a collection can be a nested type of that collection. Enumerators are usually instantiated by their enclosing type, and because many languages support the foreach statement, enumerator variables rarely have to be declared by the end user."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," use nested types when the relationship between the nested type and its outer type is such that member-accessibility semantics are desirable."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\u274c DO NOT")," use public nested types as a logical grouping construct; use namespaces for this."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\u274c AVOID")," publicly exposed nested types. The only exception to this is if variables of the nested type need to be declared only in rare scenarios such as subclassing or other advanced customization scenarios."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\u274c DO NOT")," use nested types if the type is likely to be referenced outside of the containing type."),(0,i.kt)("p",null,"For example, an enum passed to a method defined on a class should not be defined as a nested type in the class."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\u274c DO NOT")," use nested types if they need to be instantiated by client code. If a type has a public constructor, it should probably not be nested."),(0,i.kt)("p",null,"If a type can be instantiated, that seems to indicate the type has a place in the framework on its own (you can create it, work with it, and destroy it without ever using the outer type), and thus should not be nested. Inner types should not be widely reused outside of the outer type without any relationship whatsoever to the outer type."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\u274c DO NOT")," define a nested type as a member of an interface. Many languages do not support such a construct."),(0,i.kt)("h1",{id:"see-also"},"See also"),(0,i.kt)("p",null,"\u200b"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/documentation/Design%20Guidelines/Type%20Design%20Guidelines"},"Type Design Guidelines")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/documentation/Design%20Guidelines"},"Design Guidelines")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/documentation"},"Documentation"))))}c.isMDXComponent=!0}}]);