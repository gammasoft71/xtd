"use strict";(self.webpackChunkxtd=self.webpackChunkxtd||[]).push([[8090],{3905:(t,e,a)=>{a.d(e,{Zo:()=>m,kt:()=>k});var n=a(67294);function r(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function l(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function o(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?l(Object(a),!0).forEach((function(e){r(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function i(t,e){if(null==t)return{};var a,n,r=function(t,e){if(null==t)return{};var a,n,r={},l=Object.keys(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||(r[a]=t[a]);return r}(t,e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(r[a]=t[a])}return r}var p=n.createContext({}),d=function(t){var e=n.useContext(p),a=e;return t&&(a="function"==typeof t?t(e):o(o({},e),t)),a},m=function(t){var e=d(t.components);return n.createElement(p.Provider,{value:e},t.children)},u={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},s=n.forwardRef((function(t,e){var a=t.components,r=t.mdxType,l=t.originalType,p=t.parentName,m=i(t,["components","mdxType","originalType","parentName"]),s=d(a),k=r,N=s["".concat(p,".").concat(k)]||s[k]||u[k]||l;return a?n.createElement(N,o(o({ref:e},m),{},{components:a})):n.createElement(N,o({ref:e},m))}));function k(t,e){var a=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var l=a.length,o=new Array(l);o[0]=s;var i={};for(var p in e)hasOwnProperty.call(e,p)&&(i[p]=e[p]);i.originalType=t,i.mdxType="string"==typeof t?t:r,o[1]=i;for(var d=2;d<l;d++)o[d]=a[d];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}s.displayName="MDXCreateElement"},91021:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>p,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>d});var n=a(87462),r=(a(67294),a(3905));const l={},o="Operator Overloads",i={unversionedId:"documentation/Design Guidelines/Member Design Guidelines/operator_overloads",id:"documentation/Design Guidelines/Member Design Guidelines/operator_overloads",title:"Operator Overloads",description:"The principle of encapsulation is one of the most important notions in object-oriented design. This principle states that data stored inside an object should be accessible only to that object.",source:"@site/docs/documentation/Design Guidelines/Member Design Guidelines/operator_overloads.md",sourceDirName:"documentation/Design Guidelines/Member Design Guidelines",slug:"/documentation/Design Guidelines/Member Design Guidelines/operator_overloads",permalink:"/xtd/docs/documentation/Design Guidelines/Member Design Guidelines/operator_overloads",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Member Overloading",permalink:"/xtd/docs/documentation/Design Guidelines/Member Design Guidelines/member_overloading"},next:{title:"Parameter Design",permalink:"/xtd/docs/documentation/Design Guidelines/Member Design Guidelines/parameter_design"}},p={},d=[],m={toc:d};function u(t){let{components:e,...a}=t;return(0,r.kt)("wrapper",(0,n.Z)({},m,a,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"operator-overloads"},"Operator Overloads"),(0,r.kt)("p",null,"The principle of encapsulation is one of the most important notions in object-oriented design. This principle states that data stored inside an object should be accessible only to that object."),(0,r.kt)("p",null,"Operator overloads allow framework types to appear as if they were built-in language primitives."),(0,r.kt)("p",null,"Although allowed and useful in some situations, operator overloads should be used cautiously. There are many cases in which operator overloading has been abused, such as when framework designers started to use operators for operations that should be simple methods."),(0,r.kt)("p",null,"The following guidelines should help you decide when and how to use operator overloading."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u274c AVOID")," defining operator overloads, except in types that should feel like primitive (built-in) types."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f CONSIDER")," defining operator overloads in a type that should feel like a primitive type."),(0,r.kt)("p",null,"For example, xtd:string has operator == and operator != defined."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," define operator overloads in structs that represent numbers."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u274c DO NOT")," be cute when defining operator overloads."),(0,r.kt)("p",null,"Operator overloading is useful in cases in which it is immediately obvious what the result of the operation will be. For example, it makes sense to be able to subtract one date_time from another date_time and get a time_span. However, it is not appropriate to use the logical union operator to union two database queries, or to use the shift operator to write to a stream."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u274c DO NOT")," provide operator overloads unless at least one of the operands is of the type defining the overload."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," overload operators in a symmetric fashion."),(0,r.kt)("p",null,"For example, if you overload the operator ==, you should also overload the operator !=. Similarly, if you overload the operator <, you should also overload the operator >, and so on."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f CONSIDER")," providing methods with friendly names that correspond to each overloaded operator."),(0,r.kt)("h1",{id:"xtdiequatable"},"xtd::iequatable"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://gammasoft71.github.io/xtd/reference_guides/latest/classxtd_1_1iequatable.html"},"xtd::iequatable<type_t>")," interface class implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"==")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"!=")," operators and used the ",(0,r.kt)("inlineCode",{parentName:"p"},"virtual bool equals(const type_t&) const noexcept;")," method.\nYou must just overload this method for used your own implementation."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"point")," class show how to used ",(0,r.kt)("inlineCode",{parentName:"p"},"equals")," method :"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'class point : public xtd::object, public xtd::iequatable<point> {\n  //...\n  \npublic:\n  bool equals(const point& value) const noexcept override {\n    return x_ == value.x_ && y_ == value.y_;\n  }\n  \u200b\n  //...\n  \nprivate:\n  int x_ = 0;\n  int y_ = 0;\n};\n\n//...\n\nstatic string form1::check_points(const point& p1, const point& p2) {\n  if (p1 == p2) eturn "Equals";\n  return "Not equals";\n}\n')),(0,r.kt)("h1",{id:"xtdicomparable"},"xtd::icomparable"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://gammasoft71.github.io/xtd/reference_guides/latest/classxtd_1_1icomparable.html"},"xtd::icomparable<type_t>")," interface implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"<"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"<="),", ",(0,r.kt)("inlineCode",{parentName:"p"},">")," and ",(0,r.kt)("inlineCode",{parentName:"p"},">=")," operators. and used the ",(0,r.kt)("inlineCode",{parentName:"p"},"virtual int compare_to(const type_t&) const noexcept;")," method.\nYou must just overload this method for used your own implementation."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"time_span")," class show how to used ",(0,r.kt)("inlineCode",{parentName:"p"},"compare_to")," method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class time_span : public xtd::object, public xtd::icomparable<time_span> {\n  //...\n  \npublic:\n  int compare_to(const time_span& value) const noexcept override {\n    return value_ < value.value_ ? -1 : value_ > value.value_ ? 1 : 0;\n  }\n  \u200b\n  //...\n  \nprivate:\n  int64 value_ = 0;\n};\n\n//...\n\ntime_span test::get_max_duration(const std::vector<time_span>& durations) const noexcept {\n  time_span result;\n  for (const auto& duration : durations)\n    if (duration > result) result = duration;\n  return result;\n}\n")),(0,r.kt)("h1",{id:"operator-in-c"},"Operator in C++"),(0,r.kt)("p",null,"This is a list of operators in the C++ programming languages. All the operators listed exist in C++."),(0,r.kt)("p",null,"When not overloaded, for the operators &&, ||, and , (the comma operator), there is a sequence point after the evaluation of the first operand."),(0,r.kt)("p",null,"C++ also contains the type conversion operators const_cast, static_cast, dynamic_cast, and reinterpret_cast. The formatting of these operators means that their precedence level is unimportant."),(0,r.kt)("p",null,"For the purposes of this tables, a, b, and c represent valid values (literals, values from variables, or return value), object names, or lvalues, as appropriate. R, S and T stand for any type(s), and K for a class type or enumerated type."),(0,r.kt)("p",null,'"Can overload" means that the operator can be overloaded in C++.'),(0,r.kt)("h1",{id:"arithmetic-operators"},"Arithmetic operators"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0Operator name"),(0,r.kt)("th",{parentName:"tr",align:null},"Syntax"),(0,r.kt)("th",{parentName:"tr",align:null},"Can overload"),(0,r.kt)("th",{parentName:"tr",align:null},"Prototype examples as member of K"),(0,r.kt)("th",{parentName:"tr",align:null},"Protype examples outside class definition"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Basic assignment"),(0,r.kt)("td",{parentName:"tr",align:null},"a = b"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R& K::operator =(S b);"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Addition"),(0,r.kt)("td",{parentName:"tr",align:null},"a + b"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R K::operator +(S b);"),(0,r.kt)("td",{parentName:"tr",align:null},"R operator +(K a, S b);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Subtraction"),(0,r.kt)("td",{parentName:"tr",align:null},"a - b"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R K::operator -(S b);"),(0,r.kt)("td",{parentName:"tr",align:null},"R operator -(K a, S b);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Unary plus (integer promotion)"),(0,r.kt)("td",{parentName:"tr",align:null},"+a"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R K::operator +();"),(0,r.kt)("td",{parentName:"tr",align:null},"R operator +(K a);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Unary minus (additive inverse)"),(0,r.kt)("td",{parentName:"tr",align:null},"-a"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R K::operator -();"),(0,r.kt)("td",{parentName:"tr",align:null},"R operator -(K a);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Multiplication"),(0,r.kt)("td",{parentName:"tr",align:null},"a * b"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R K::operator *(S b);"),(0,r.kt)("td",{parentName:"tr",align:null},"R operator *(K a, S b);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Division"),(0,r.kt)("td",{parentName:"tr",align:null},"a / b"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R K::operator /(S b);"),(0,r.kt)("td",{parentName:"tr",align:null},"R operator /(K a, S b);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Modulo (integer remainder)"),(0,r.kt)("td",{parentName:"tr",align:null},"a % b"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R K::operator %(S b);"),(0,r.kt)("td",{parentName:"tr",align:null},"R operator %(K a, S b);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Increment Prefix"),(0,r.kt)("td",{parentName:"tr",align:null},"++a"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R& K::operator ++();"),(0,r.kt)("td",{parentName:"tr",align:null},"R& operator ++(K& a);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Increment Postfix"),(0,r.kt)("td",{parentName:"tr",align:null},"a++."),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R K::operator ++(int);"),(0,r.kt)("td",{parentName:"tr",align:null},"R operator ++(K& a, int);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Decrement Prefix"),(0,r.kt)("td",{parentName:"tr",align:null},"--a"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R& K::operator --();"),(0,r.kt)("td",{parentName:"tr",align:null},"R& operator --(K& a);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Decrement Postfix"),(0,r.kt)("td",{parentName:"tr",align:null},"a--"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R K::operator --(int);"),(0,r.kt)("td",{parentName:"tr",align:null},"R operator --(K& a, int);")))),(0,r.kt)("h1",{id:"comparison-operators--relational-operators"},"Comparison operators / relational operators"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0Operator name"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0Syntax"),(0,r.kt)("th",{parentName:"tr",align:null},"Can overload"),(0,r.kt)("th",{parentName:"tr",align:null},"Prototype example as member of K"),(0,r.kt)("th",{parentName:"tr",align:null},"Prototype examples outside class definition"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Equal to."),(0,r.kt)("td",{parentName:"tr",align:null},"a == b"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"bool K::operator ==(S const& b) const;"),(0,r.kt)("td",{parentName:"tr",align:null},"bool operator ==(K const& a, S const& b);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Not equal to"),(0,r.kt)("td",{parentName:"tr",align:null},"a != b -or- a not_eq b"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"bool K::operator !=(S const& b) const;"),(0,r.kt)("td",{parentName:"tr",align:null},"bool operator !=(K const& a, S const& b);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Greater than"),(0,r.kt)("td",{parentName:"tr",align:null},"a ",">"," b"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"bool K::operator ",">","(S const& b) const;"),(0,r.kt)("td",{parentName:"tr",align:null},"bool operator ",">","(K const& a, S const& b);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Less than"),(0,r.kt)("td",{parentName:"tr",align:null},"a < b"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"bool K::operator <(S const& b) const;"),(0,r.kt)("td",{parentName:"tr",align:null},"bool operator <(K const& a, S const& b);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Greater than or equal to"),(0,r.kt)("td",{parentName:"tr",align:null},"a ",">","= b"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"bool K::operator ",">","=(S const& b) const;"),(0,r.kt)("td",{parentName:"tr",align:null},"bool operator ",">","=(K const& a, S const& b);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Less than or equal to"),(0,r.kt)("td",{parentName:"tr",align:null},"a <= b"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"bool K::operator <=(S const& b) const;"),(0,r.kt)("td",{parentName:"tr",align:null},"bool operator <=(K const& a, S const& b);")))),(0,r.kt)("h1",{id:"logical-operators"},"Logical operators"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0Operator name"),(0,r.kt)("th",{parentName:"tr",align:null},"Syntax"),(0,r.kt)("th",{parentName:"tr",align:null},"Can overload"),(0,r.kt)("th",{parentName:"tr",align:null},"Protype examples as member of K"),(0,r.kt)("th",{parentName:"tr",align:null},"Protype examples outside class definitions"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Logical negation (NOT)"),(0,r.kt)("td",{parentName:"tr",align:null},"!a -or- not a"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"bool K::operator !() const;"),(0,r.kt)("td",{parentName:"tr",align:null},"bool operator !(K a);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Logical AND"),(0,r.kt)("td",{parentName:"tr",align:null},"a && b -or- a and b"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"bool K::operator &&(S b) const;"),(0,r.kt)("td",{parentName:"tr",align:null},"\xa0bool operator &&(K a, S b);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Logical OR"),(0,r.kt)("td",{parentName:"tr",align:null},"a"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"b -or- a or b"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes")))),(0,r.kt)("h1",{id:"bitwise-operators"},"Bitwise operators"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Operator name"),(0,r.kt)("th",{parentName:"tr",align:null},"Syntax"),(0,r.kt)("th",{parentName:"tr",align:null},"Can overload"),(0,r.kt)("th",{parentName:"tr",align:null},"Protype examples as member of K"),(0,r.kt)("th",{parentName:"tr",align:null},"Protype examples outside class definitions"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Bitwise NOT"),(0,r.kt)("td",{parentName:"tr",align:null},"~a -or- compl a"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R K::operator ~();"),(0,r.kt)("td",{parentName:"tr",align:null},"R operator ~(K a);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Bitwise AND"),(0,r.kt)("td",{parentName:"tr",align:null},"a & b -or- a bitand b"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"\xa0R K::operator &(S b);"),(0,r.kt)("td",{parentName:"tr",align:null},"R operator &(K a, S b);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Bitwise OR"),(0,r.kt)("td",{parentName:"tr",align:null},"a"),(0,r.kt)("td",{parentName:"tr",align:null},"n -or- a bitor b"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R K::operator")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Bitwise XOR"),(0,r.kt)("td",{parentName:"tr",align:null},"a ^ b -r- a xor b"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R K::operator ^(S b);"),(0,r.kt)("td",{parentName:"tr",align:null},"R operator ^(K a, S b);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"\xa0Bitwise left shift"),(0,r.kt)("td",{parentName:"tr",align:null},"a << b"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R K::operator <<(S b);"),(0,r.kt)("td",{parentName:"tr",align:null},"R operator <<(K a, S b);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Bitwise right shift"),(0,r.kt)("td",{parentName:"tr",align:null},"a ",">",">"," b"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R K::operator ",">",">","(S b);"),(0,r.kt)("td",{parentName:"tr",align:null},"R operator ",">",">","(K a, S b);")))),(0,r.kt)("h1",{id:"compound-assignment-operators"},"Compound assignment operators"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Operator name"),(0,r.kt)("th",{parentName:"tr",align:null},"Syntax"),(0,r.kt)("th",{parentName:"tr",align:null},"Meaning."),(0,r.kt)("th",{parentName:"tr",align:null},"Can overload"),(0,r.kt)("th",{parentName:"tr",align:null},"Protype examples as member of K"),(0,r.kt)("th",{parentName:"tr",align:null},"Protype examples outside class definitions"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Addition assignment"),(0,r.kt)("td",{parentName:"tr",align:null},"a += b"),(0,r.kt)("td",{parentName:"tr",align:null},"a = a + b"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R& K::operator +=(S b);"),(0,r.kt)("td",{parentName:"tr",align:null},"R& operator +=(K& a, S b);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Subtraction assignment"),(0,r.kt)("td",{parentName:"tr",align:null},"a -= b"),(0,r.kt)("td",{parentName:"tr",align:null},"a = a - b"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R& K::operator -=(S b);"),(0,r.kt)("td",{parentName:"tr",align:null},"R& operator -=(K& a, S b);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"\xa0Multiplication assignment"),(0,r.kt)("td",{parentName:"tr",align:null},"a *= b"),(0,r.kt)("td",{parentName:"tr",align:null},"a = a * b"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R& K::operator *=(S b);"),(0,r.kt)("td",{parentName:"tr",align:null},"R& operator *=(K& a, S b);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Division assignment"),(0,r.kt)("td",{parentName:"tr",align:null},"a /= b"),(0,r.kt)("td",{parentName:"tr",align:null},"a = a / b"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R& K::operator /=(S b);"),(0,r.kt)("td",{parentName:"tr",align:null},"R& operator /=(K& a, S b);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Modulo assignment"),(0,r.kt)("td",{parentName:"tr",align:null},"a %= b"),(0,r.kt)("td",{parentName:"tr",align:null},"a = a % b"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R& K::operator %=(S b);"),(0,r.kt)("td",{parentName:"tr",align:null},"R& operator %=(K& a, S b);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Bitwise AND assignment"),(0,r.kt)("td",{parentName:"tr",align:null},"a &= b -or- a end_eq b"),(0,r.kt)("td",{parentName:"tr",align:null},"a = a & b"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R& K::operator &=(S b);"),(0,r.kt)("td",{parentName:"tr",align:null},"R& operator &=(K& a, S b);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"\xa0Bitwise OR assignment"),(0,r.kt)("td",{parentName:"tr",align:null},"a ","|","= b -or- a or_eq b"),(0,r.kt)("td",{parentName:"tr",align:null},"\xa0a = a ","|"," b"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R& K::operator ","|","=(S b);"),(0,r.kt)("td",{parentName:"tr",align:null},"\xa0R& operator ","|","=(K& a, S b);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"\xa0Bitwise XOR assignment"),(0,r.kt)("td",{parentName:"tr",align:null},"a ^= b -or- a xor_eq b"),(0,r.kt)("td",{parentName:"tr",align:null},"\xa0a = a^b"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R& K::operator ^=(S b);"),(0,r.kt)("td",{parentName:"tr",align:null},"R& operator ^=(K& a, S b);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Bitwise left shift assignment"),(0,r.kt)("td",{parentName:"tr",align:null},"a <<= b"),(0,r.kt)("td",{parentName:"tr",align:null},"a = a << b"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R& K::operator <<=(S b);"),(0,r.kt)("td",{parentName:"tr",align:null},"R& operator <<=(K& a, S b);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Bitwise right shift assignment"),(0,r.kt)("td",{parentName:"tr",align:null},"a ",">",">","= b"),(0,r.kt)("td",{parentName:"tr",align:null},"a = a ",">",">"," b"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R& K::operator ",">",">","=(S b);"),(0,r.kt)("td",{parentName:"tr",align:null},"R& operator ",">",">","=(K& a, S b);")))),(0,r.kt)("h1",{id:"member-and-pointer-operators"},"Member and pointer operators"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Operator name"),(0,r.kt)("th",{parentName:"tr",align:null},"Syntax"),(0,r.kt)("th",{parentName:"tr",align:null},"Can overload"),(0,r.kt)("th",{parentName:"tr",align:null},"Protype examples as member of K"),(0,r.kt)("th",{parentName:"tr",align:null},"Protype examples outside class definitions"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Array subsript"),(0,r.kt)("td",{parentName:"tr",align:null},"a","[b]"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R& K::operator [](S b);"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},'Indirection ("object pointed to by a")'),(0,r.kt)("td",{parentName:"tr",align:null},"a"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R& K::operator *();"),(0,r.kt)("td",{parentName:"tr",align:null},"R& operator *(K a);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},'Address ("address of a")'),(0,r.kt)("td",{parentName:"tr",align:null},"&a"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R* K::operator &();"),(0,r.kt)("td",{parentName:"tr",align:null},"R* operator &(K a);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},'\xa0Structure dereference ("member b of object pointed to by a")'),(0,r.kt)("td",{parentName:"tr",align:null},"a->b"),(0,r.kt)("td",{parentName:"tr",align:null},"\xa0Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R* K::operator -",">","();"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},'Structure reference ("member b of object a")'),(0,r.kt)("td",{parentName:"tr",align:null},"a.b"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Member pointed to by b of object pointed to by a"),(0,r.kt)("td",{parentName:"tr",align:null},"a-",">","*b"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R& K::operator -",">","*(S b);"),(0,r.kt)("td",{parentName:"tr",align:null},"R& operator -",">","*(K a, S b);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Member pointed to by b of object a"),(0,r.kt)("td",{parentName:"tr",align:null},"a.*b"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A")))),(0,r.kt)("h1",{id:"other-operators"},"Other operators"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Operator name"),(0,r.kt)("th",{parentName:"tr",align:null},"Syntax"),(0,r.kt)("th",{parentName:"tr",align:null},"Can overload"),(0,r.kt)("th",{parentName:"tr",align:null},"Protype examples as member of K"),(0,r.kt)("th",{parentName:"tr",align:null},"Protype examples outside class definitions"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Function call"),(0,r.kt)("td",{parentName:"tr",align:null},"a(a1, a2)"),(0,r.kt)("td",{parentName:"tr",align:null},"\xa0Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R K::operator ()(S a, T b, ...);"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Comma"),(0,r.kt)("td",{parentName:"tr",align:null},"a, b"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"R K::operator ,(S b);"),(0,r.kt)("td",{parentName:"tr",align:null},"\xa0R operator ,(K a, S b);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Ternary conditional"),(0,r.kt)("td",{parentName:"tr",align:null},"a ? b : c"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A"),(0,r.kt)("td",{parentName:"tr",align:null},"\xa0N/A")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Scope resolution"),(0,r.kt)("td",{parentName:"tr",align:null},"\xa0a::b"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"User-defined literals"),(0,r.kt)("td",{parentName:"tr",align:null},'"a"_b'),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A"),(0,r.kt)("td",{parentName:"tr",align:null},'R operator "" _b(T a);')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"\xa0Size-of"),(0,r.kt)("td",{parentName:"tr",align:null},"\xa0sizeof(a) -or- sizeof(type)"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Size of parameter pack"),(0,r.kt)("td",{parentName:"tr",align:null},"sizeof...(args)"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Align-of"),(0,r.kt)("td",{parentName:"tr",align:null},"alignof(type) -or- _Alignof(type)"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Type identification"),(0,r.kt)("td",{parentName:"tr",align:null},"typeid(a) -or- typeid(type)"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Conversion (C-style cast)"),(0,r.kt)("td",{parentName:"tr",align:null},"(type)a -or- type(a)"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"K::operator R();"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"\xa0static_cast conversion"),(0,r.kt)("td",{parentName:"tr",align:null},"static_cast\\<type",">","(a)"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"dynamic_cast conversion"),(0,r.kt)("td",{parentName:"tr",align:null},"dynamic_cast\\<type",">","(a)"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"const_cast conversion"),(0,r.kt)("td",{parentName:"tr",align:null},"const_cast\\<type",">","(a)"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"reinterpret_cast conversion"),(0,r.kt)("td",{parentName:"tr",align:null},"reinterpret_cast\\<type",">","(a)"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Allocate storage"),(0,r.kt)("td",{parentName:"tr",align:null},"new type"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"void* K::operator new(size_t x);"),(0,r.kt)("td",{parentName:"tr",align:null},"void* operator new(size_t x);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Allocate storage (array)"),(0,r.kt)("td",{parentName:"tr",align:null},"new type","[n]"),(0,r.kt)("td",{parentName:"tr",align:null},"\xa0Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"void* K::operator new[](size_t a);"),(0,r.kt)("td",{parentName:"tr",align:null},"\xa0void* operator new[](size_t x);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Deallocate storage"),(0,r.kt)("td",{parentName:"tr",align:null},"delete a"),(0,r.kt)("td",{parentName:"tr",align:null},"\xa0Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"void K::operator delete(void* a);"),(0,r.kt)("td",{parentName:"tr",align:null},"void operator delete(void* a);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Deallocate storage (array)"),(0,r.kt)("td",{parentName:"tr",align:null},"\xa0delete[] a"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"void K::operator delete[](void* a);"),(0,r.kt)("td",{parentName:"tr",align:null},"void operator delete[](void* a);")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Exception check"),(0,r.kt)("td",{parentName:"tr",align:null},"noexcept(a)"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A")))),(0,r.kt)("h1",{id:"see-also"},"See also"),(0,r.kt)("p",null,"\u200b"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/documentation/Design%20Guidelines/Member%20Design%20Guidelines"},"Member Design Guidelines")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/documentation/Design%20Guidelines"},"Design Guidelines")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/documentation"},"Documentation"))))}u.isMDXComponent=!0}}]);