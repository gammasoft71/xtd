"use strict";(self.webpackChunkxtd=self.webpackChunkxtd||[]).push([[7522],{91971:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>f});var a=n(76687);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),d=p(n),u=r,f=d["".concat(l,".").concat(u)]||d[u]||c[u]||s;return n?a.createElement(f,o(o({ref:t},m),{},{components:n})):a.createElement(f,o({ref:t},m))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,o=new Array(s);o[0]=u;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[d]="string"==typeof e?e:r,o[1]=i;for(var p=2;p<s;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},95073:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>s,metadata:()=>i,toc:()=>p});var a=n(855),r=(n(76687),n(91971));const s={},o="Names of Type Members",i={unversionedId:"documentation/Design Guidelines/Naming Guidelines/names_of_type_members",id:"documentation/Design Guidelines/Naming Guidelines/names_of_type_members",title:"Names of Type Members",description:"Types are made of members: methods, properties, events, constructors, and fields. The following sections describe guidelines for naming type members.",source:"@site/docs/documentation/Design Guidelines/Naming Guidelines/names_of_type_members.md",sourceDirName:"documentation/Design Guidelines/Naming Guidelines",slug:"/documentation/Design Guidelines/Naming Guidelines/names_of_type_members",permalink:"/xtd/docs/documentation/Design Guidelines/Naming Guidelines/names_of_type_members",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Names of Namespace",permalink:"/xtd/docs/documentation/Design Guidelines/Naming Guidelines/names_of_namespace"},next:{title:"Naming Parameters",permalink:"/xtd/docs/documentation/Design Guidelines/Naming Guidelines/naming_parameters"}},l={},p=[{value:"Names of Methods",id:"names-of-methods",level:2},{value:"Names of Properties",id:"names-of-properties",level:2},{value:"Names of Events",id:"names-of-events",level:2},{value:"Names of Fields",id:"names-of-fields",level:2},{value:"See also",id:"see-also",level:2}],m={toc:p},d="wrapper";function c(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"names-of-type-members"},"Names of Type Members"),(0,r.kt)("p",null,"Types are made of members: methods, properties, events, constructors, and fields. The following sections describe guidelines for naming type members."),(0,r.kt)("h2",{id:"names-of-methods"},"Names of Methods"),(0,r.kt)("p",null,"Because methods are the means of taking action, the design guidelines require that method names be verbs or verb phrases. Following this guideline also serves to distinguish method names from property and type names, which are noun or adjective phrases."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," give methods names that are verbs or verb phrases."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"\u200bclass ustring : public object {\npublic:\n  int compare_to(...);\n  std::vectory<ustring> split(...);\n  ustring trim();\n};\n")),(0,r.kt)("h2",{id:"names-of-properties"},"Names of Properties"),(0,r.kt)("p",null,"Unlike other members, properties should be given noun phrase or adjective names. That is because a property refers to data, and the name of the property reflects that. snake_casing is always used for property names."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," name properties using a noun, noun phrase, or adjective."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u274c DO NOT"),' have properties that match the name of "get',(0,r.kt)("em",{parentName:"p"},'" or "set'),'" methods as in the following example:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"ustring text_writer() const { ... }\nvoid textt_writer(const ustring& value) { ... }\nustring get_text_writer(int value) { ... }\n")),(0,r.kt)("p",null,"This pattern typically indicates that the property should really be a method."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO"),' name collection properties with a plural phrase describing the items in the collection instead of using a singular phrase followed by "_list" or "_collection."'),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," name boolean properties with an affirmative phrase (can",(0,r.kt)("em",{parentName:"p"},'seek instead of cant_seek). Optionally, you can also prefix boolean properties with "is'),'", "can',(0,r.kt)("em",{parentName:"p"},'", or "has'),'" but only where it adds value.'),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f CONSIDER")," giving a property the same name as its type."),(0,r.kt)("p",null,"For example, the following property correctly gets and sets an enum value named color, so the property is named color:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"namespace forms {\n  enum class color {\n    ...\n  };\n  \u200b\n  class control : public object {\n  public:\n    forms::color color() const { ... };\n    void color(forms::color value) { ... };\n  };\n}\n")),(0,r.kt)("h2",{id:"names-of-events"},"Names of Events"),(0,r.kt)("p",null,"Events always refer to some action, either one that is happening or one that has occurred. Therefore, as with methods, events are named with verbs, and verb tense is used to indicate the time when the event is raised."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," name events with a verb or a verb phrase."),(0,r.kt)("p",null,"Examples include clicked, painting, dropped_down, and so on."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," give events names with a concept of before and after, using the present and past tenses."),(0,r.kt)("p",null,"For example, a close event that is raised before a window is closed would be called closing, and one that is raised after the window is closed would be called closed."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u274c DO NOT"),' use "before',(0,r.kt)("em",{parentName:"p"},'" or "after'),'" prefixes or postfixes to indicate pre- and post-events. Use present and past tenses as just described.'),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO"),' name event handlers (delegates used as types of events) with the "_event_handler" suffix, as shown in the following example:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"using clicked_event_handler = delegate<void(object&, const event_args&)>;\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," use two parameters named ",(0,r.kt)("em",{parentName:"p"},"sender")," and ",(0,r.kt)("em",{parentName:"p"},"e")," in event handlers."),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"sender")," parameter represents the object that raised the event. The ",(0,r.kt)("em",{parentName:"p"},"sender")," parameter is typically of type object, even if it is possible to employ a more specific type."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO"),' name event argument classes with the "_event_args" suffix.'),(0,r.kt)("h2",{id:"names-of-fields"},"Names of Fields"),(0,r.kt)("p",null,"The field-naming guidelines apply to static public and protected fields. Internal and private fields are not covered by guidelines, and public or protected instance fields are not allowed by the Member Design Guidelines."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," use snake_casing in field names."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," name fields using a noun, noun phrase, or adjective."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u274c DO NOT")," use a prefix for field names."),(0,r.kt)("p",null,'For example, do not use "g',(0,r.kt)("em",{parentName:"p"},'" or "s'),'" to indicate static fields.'),(0,r.kt)("h2",{id:"see-also"},"See also"),(0,r.kt)("p",null,"\u200b"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/documentation/Design%20Guidelines/Naming%20Guidelines"},"Naming Guidelines")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/documentation/Design%20Guidelines"},"Design Guidelines")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/documentation"},"Documentation"))))}c.isMDXComponent=!0}}]);