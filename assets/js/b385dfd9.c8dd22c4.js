"use strict";(self.webpackChunkxtd=self.webpackChunkxtd||[]).push([[3815],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),s=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=s(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),m=s(n),d=r,f=m["".concat(l,".").concat(d)]||m[d]||u[d]||i;return n?a.createElement(f,o(o({ref:t},p),{},{components:n})):a.createElement(f,o({ref:t},p))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:r,o[1]=c;for(var s=2;s<i;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},57312:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>c,toc:()=>s});var a=n(87462),r=(n(67294),n(3905));const i={},o="Interfaces",c={unversionedId:"documentation/Guides/xtd.core/interfaces",id:"documentation/Guides/xtd.core/interfaces",title:"Interfaces",description:"Overview",source:"@site/docs/documentation/Guides/xtd.core/interfaces.md",sourceDirName:"documentation/Guides/xtd.core",slug:"/documentation/Guides/xtd.core/interfaces",permalink:"/xtd/docs/documentation/Guides/xtd.core/interfaces",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Delegates and lambdas",permalink:"/xtd/docs/documentation/Guides/xtd.core/delegates_and_lambdas"},next:{title:"Internationalization",permalink:"/xtd/docs/documentation/Guides/xtd.core/internationalization"}},l={},s=[{value:"Overview",id:"overview",level:2},{value:"Interface declarations",id:"interface-declarations",level:2},{value:"Interface implementations",id:"interface-implementations",level:2},{value:"iequatable",id:"iequatable",level:2},{value:"icomparable",id:"icomparable",level:2}],p={toc:s};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"interfaces"},"Interfaces"),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,"AnAn interface defines a contract. A class or structure that implements an interface must respect its contract. An interface can inherit from several basic interfaces, and a class or structure can implement several interfaces.\nInterfaces must contain pure virtual methods (or properties). The interface itself does not provide an implementation for the members it declares. The interface simply specifies the members that must be provided by the classes or structures that implement the interface."),(0,r.kt)("h2",{id:"interface-declarations"},"Interface declarations"),(0,r.kt)("p",null,"The following example shows how to declare an interface using the ",(0,r.kt)("a",{parentName:"p",href:"https://gammasoft71.github.io/xtd/reference_guides/latest/group__keywords.html#ga64c32b24bd922fc8189a487213592ccf"},"interface_")," keyword."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class icontrol interface_ {\npublic:\n  virtual point location() const = 0;\n  virtual icontrol& location(const& value) = 0;\n\n  virtual void paint) = 0;\n};\n")),(0,r.kt)("p",null,"The following example shows how to declare an interface using the ",(0,r.kt)("a",{parentName:"p",href:"https://gammasoft71.github.io/xtd/reference_guides/latest/classxtd_1_1interface.html"},"interface")," class."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class icontrol : public interface {\npublic:\n  virtual point location() const = 0;\n  virtual icontrol& location(const& value) = 0;\n\n  virtual void paint) = 0;\n};\n")),(0,r.kt)("h2",{id:"interface-implementations"},"Interface implementations"),(0,r.kt)("p",null,"Interfaces may be implemented by classes and structs. To indicate that a class or struct directly implements an interface, the interface is included in the base class list of the class or struct."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class icloneable interface_ {\npublic:\n  virtual std::shared_ptr<object> clone() = 0;\n};\n\nclass icomparable interface_ {\npublic:\n  virtual int compare_to(const object& other);\n};\n\nclass list_entry : public icloneable, public icomparable {\npublic:\n  std::shared_ptr<object> clone() override {...}    \n  int compare_to(const object& other) override {...}\n};\n")),(0,r.kt)("p",null,"A class or struct that directly implements an interface also implicitly implements all of the interface\u2019s base interfaces. This is true even if the class or struct doesn\u2019t explicitly list all base interfaces in the base class list."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class icontrol interface_ {\npublic:\n  virtual void paint) = 0;\n};\n\nclass itext_box : public icontrol {\npublic:\n  virtual void set_text(const string& text) = 0;\n};\n\nclass text_box : public itextBox {\npublic: \n  void Paint() override {...}\n  void SetText(string text) override {...}\n};\n")),(0,r.kt)("p",null,"Here, class text_box implements both icontrol and itext_box."),(0,r.kt)("p",null,"For multiple-inheritance interfaces, ambiguities can occur when two or more unrelated base interfaces declare members with the same name or signature. Explicit casts can be used to resolve the ambiguities."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"struct ilist interface_ {\n  virtual size_t count() const = 0;\n  virtual void count(size_t) = 0;\n};\n\nstruct icounter interface_ {\n  virtual size_t count() const = 0;\n  virtual void count(size_t) = 0;\n};\n\nstruct ilist_counter : public ilist, public icounter {\n  \n};\n\nstruct s : public ilist_counter {\n  void test(ilist_counter& x) {\n    x.count();    // Error\n    x.count(1);   // Error\n    x.ilist::count(); // Ok, invokes ilist::count method\n    x.icounter::count(1); // Ok, invokes ilist::count method\n  }\n};\n\n")),(0,r.kt)("p",null,"The first two instructions cause compile-time errors because the search for the ",(0,r.kt)("inlineCode",{parentName:"p"},"count")," member in ",(0,r.kt)("inlineCode",{parentName:"p"},"ilist_counter")," is ambiguous. As the example illustrates, the ambiguity is resolved by casting ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," into the appropriate basic interface type. Such castings have no runtime cost - they simply involve considering the instance as a less derived type at compile time."),(0,r.kt)("h2",{id:"iequatable"},"iequatable"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://gammasoft71.github.io/xtd/reference_guides/latest/classxtd_1_1iequatable.html"},"xtd::iequatable<type_t>")," interface class implement the ",(0,r.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/language/operator_precedence"},"==")," and ",(0,r.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/language/operator_precedence"},"!=")," operators and used the ",(0,r.kt)("inlineCode",{parentName:"p"},"virtual bool equals(const type_t&) const noexcept;")," method.\nYou must just overload this method for used your own implementation."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"point")," class show how to used ",(0,r.kt)("inlineCode",{parentName:"p"},"equals")," method :"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'class point : public xtd::object, public xtd::iequatable<point> {\n  //...\n  \npublic:\n  bool equals(const point& value) const noexcept override {\n    return x_ == value.x_ && y_ == value.y_;\n  }\n  \u200b\n  //...\n  \nprivate:\n  int x_ = 0;\n  int y_ = 0;\n};\n\n//...\n\nstatic string form1::check_points(const point& p1, const point& p2) {\n  if (p1 == p2) eturn "Equals";\n  return "Not equals";\n}\n')),(0,r.kt)("h2",{id:"icomparable"},"icomparable"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://gammasoft71.github.io/xtd/reference_guides/latest/classxtd_1_1icomparable.html"},"xtd::icomparable<type_t>")," interface implement the ",(0,r.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/language/operator_precedence"},"<"),", ",(0,r.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/language/operator_precedence"},"<="),", ",(0,r.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/language/operator_precedence"},">")," and ",(0,r.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/language/operator_precedence"},">=")," operators. and used the ",(0,r.kt)("inlineCode",{parentName:"p"},"virtual int compare_to(const type_t&) const noexcept;")," method.\nYou must just overload this method for used your own implementation."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"time_span")," class show how to used ",(0,r.kt)("inlineCode",{parentName:"p"},"compare_to")," method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class time_span : public xtd::object, public xtd::icomparable<time_span> {\n  //...\n  \npublic:\n  int compare_to(const time_span& value) const noexcept override {\n    return value_ < value.value_ ? -1 : value_ > value.value_ ? 1 : 0;\n  }\n  \u200b\n  //...\n  \nprivate:\n  int64 value_ = 0;\n};\n\n//...\n\ntime_span test::get_max_duration(const std::vector<time_span>& durations) const noexcept {\n  time_span result;\n  for (const auto& duration : durations)\n    if (duration > result) result = duration;\n  return result;\n}\n")),(0,r.kt)("h1",{id:"see-also"},"See also"),(0,r.kt)("p",null,"\u200b"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/documentation/Guides"},"Guides")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/documentation"},"Documentation"))))}u.isMDXComponent=!0}}]);