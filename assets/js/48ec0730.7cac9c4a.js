"use strict";(self.webpackChunkxtd=self.webpackChunkxtd||[]).push([[1265],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>p});var o=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=o.createContext({}),s=function(e){var t=o.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},m=function(e){var t=s(e.components);return o.createElement(i.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,i=e.parentName,m=c(e,["components","mdxType","originalType","parentName"]),u=s(n),p=r,h=u["".concat(i,".").concat(p)]||u[p]||d[p]||a;return n?o.createElement(h,l(l({ref:t},m),{},{components:n})):o.createElement(h,l({ref:t},m))}));function p(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,l=new Array(a);l[0]=u;var c={};for(var i in t)hasOwnProperty.call(t,i)&&(c[i]=t[i]);c.originalType=e,c.mdxType="string"==typeof e?e:r,l[1]=c;for(var s=2;s<a;s++)l[s]=n[s];return o.createElement.apply(null,l)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},89138:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>l,default:()=>d,frontMatter:()=>a,metadata:()=>c,toc:()=>s});var o=n(87462),r=(n(67294),n(3905));const a={},l="Controls management",c={unversionedId:"documentation/Guides/xtd.forms/Overview/controls_management",id:"documentation/Guides/xtd.forms/Overview/controls_management",title:"Controls management",description:"* Objects that inherit xtd::control are not copyable.",source:"@site/docs/documentation/Guides/xtd.forms/Overview/controls_management.md",sourceDirName:"documentation/Guides/xtd.forms/Overview",slug:"/documentation/Guides/xtd.forms/Overview/controls_management",permalink:"/xtd/docs/documentation/Guides/xtd.forms/Overview/controls_management",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Controls",permalink:"/xtd/docs/documentation/Guides/xtd.forms/Overview/controls"},next:{title:"Dialogs",permalink:"/xtd/docs/documentation/Guides/xtd.forms/Overview/dialogs"}},i={},s=[{value:"The following code is wrong :",id:"the-following-code-is-wrong-",level:2},{value:"You should have written this instead:",id:"you-should-have-written-this-instead",level:2},{value:"Best (easy) way",id:"best-easy-way",level:2},{value:"See also",id:"see-also",level:2}],m={toc:s};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,o.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"controls-management"},"Controls management"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Objects that inherit ",(0,r.kt)("a",{parentName:"p",href:"https://gammasoft71.github.io/xtd/reference_guides/latest/classxtd_1_1forms_1_1control.html"},"xtd::forms::control")," are not copyable.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"No object of the ",(0,r.kt)("a",{parentName:"p",href:"https://gammasoft71.github.io/xtd/reference_guides/latest/group__xtd__forms.html"},"xtd.forms")," library manages controls for you. "),(0,r.kt)("p",{parentName:"li"},"You are responsible for their creation and destruction.\nThe objects of the ",(0,r.kt)("a",{parentName:"p",href:"https://gammasoft71.github.io/xtd/reference_guides/latest/group__xtd__forms.html"},"xtd.forms")," library only contain references to controls.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("a",{parentName:"p",href:"https://gammasoft71.github.io/xtd/reference_guides/latest/group__xtd__forms.html"},"xtd.forms")," library does not manage memory for you."),(0,r.kt)("p",{parentName:"li"},"Each control manages its own resources on the ",(0,r.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/language/raii"},"RAII")," programming idiom. And it does not manage your objects.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A control can be created on the stack or dynamically in the heap."),(0,r.kt)("p",{parentName:"li"},"If you know in advance which controls need to be created you can do it on the stack.  On the other hand, if the controls are not known in advance, you will have to create them dynamically with or without a smart pointer.  Control management is up to you, the xtd.forms library doesn't care how you create controls. The xtd library does not contain a smart pointer, the std has what it takes."))),(0,r.kt)("p",null,"For example a form that contains a reference to a label, the label will never be destroyed when the form is destroyed.\nThe form will only delete the reference on the label and it also remove the resource handle.\nSo it is you who will have to delete the label instance. The ",(0,r.kt)("a",{parentName:"p",href:"https://gammasoft71.github.io/xtd/reference_guides/latest/group__xtd__forms.html"},"xtd.forms")," library will never assume what you would like to do next with your control."),(0,r.kt)("h1",{id:"copy-of-control"},"Copy of control"),(0,r.kt)("p",null,"Because of the ",(0,r.kt)("a",{parentName:"p",href:"/docs/documentation/Guides/xtd.core/Types%20overview/events"},"events"),", the controls cannot be copied."),(0,r.kt)("p",null,"Imagine a control that responds to a ",(0,r.kt)("a",{parentName:"p",href:"https://gammasoft71.github.io/xtd/reference_guides/latest/group__events.html#ga651752ad0a3ec381983aa0b367291a68"},"click")," event like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <xtd/xtd>\n\nclass my_control : public xtd::forms::control {\npublic:\n  my_control() {\n    click += {*this, &my_control::on_control_click};\n  }\n\n  void on_control_click(xtd::object& sender, const xtd::event_args& e) {\n    (*internal_counter)++;\n  }\n  private:\n    std::shared_ptr<int> internal_counter = std::make_shared<int>(0);\n};\n\nint main () {\n  my_control my_control1;\n  \n  xtd::forms::form main_form;\n  main_form.controls().push_back(my_control1);\n  \n  xtd::forms::application::run(main_form);\n}\n")),(0,r.kt)("p",null,"If you could copy my_control1 to my_control2 like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <xtd/xtd>\n\nclass my_control : public xtd::forms::control {\npublic:\n  my_control() {\n    click += {*this, &my_control::on_control_click};\n  }\n\n  my_control(const my_control&) = default;\n  my_control& operator =(const my_control&) = default;\n    \n  void on_control_click(xtd::object& sender, const xtd::event_args& e) {\n    (*internal_counter)++;\n  }\n  private:\n    std::shared_ptr<int> internal_counter = std::make_shared<int>(0);\n};\n\nint main () {\n  my_control my_control1;\n  my_control my_control2 = my_control1;\n  \n  xtd::forms::form main_form;\n  main_form.controls().push_back(my_control1);\n  \n  xtd::forms::application::run(main_form);\n}\n")),(0,r.kt)("p",null,"What would happen when you go to ",(0,r.kt)("a",{parentName:"p",href:"https://gammasoft71.github.io/xtd/reference_guides/latest/group__events.html#ga651752ad0a3ec381983aa0b367291a68"},"click")," on the control?"),(0,r.kt)("p",null,"my_control1::on_control_click would be called and my_control2::on_control_click would not be called. It seems to work.\nYes, but if you delete my_control1 after making the assignment to my_control2. No object will be called when you click."),(0,r.kt)("p",null,"So in this case it would be enough to say that in the copy constructor, the ",(0,r.kt)("a",{parentName:"p",href:"https://gammasoft71.github.io/xtd/reference_guides/latest/group__events.html#ga651752ad0a3ec381983aa0b367291a68"},"click")," event should also be implemented like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"  my_control(const my_control& other) {\n    *this = other;\n    click += {*this, &my_control::on_control_click};    \n  }\n\n  my_control& operator =(const my_control&) {\n    *this = other;\n    click += {*this, &my_control::on_control_click};\n    return *this;    \n  }\n")),(0,r.kt)("p",null,"So my_control2::on_control_click would be called too. But in this case, internal_counter would be incremented by 2.\nAnd this is not what we wanted."),(0,r.kt)("p",null,"Ok, so let's only use the click event on my_control2 and not on my_control1. That will solve everything. Well NO, because if we delete my_control2 and we decide to keep my_control1.\nNo more events will be called."),(0,r.kt)("p",null,"So to conclude. not knowing what the user of the library will want to do.\nThe controls can NEVER be copied. And to be more precise a class that contains an event can NEVER be copied."),(0,r.kt)("p",null,"If you want to have a share (not a copy) of a control, then use ",(0,r.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/memory/shared_ptr"},"std::shared_ptr")," of the std.\n",(0,r.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/memory/shared_ptr"},"std::shared_ptr")," is the best way to share a resource. "),(0,r.kt)("h1",{id:"create-and-destroy-a-control"},"Create and destroy a control"),(0,r.kt)("p",null,"When you create a label and add it to the main window as in the example below :"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <xtd/xtd>\n\nauto main() -> int {\n  xtd::forms::label my_label;\n  my_label.text("Hello, World!");\n\n  xtd::forms::form main_form;\n  main_form.controls().push_back(my_label);\n  \n  xtd::forms::application::run(main_form);\n}\n')),(0,r.kt)("p",null,"You must keep the instance my_label a live until the main_form is alive."),(0,r.kt)("p",null,"Indeed, my_label will be destroyed after main_form when the main function is finished."),(0,r.kt)("h2",{id:"the-following-code-is-wrong-"},"The following code is wrong :"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <xtd/xtd>\n\nvoid add_label(xtd::forms::form& f) {\n  xtd::forms::label my_label;\n  my_label.text("Hello, World!");\n\n  f.controls().push_back(my_label);\n}\n\nauto main() -> int {\n  xtd::forms::form main_form;\n  add_label(main_form);\n  \n  xtd::forms::application::run(main_form);\n}\n')),(0,r.kt)("p",null,"Indeed, you create my_label in the add_label method and when the method ends, my_label is deleted. when my_label is deleted, it remove automatically the reference on its control parent, in this case main_form. After add_label method ends, main_form does not contains my_label. You can see that it has no memory corruption. It's just like you never added a control to main_form."),(0,r.kt)("h2",{id:"you-should-have-written-this-instead"},"You should have written this instead:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <xtd/xtd>\n\nauto add_label(xtd::forms::form& f) {\n  auto my_label = std::make_unique<xtd::forms::label>();\n  my_label->text("Hello, World!");\n\n  f.controls().push_back(*my_label);\n  return my_label;\n}\n\nauto main() -> int {\n  xtd::forms::form main_form;\n  auto my_label = add_label(main_form);\n  \n  xtd::forms::application::run(main_form);\n}\n')),(0,r.kt)("p",null,"Always keep in mind which controls are used by which control."),(0,r.kt)("h2",{id:"best-easy-way"},"Best (easy) way"),(0,r.kt)("p",null,"An easy way to do this is OO programming. Just create a class that contains its child controls.\nThis way as soon as the class is destroyed, its child controls will be destroyed too. "),(0,r.kt)("p",null,"Like in the following example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <xtd/xtd>\n\nclass main_form : public xtd::forms::form {\npublic:\n  main_form() {\n    controls().push_back(my_label);\n    \n    my_label.text("Hello, World!");\n  }\n\nprivate:\n  xtd::forms::label my_label;\n};\n\nauto main() -> int {\n  xtd::forms::application::run(main_form());\n}\n')),(0,r.kt)("p",null,"In addition, you will respect the ",(0,r.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/language/raii"},"RAII")," programming idiom."),(0,r.kt)("h1",{id:"close-form"},"Close form"),(0,r.kt)("p",null,"Similarly, when you close a form, the child controls will never be destroyed. The form is closed, if it is a modal form (dialog), the result will be returned, but the controls are not destroyed. It is therefore your responsibility to destroy the child control(s) and the form.\nSo a closed form can be renewed at any time. There is no risk of memory leak or unallocated control when reopening (unless you have decided to do so)."),(0,r.kt)("p",null,"The following example illustrates how closing the form works:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <xtd/xtd>\n\nusing namespace xtd;\nusing namespace xtd::forms;\n\nclass form1 : public form {\npublic:\n  form1() {\n    client_size({320, 325});\n    controls().push_back_range({close_button, show_button, hide_button, cancel_close_check_box});\n    text("Form shaw and hide example");\n\n    close_button.location({10, 10});\n    close_button.size({100, 40});\n    close_button.text("Close");\n    close_button.click += [&] {\n      form2.close();\n    };\n    \n    show_button.location({10, 60});\n    show_button.size({100, 40});\n    show_button.text("Show");\n    show_button.click += [&] {\n      form2.show();\n    };\n    \n    hide_button.location({10, 110});\n    hide_button.size({100, 40});\n    hide_button.text("Hide");\n    hide_button.click += [&] {\n      form2.hide();\n    };\n    \n    cancel_close_check_box.location({10, 160});\n    cancel_close_check_box.size({100, 40});\n    cancel_close_check_box.text("cancel close");\n\n    form2.text("Close count = 0");\n    form2.form_closing += [&](object& seander, form_closing_event_args& e) {\n      e.cancel(cancel_close_check_box.checked());\n    };\n    form2.form_closed += [&] {\n      static auto close_count = 0;\n      form2.text(string::format("Close count = {}", ++close_count));\n    };\n  }\n  \nprivate:\n  button close_button;\n  button show_button;\n  button hide_button;\n  check_box cancel_close_check_box;\n  form form2;\n};\n\nauto main() -> int {\n  application::run(form1());\n}\n')),(0,r.kt)("h2",{id:"see-also"},"See also"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/documentation/Guides"},"Guides")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/documentation"},"Documentation"))))}d.isMDXComponent=!0}}]);