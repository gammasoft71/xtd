"use strict";(self.webpackChunkxtd=self.webpackChunkxtd||[]).push([[8342],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>c});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),u=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},m=function(e){var t=u(e.components);return r.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),d=u(n),c=a,g=d["".concat(l,".").concat(c)]||d[c]||p[c]||i;return n?r.createElement(g,s(s({ref:t},m),{},{components:n})):r.createElement(g,s({ref:t},m))}));function c(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,s=new Array(i);s[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:a,s[1]=o;for(var u=2;u<i;u++)s[u]=n[u];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},85522:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>u});var r=n(87462),a=(n(67294),n(3905));const i={},s="Parameter Design",o={unversionedId:"documentation/Design Guidelines/Member Design Guidelines/parameter_design",id:"documentation/Design Guidelines/Member Design Guidelines/parameter_design",title:"Parameter Design",description:"This section provides broad guidelines on parameter design, including sections with guidelines for checking arguments. In addition, you should refer to the guidelines described in Naming Parameters.",source:"@site/docs/documentation/Design Guidelines/Member Design Guidelines/parameter_design.md",sourceDirName:"documentation/Design Guidelines/Member Design Guidelines",slug:"/documentation/Design Guidelines/Member Design Guidelines/parameter_design",permalink:"/xtd/docs/documentation/Design Guidelines/Member Design Guidelines/parameter_design",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Operator Overloads",permalink:"/xtd/docs/documentation/Design Guidelines/Member Design Guidelines/operator_overloads"},next:{title:"Property Design",permalink:"/xtd/docs/documentation/Design Guidelines/Member Design Guidelines/property_design"}},l={},u=[],m={toc:u};function p(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"parameter-design"},"Parameter Design"),(0,a.kt)("p",null,"This section provides broad guidelines on parameter design, including sections with guidelines for checking arguments. In addition, you should refer to the guidelines described in ",(0,a.kt)("a",{parentName:"p",href:"/docs/documentation/Design%20Guidelines/Naming%20Guidelines/naming_parameters"},"Naming Parameters"),"."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," use the least derived parameter type that provides the functionality required by the member."),(0,a.kt)("p",null,"For example, suppose you want to design a method that change the size of any control. Such a method should take xtd::forms::control as the parameter, not xtd::forms::button or xtd::forms::text_box, for example."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"\u274c DO NOT")," use reserved parameters."),(0,a.kt)("p",null,"If more input to a member is needed in some future version, a new overload can be added."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"\u274c DO NOT")," have publicly exposed methods that take pointers, arrays of pointers, or multidimensional arrays as parameters."),(0,a.kt)("p",null,"Pointers and multidimensional arrays are relatively difficult to use properly. In almost all cases, APIs can be redesigned to avoid taking these types as parameters."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," place all parameters following all of the by-value, const ref and ref parameters, even if it results in an inconsistency in parameter ordering between overloads (see ",(0,a.kt)("a",{parentName:"p",href:"/docs/documentation/Design%20Guidelines/Member%20Design%20Guidelines/member_overloading"},"Member Overloading"),")."),(0,a.kt)("p",null,"The ref parameters can be seen as extra return values, and grouping them together makes the method signature easier to understand."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," be consistent in naming parameters when overriding members or implementing interface members."),(0,a.kt)("p",null,"This better communicates the relationship between the methods."),(0,a.kt)("h1",{id:"choosing-between-enum-and-boolean-parameters"},"Choosing Between enum and boolean Parameters"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," use enums if a member would otherwise have two or more boolean parameters."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"\u274c DO NOT")," use booleans unless you are absolutely sure there will never be a need for more than two values."),(0,a.kt)("p",null,"Enums give you some room for future addition of values, but you should be aware of all the implications of adding values to enums, which are described in ",(0,a.kt)("a",{parentName:"p",href:"/docs/documentation/Design%20Guidelines/Type%20Design%20Guidelines/enum_design"},"Enum Design"),"."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"\u2714\ufe0f CONSIDER")," using booleans for constructor parameters that are truly two-state values and are simply used to initialize boolean properties."),(0,a.kt)("h1",{id:"validating-arguments"},"Validating Arguments"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," validate arguments passed to public, protected, or explicitly implemented members. Throw xtd::argument_exception, or one of its subclasses, if the validation fails."),(0,a.kt)("p",null,"Note that the actual validation does not necessarily have to happen in the public or protected member itself. It could happen at a lower level in some private routine. The main point is that the entire surface area that is exposed to the end users checks the arguments."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," throw xtd::argument_null_exception if a nullptr argument is passed and the member does not support nullptr arguments."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," validate enum parameters. Do not assume enum arguments will be in the range defined by the enum. The C++ language allows casting any integer value into an enum value even if the value is not defined in the enum."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," be aware that mutable arguments might have changed after they were validated."),(0,a.kt)("p",null,"If the member is security sensitive, you are encouraged to make a copy and then validate and process the argument."),(0,a.kt)("h1",{id:"parameter-passing"},"Parameter Passing"),(0,a.kt)("p",null,"From the perspective of a framework designer, there are three main groups of parameters: by-value parameters, const ref parameters, and ref parameters."),(0,a.kt)("p",null,"When an argument is passed through a by-value or const ref parameter, the member receives a copy of the actual argument passed in. If the argument is a value type, a copy of the argument is put on the stack. If the argument is a reference type, a copy of the reference is put on the stack. The C++ languages, default to passing parameters by value."),(0,a.kt)("p",null,"When an argument is passed through a ref parameter, the member receives a reference to the actual argument passed in. A reference to the argument is put on the stack. Ref parameters can be used to allow the member to modify arguments passed by the caller."),(0,a.kt)("h1",{id:"see-also"},"See also"),(0,a.kt)("p",null,"\u200b"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/docs/documentation/Design%20Guidelines/Member%20Design%20Guidelines"},"Member Design Guidelines")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/docs/documentation/Design%20Guidelines"},"Design Guidelines")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/docs/documentation"},"Documentation"))))}p.isMDXComponent=!0}}]);