"use strict";(self.webpackChunkxtd=self.webpackChunkxtd||[]).push([[1861],{3905:(t,e,n)=>{n.d(e,{Zo:()=>u,kt:()=>g});var a=n(67294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function l(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?i(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function o(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},i=Object.keys(t);for(a=0;a<i.length;a++)n=i[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(a=0;a<i.length;a++)n=i[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var s=a.createContext({}),d=function(t){var e=a.useContext(s),n=e;return t&&(n="function"==typeof t?t(e):l(l({},e),t)),n},u=function(t){var e=d(t.components);return a.createElement(s.Provider,{value:e},t.children)},p={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},m=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,i=t.originalType,s=t.parentName,u=o(t,["components","mdxType","originalType","parentName"]),m=d(n),g=r,c=m["".concat(s,".").concat(g)]||m[g]||p[g]||i;return n?a.createElement(c,l(l({ref:e},u),{},{components:n})):a.createElement(c,l({ref:e},u))}));function g(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var i=n.length,l=new Array(i);l[0]=m;var o={};for(var s in e)hasOwnProperty.call(e,s)&&(o[s]=e[s]);o.originalType=t,o.mdxType="string"==typeof t?t:r,l[1]=o;for(var d=2;d<i;d++)l[d]=n[d];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},78785:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>s,contentTitle:()=>l,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var a=n(87462),r=(n(67294),n(3905));const i={},l="General Naming Conventions",o={unversionedId:"documentation/Design Guidelines/Naming Guidelines/general_naming_conventions",id:"documentation/Design Guidelines/Naming Guidelines/general_naming_conventions",title:"General Naming Conventions",description:"This section describes general naming conventions that relate to word choice, guidelines on using abbreviations and acronyms, and recommendations on how to avoid using c++ names.",source:"@site/docs/documentation/Design Guidelines/Naming Guidelines/general_naming_conventions.md",sourceDirName:"documentation/Design Guidelines/Naming Guidelines",slug:"/documentation/Design Guidelines/Naming Guidelines/general_naming_conventions",permalink:"/xtd/docs/documentation/Design Guidelines/Naming Guidelines/general_naming_conventions",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Capitalisation Conventions",permalink:"/xtd/docs/documentation/Design Guidelines/Naming Guidelines/capitalisation_conventions"},next:{title:"Names of Classes, Structs and Interfaces",permalink:"/xtd/docs/documentation/Design Guidelines/Naming Guidelines/names_of_classes_structs_and_interfaces"}},s={},d=[{value:"Word Choice",id:"word-choice",level:2},{value:"Using Abbreviations and Acronyms",id:"using-abbreviations-and-acronyms",level:2},{value:"Avoiding C++ Names",id:"avoiding-c-names",level:2},{value:"Naming New Versions of Existing APIs",id:"naming-new-versions-of-existing-apis",level:2},{value:"See also",id:"see-also",level:2}],u={toc:d};function p(t){let{components:e,...n}=t;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"general-naming-conventions"},"General Naming Conventions"),(0,r.kt)("p",null,"This section describes general naming conventions that relate to word choice, guidelines on using abbreviations and acronyms, and recommendations on how to avoid using c++ names."),(0,r.kt)("h2",{id:"word-choice"},"Word Choice"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," choose easily readable identifier names."),(0,r.kt)("p",null,"For example, a property named horizontal_alignment is more English-readable than alignment_horizontal."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," favour readability over brevity."),(0,r.kt)("p",null,"The property name can_scroll_horizontally is better than scrollable_x (an obscure reference to the X-axis)."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u274c DO NOT")," use hyphens, or any other non-alphanumeric characters except underscores."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u274c DO NOT")," use Hungarian notation."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u274c AVOID")," using identifiers that conflict with keywords of widely used programming languages."),(0,r.kt)("h2",{id:"using-abbreviations-and-acronyms"},"Using Abbreviations and Acronyms"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u274c DO NOT")," use abbreviations or contractions as part of identifier names."),(0,r.kt)("p",null,"For example, use get_window rather than get_win."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u274c DO NOT")," use any acronyms that are not widely accepted, and even if they are, only when necessary."),(0,r.kt)("h2",{id:"avoiding-c-names"},"Avoiding C++ Names"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," use semantically interesting names rather than language-specific keywords for type names."),(0,r.kt)("p",null,"For example, get_length is a better name than get_int."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," use a generic ",(0,r.kt)("strong",{parentName:"p"},"cstdint")," type name, rather than a C++ name, in the rare cases when an identifier has no semantic meaning beyond its type."),(0,r.kt)("p",null,"For example, a method converting to int64_t should be named to_int64, not to_long (because int64_t is a ",(0,r.kt)("strong",{parentName:"p"},"cstdint")," name for the c++ alias long long)."),(0,r.kt)("p",null,"The following table presents several base data types using the ",(0,r.kt)("strong",{parentName:"p"},"cstdint")," type names (as well as the corresponding type names for all platform)."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0C++"),(0,r.kt)("th",{parentName:"tr",align:null},"cstdint"),(0,r.kt)("th",{parentName:"tr",align:null},"xtd"),(0,r.kt)("th",{parentName:"tr",align:null},"Size in bytes"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"char"),(0,r.kt)("td",{parentName:"tr",align:null},"uint8_t"),(0,r.kt)("td",{parentName:"tr",align:null},"sbyte"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"unsigned char"),(0,r.kt)("td",{parentName:"tr",align:null},"int8_t"),(0,r.kt)("td",{parentName:"tr",align:null},"byte"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"short"),(0,r.kt)("td",{parentName:"tr",align:null},"int16_t"),(0,r.kt)("td",{parentName:"tr",align:null},"int16"),(0,r.kt)("td",{parentName:"tr",align:null},"2")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"unsigned short"),(0,r.kt)("td",{parentName:"tr",align:null},"uint16_t"),(0,r.kt)("td",{parentName:"tr",align:null},"uint16"),(0,r.kt)("td",{parentName:"tr",align:null},"2")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"int"),(0,r.kt)("td",{parentName:"tr",align:null},"int32_t"),(0,r.kt)("td",{parentName:"tr",align:null},"int32"),(0,r.kt)("td",{parentName:"tr",align:null},"4")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"\xa0unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"uint32_t"),(0,r.kt)("td",{parentName:"tr",align:null},"uint32"),(0,r.kt)("td",{parentName:"tr",align:null},"4")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"long long"),(0,r.kt)("td",{parentName:"tr",align:null},"int64_t"),(0,r.kt)("td",{parentName:"tr",align:null},"int64"),(0,r.kt)("td",{parentName:"tr",align:null},"8")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"unsigned long long"),(0,r.kt)("td",{parentName:"tr",align:null},"uint64_t"),(0,r.kt)("td",{parentName:"tr",align:null},"uint64"),(0,r.kt)("td",{parentName:"tr",align:null},"8")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"float"),(0,r.kt)("td",{parentName:"tr",align:null},"float"),(0,r.kt)("td",{parentName:"tr",align:null},"float"),(0,r.kt)("td",{parentName:"tr",align:null},"4")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"double"),(0,r.kt)("td",{parentName:"tr",align:null},"double"),(0,r.kt)("td",{parentName:"tr",align:null},"double"),(0,r.kt)("td",{parentName:"tr",align:null},"8")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"long double"),(0,r.kt)("td",{parentName:"tr",align:null},"long double"),(0,r.kt)("td",{parentName:"tr",align:null},"decimal"),(0,r.kt)("td",{parentName:"tr",align:null},"16")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"\xa0bool"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"\xa0wchar_t"),(0,r.kt)("td",{parentName:"tr",align:null},"wchar_t"),(0,r.kt)("td",{parentName:"tr",align:null},"wcchar"),(0,r.kt)("td",{parentName:"tr",align:null},"4")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"char*"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"variable")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," use a common name, such as value or item, rather than repeating the type name, in the rare cases when an identifier has no semantic meaning and the type of the parameter is not important."),(0,r.kt)("h2",{id:"naming-new-versions-of-existing-apis"},"Naming New Versions of Existing APIs"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," use a name similar to the old API when creating new versions of an existing API."),(0,r.kt)("p",null,"This helps to highlight the relationship between the APIs."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," prefer adding a suffix rather than a prefix to indicate a new version of an existing API."),(0,r.kt)("p",null,"This will assist discovery when browsing documentation, or using Intellisense. The old version of the API will be organised close to the new APIs, because most browsers and Intellisense show identifiers in alphabetical order."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f CONSIDER")," using a brand new, but meaningful identifier, instead of adding a suffix or a prefix."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," use a numeric suffix to indicate a new version of an existing API, particularly if the existing name of the API is the only name that makes sense (i.e., if it is an industry standard) and if adding any meaningful suffix (or changing the name) is not an appropriate option."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u274c DO NOT"),' use the "ex" (or a similar) suffix for an identifier to distinguish it from an earlier version of the same API.'),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO"),' use the "64" suffix when introducing versions of APIs that operate on a 64-bit integer (a long integer) instead of a 32-bit integer. You only need to take this approach when the existing 32-bit API exists; don\u2019t do it for brand new APIs with only a 64-bit version.'),(0,r.kt)("h2",{id:"see-also"},"See also"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/documentation/Design%20Guidelines/Naming%20Guidelines"},"Naming Guidelines")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/documentation/Design%20Guidelines"},"Design Guidelines")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/documentation"},"Documentation"))))}p.isMDXComponent=!0}}]);