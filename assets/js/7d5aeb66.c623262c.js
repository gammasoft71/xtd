"use strict";(self.webpackChunkxtd=self.webpackChunkxtd||[]).push([[3376],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var i=n(67294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,i,s=function(e,t){if(null==e)return{};var n,i,s={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=i.createContext({}),c=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,s=e.mdxType,r=e.originalType,l=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),d=c(n),m=s,f=d["".concat(l,".").concat(m)]||d[m]||p[m]||r;return n?i.createElement(f,a(a({ref:t},u),{},{components:n})):i.createElement(f,a({ref:t},u))}));function m(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var r=n.length,a=new Array(r);a[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:s,a[1]=o;for(var c=2;c<r;c++)a[c]=n[c];return i.createElement.apply(null,a)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"},10793:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var i=n(87462),s=(n(67294),n(3905));const r={},a="Type Design Guidelines",o={unversionedId:"documentation/Design Guidelines/Type Design Guidelines/README",id:"documentation/Design Guidelines/Type Design Guidelines/README",title:"Type Design Guidelines",description:"From the c++ perspective, there are only two categories of types-natives types and class types\u2014but for the purpose of a discussion about framework design, we divide types into more logical groups, each with its own specific design rules.",source:"@site/docs/documentation/Design Guidelines/Type Design Guidelines/README.md",sourceDirName:"documentation/Design Guidelines/Type Design Guidelines",slug:"/documentation/Design Guidelines/Type Design Guidelines/",permalink:"/xtd/docs/documentation/Design Guidelines/Type Design Guidelines/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Naming Resources",permalink:"/xtd/docs/documentation/Design Guidelines/Naming Guidelines/naming_resources"},next:{title:"Abstract Class Design",permalink:"/xtd/docs/documentation/Design Guidelines/Type Design Guidelines/abstract_class_design"}},l={},c=[],u={toc:c};function p(e){let{components:t,...n}=e;return(0,s.kt)("wrapper",(0,i.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"type-design-guidelines"},"Type Design Guidelines"),(0,s.kt)("p",null,"From the c++ perspective, there are only two categories of types-natives types and class types\u2014but for the purpose of a discussion about framework design, we divide types into more logical groups, each with its own specific design rules."),(0,s.kt)("p",null,"Classes are the general case of reference types. They make up the bulk of types in the majority of frameworks. Classes owe their popularity to the rich set of object-oriented features they support and to their general applicability. Base classes and abstract classes are special logical groups related to extensibility."),(0,s.kt)("p",null,"Interfaces are types that can be implemented by both reference types and value types. They can thus serve as roots of polymorphic hierarchies of reference types and value types."),(0,s.kt)("p",null,"Structs are the general case of value types and should be reserved for small, simple types, similar to language primitives."),(0,s.kt)("p",null,"Enums are a special case of value types used to define short sets of values, such as days of the week, console colors, and so on."),(0,s.kt)("p",null,"Static classes are types intended to be containers for static members. They are commonly used to provide shortcuts to other operations."),(0,s.kt)("p",null,"Delegates, exceptions, attributes, arrays, and collections are all special cases of reference types intended for specific uses, and guidelines for their design and usage are discussed elsewhere in this book."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"\u2714\ufe0f DO")," ensure that each type is a well-defined set of related members, not just a random collection of unrelated functionality."),(0,s.kt)("h1",{id:"in-this-section"},"In This Section"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"/docs/documentation/Design%20Guidelines/Type%20Design%20Guidelines/choosing_between_class_and_struct"},"Choosing Between Class and Struct")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"/docs/documentation/Design%20Guidelines/Type%20Design%20Guidelines/abstract_class_design"},"Abstract Class Design")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"/docs/documentation/Design%20Guidelines/Type%20Design%20Guidelines/static_class_design"},"Static Class Design")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"/docs/documentation/Design%20Guidelines/Type%20Design%20Guidelines/interface_design"},"Interface Design")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"/docs/documentation/Design%20Guidelines/Type%20Design%20Guidelines/struct_design"},"Struct Design")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"/docs/documentation/Design%20Guidelines/Type%20Design%20Guidelines/enum_design"},"Enum Design")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"/docs/documentation/Design%20Guidelines/Type%20Design%20Guidelines/nested_types"},"Nested Types"))),(0,s.kt)("h1",{id:"see-also"},"See also"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"/docs/documentation/Design%20Guidelines"},"Design Guidelines")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"/docs/documentation"},"Documentation"))))}p.isMDXComponent=!0}}]);